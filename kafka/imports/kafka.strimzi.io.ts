// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema Kafka
 */
export class Kafka extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Kafka"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'Kafka',
  }

  /**
   * Renders a Kubernetes manifest for "Kafka".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaProps = {}): any {
    return {
      ...Kafka.GVK,
      ...toJson_KafkaProps(props),
    };
  }

  /**
   * Defines a "Kafka" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaProps = {}) {
    super(scope, id, {
      ...Kafka.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Kafka.GVK,
      ...toJson_KafkaProps(resolved),
    };
  }
}

/**
 * @schema Kafka
 */
export interface KafkaProps {
  /**
   * @schema Kafka#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
   *
   * @schema Kafka#spec
   */
  readonly spec?: KafkaSpec;

}

/**
 * Converts an object of type 'KafkaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaProps(obj: KafkaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
 *
 * @schema KafkaSpec
 */
export interface KafkaSpec {
  /**
   * Configuration of the Kafka cluster.
   *
   * @schema KafkaSpec#kafka
   */
  readonly kafka: KafkaSpecKafka;

  /**
   * Configuration of the ZooKeeper cluster.
   *
   * @schema KafkaSpec#zookeeper
   */
  readonly zookeeper: KafkaSpecZookeeper;

  /**
   * Configuration of the Entity Operator.
   *
   * @schema KafkaSpec#entityOperator
   */
  readonly entityOperator?: KafkaSpecEntityOperator;

  /**
   * Configuration of the cluster certificate authority.
   *
   * @schema KafkaSpec#clusterCa
   */
  readonly clusterCa?: KafkaSpecClusterCa;

  /**
   * Configuration of the clients certificate authority.
   *
   * @schema KafkaSpec#clientsCa
   */
  readonly clientsCa?: KafkaSpecClientsCa;

  /**
   * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
   *
   * @schema KafkaSpec#cruiseControl
   */
  readonly cruiseControl?: KafkaSpecCruiseControl;

  /**
   * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
   *
   * @schema KafkaSpec#jmxTrans
   */
  readonly jmxTrans?: KafkaSpecJmxTrans;

  /**
   * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
   *
   * @schema KafkaSpec#kafkaExporter
   */
  readonly kafkaExporter?: KafkaSpecKafkaExporter;

  /**
   * A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
   *
   * @schema KafkaSpec#maintenanceTimeWindows
   */
  readonly maintenanceTimeWindows?: string[];

}

/**
 * Converts an object of type 'KafkaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpec(obj: KafkaSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kafka': toJson_KafkaSpecKafka(obj.kafka),
    'zookeeper': toJson_KafkaSpecZookeeper(obj.zookeeper),
    'entityOperator': toJson_KafkaSpecEntityOperator(obj.entityOperator),
    'clusterCa': toJson_KafkaSpecClusterCa(obj.clusterCa),
    'clientsCa': toJson_KafkaSpecClientsCa(obj.clientsCa),
    'cruiseControl': toJson_KafkaSpecCruiseControl(obj.cruiseControl),
    'jmxTrans': toJson_KafkaSpecJmxTrans(obj.jmxTrans),
    'kafkaExporter': toJson_KafkaSpecKafkaExporter(obj.kafkaExporter),
    'maintenanceTimeWindows': obj.maintenanceTimeWindows?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Kafka cluster.
 *
 * @schema KafkaSpecKafka
 */
export interface KafkaSpecKafka {
  /**
   * The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaSpecKafka#version
   */
  readonly version?: string;

  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecKafka#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
   *
   * @schema KafkaSpecKafka#image
   */
  readonly image?: string;

  /**
   * Configures listeners of Kafka brokers.
   *
   * @schema KafkaSpecKafka#listeners
   */
  readonly listeners: KafkaSpecKafkaListeners[];

  /**
   * Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers,node.id, process.roles, controller. (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, sasl.server.max.receive.size,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms,cruise.control.metrics.topic.min.insync.replicas,controller.quorum.election.backoff.max.ms, controller.quorum.election.timeout.ms, controller.quorum.fetch.timeout.ms).
   *
   * @schema KafkaSpecKafka#config
   */
  readonly config?: any;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecKafka#storage
   */
  readonly storage: KafkaSpecKafkaStorage;

  /**
   * Authorization configuration for Kafka brokers.
   *
   * @schema KafkaSpecKafka#authorization
   */
  readonly authorization?: KafkaSpecKafkaAuthorization;

  /**
   * Configuration of the `broker.rack` broker config.
   *
   * @schema KafkaSpecKafka#rack
   */
  readonly rack?: KafkaSpecKafkaRack;

  /**
   * The image of the init container used for initializing the `broker.rack`.
   *
   * @schema KafkaSpecKafka#brokerRackInitImage
   */
  readonly brokerRackInitImage?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecKafka#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecKafka#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecKafka#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecKafkaJvmOptions;

  /**
   * JMX Options for Kafka brokers.
   *
   * @schema KafkaSpecKafka#jmxOptions
   */
  readonly jmxOptions?: KafkaSpecKafkaJmxOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafka#resources
   */
  readonly resources?: KafkaSpecKafkaResources;

  /**
   * Metrics configuration.
   *
   * @schema KafkaSpecKafka#metricsConfig
   */
  readonly metricsConfig?: KafkaSpecKafkaMetricsConfig;

  /**
   * Logging configuration for Kafka.
   *
   * @schema KafkaSpecKafka#logging
   */
  readonly logging?: KafkaSpecKafkaLogging;

  /**
   * Template for Kafka cluster resources. The template allows users to specify how the `StatefulSet`, `Pods`, and `Services` are generated.
   *
   * @schema KafkaSpecKafka#template
   */
  readonly template?: KafkaSpecKafkaTemplate;

}

/**
 * Converts an object of type 'KafkaSpecKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafka(obj: KafkaSpecKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'replicas': obj.replicas,
    'image': obj.image,
    'listeners': obj.listeners?.map(y => toJson_KafkaSpecKafkaListeners(y)),
    'config': obj.config,
    'storage': toJson_KafkaSpecKafkaStorage(obj.storage),
    'authorization': toJson_KafkaSpecKafkaAuthorization(obj.authorization),
    'rack': toJson_KafkaSpecKafkaRack(obj.rack),
    'brokerRackInitImage': obj.brokerRackInitImage,
    'livenessProbe': toJson_KafkaSpecKafkaLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecKafkaReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaSpecKafkaJvmOptions(obj.jvmOptions),
    'jmxOptions': toJson_KafkaSpecKafkaJmxOptions(obj.jmxOptions),
    'resources': toJson_KafkaSpecKafkaResources(obj.resources),
    'metricsConfig': toJson_KafkaSpecKafkaMetricsConfig(obj.metricsConfig),
    'logging': toJson_KafkaSpecKafkaLogging(obj.logging),
    'template': toJson_KafkaSpecKafkaTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the ZooKeeper cluster.
 *
 * @schema KafkaSpecZookeeper
 */
export interface KafkaSpecZookeeper {
  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecZookeeper#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecZookeeper#image
   */
  readonly image?: string;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecZookeeper#storage
   */
  readonly storage: KafkaSpecZookeeperStorage;

  /**
   * The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
   *
   * @schema KafkaSpecZookeeper#config
   */
  readonly config?: any;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecZookeeper#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecZookeeperLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecZookeeper#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecZookeeperReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecZookeeper#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecZookeeperJvmOptions;

  /**
   * JMX Options for Zookeeper nodes.
   *
   * @schema KafkaSpecZookeeper#jmxOptions
   */
  readonly jmxOptions?: KafkaSpecZookeeperJmxOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecZookeeper#resources
   */
  readonly resources?: KafkaSpecZookeeperResources;

  /**
   * Metrics configuration.
   *
   * @schema KafkaSpecZookeeper#metricsConfig
   */
  readonly metricsConfig?: KafkaSpecZookeeperMetricsConfig;

  /**
   * Logging configuration for ZooKeeper.
   *
   * @schema KafkaSpecZookeeper#logging
   */
  readonly logging?: KafkaSpecZookeeperLogging;

  /**
   * Template for ZooKeeper cluster resources. The template allows users to specify how the `StatefulSet`, `Pods`, and `Services` are generated.
   *
   * @schema KafkaSpecZookeeper#template
   */
  readonly template?: KafkaSpecZookeeperTemplate;

}

/**
 * Converts an object of type 'KafkaSpecZookeeper' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeper(obj: KafkaSpecZookeeper | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas,
    'image': obj.image,
    'storage': toJson_KafkaSpecZookeeperStorage(obj.storage),
    'config': obj.config,
    'livenessProbe': toJson_KafkaSpecZookeeperLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecZookeeperReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaSpecZookeeperJvmOptions(obj.jvmOptions),
    'jmxOptions': toJson_KafkaSpecZookeeperJmxOptions(obj.jmxOptions),
    'resources': toJson_KafkaSpecZookeeperResources(obj.resources),
    'metricsConfig': toJson_KafkaSpecZookeeperMetricsConfig(obj.metricsConfig),
    'logging': toJson_KafkaSpecZookeeperLogging(obj.logging),
    'template': toJson_KafkaSpecZookeeperTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Entity Operator.
 *
 * @schema KafkaSpecEntityOperator
 */
export interface KafkaSpecEntityOperator {
  /**
   * Configuration of the Topic Operator.
   *
   * @schema KafkaSpecEntityOperator#topicOperator
   */
  readonly topicOperator?: KafkaSpecEntityOperatorTopicOperator;

  /**
   * Configuration of the User Operator.
   *
   * @schema KafkaSpecEntityOperator#userOperator
   */
  readonly userOperator?: KafkaSpecEntityOperatorUserOperator;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecEntityOperator#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecEntityOperatorTlsSidecar;

  /**
   * Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
   *
   * @schema KafkaSpecEntityOperator#template
   */
  readonly template?: KafkaSpecEntityOperatorTemplate;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperator(obj: KafkaSpecEntityOperator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topicOperator': toJson_KafkaSpecEntityOperatorTopicOperator(obj.topicOperator),
    'userOperator': toJson_KafkaSpecEntityOperatorUserOperator(obj.userOperator),
    'tlsSidecar': toJson_KafkaSpecEntityOperatorTlsSidecar(obj.tlsSidecar),
    'template': toJson_KafkaSpecEntityOperatorTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the cluster certificate authority.
 *
 * @schema KafkaSpecClusterCa
 */
export interface KafkaSpecClusterCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClusterCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
   *
   * @default true`.
   * @schema KafkaSpecClusterCa#generateSecretOwnerReference
   */
  readonly generateSecretOwnerReference?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClusterCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClusterCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClusterCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClusterCaCertificateExpirationPolicy;

}

/**
 * Converts an object of type 'KafkaSpecClusterCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecClusterCa(obj: KafkaSpecClusterCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generateCertificateAuthority': obj.generateCertificateAuthority,
    'generateSecretOwnerReference': obj.generateSecretOwnerReference,
    'validityDays': obj.validityDays,
    'renewalDays': obj.renewalDays,
    'certificateExpirationPolicy': obj.certificateExpirationPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the clients certificate authority.
 *
 * @schema KafkaSpecClientsCa
 */
export interface KafkaSpecClientsCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClientsCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
   *
   * @default true`.
   * @schema KafkaSpecClientsCa#generateSecretOwnerReference
   */
  readonly generateSecretOwnerReference?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClientsCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClientsCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClientsCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClientsCaCertificateExpirationPolicy;

}

/**
 * Converts an object of type 'KafkaSpecClientsCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecClientsCa(obj: KafkaSpecClientsCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generateCertificateAuthority': obj.generateCertificateAuthority,
    'generateSecretOwnerReference': obj.generateSecretOwnerReference,
    'validityDays': obj.validityDays,
    'renewalDays': obj.renewalDays,
    'certificateExpirationPolicy': obj.certificateExpirationPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
 *
 * @schema KafkaSpecCruiseControl
 */
export interface KafkaSpecCruiseControl {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecCruiseControl#image
   */
  readonly image?: string;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecCruiseControl#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecCruiseControlTlsSidecar;

  /**
   * CPU and memory resources to reserve for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#resources
   */
  readonly resources?: KafkaSpecCruiseControlResources;

  /**
   * Pod liveness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlLivenessProbe;

  /**
   * Pod readiness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlReadinessProbe;

  /**
   * JVM Options for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecCruiseControlJvmOptions;

  /**
   * Logging configuration (Log4j 2) for Cruise Control.
   *
   * @schema KafkaSpecCruiseControl#logging
   */
  readonly logging?: KafkaSpecCruiseControlLogging;

  /**
   * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
   *
   * @schema KafkaSpecCruiseControl#template
   */
  readonly template?: KafkaSpecCruiseControlTemplate;

  /**
   * The Cruise Control `brokerCapacity` configuration.
   *
   * @schema KafkaSpecCruiseControl#brokerCapacity
   */
  readonly brokerCapacity?: KafkaSpecCruiseControlBrokerCapacity;

  /**
   * The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, capacity.config.file, self.healing., ssl., kafka.broker.failure.detection.enable, topic.config.provider.class (with the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, webserver.http.cors.enabled, webserver.http.cors.origin, webserver.http.cors.exposeheaders, webserver.security.enable, webserver.ssl.enable).
   *
   * @schema KafkaSpecCruiseControl#config
   */
  readonly config?: any;

  /**
   * Metrics configuration.
   *
   * @schema KafkaSpecCruiseControl#metricsConfig
   */
  readonly metricsConfig?: KafkaSpecCruiseControlMetricsConfig;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControl(obj: KafkaSpecCruiseControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'tlsSidecar': toJson_KafkaSpecCruiseControlTlsSidecar(obj.tlsSidecar),
    'resources': toJson_KafkaSpecCruiseControlResources(obj.resources),
    'livenessProbe': toJson_KafkaSpecCruiseControlLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecCruiseControlReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaSpecCruiseControlJvmOptions(obj.jvmOptions),
    'logging': toJson_KafkaSpecCruiseControlLogging(obj.logging),
    'template': toJson_KafkaSpecCruiseControlTemplate(obj.template),
    'brokerCapacity': toJson_KafkaSpecCruiseControlBrokerCapacity(obj.brokerCapacity),
    'config': obj.config,
    'metricsConfig': toJson_KafkaSpecCruiseControlMetricsConfig(obj.metricsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
 *
 * @schema KafkaSpecJmxTrans
 */
export interface KafkaSpecJmxTrans {
  /**
   * The image to use for the JmxTrans.
   *
   * @schema KafkaSpecJmxTrans#image
   */
  readonly image?: string;

  /**
   * Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#outputDefinitions
   */
  readonly outputDefinitions: KafkaSpecJmxTransOutputDefinitions[];

  /**
   * Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
   *
   * @schema KafkaSpecJmxTrans#logLevel
   */
  readonly logLevel?: string;

  /**
   * Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#kafkaQueries
   */
  readonly kafkaQueries: KafkaSpecJmxTransKafkaQueries[];

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecJmxTrans#resources
   */
  readonly resources?: KafkaSpecJmxTransResources;

  /**
   * Template for JmxTrans resources.
   *
   * @schema KafkaSpecJmxTrans#template
   */
  readonly template?: KafkaSpecJmxTransTemplate;

}

/**
 * Converts an object of type 'KafkaSpecJmxTrans' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTrans(obj: KafkaSpecJmxTrans | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'outputDefinitions': obj.outputDefinitions?.map(y => toJson_KafkaSpecJmxTransOutputDefinitions(y)),
    'logLevel': obj.logLevel,
    'kafkaQueries': obj.kafkaQueries?.map(y => toJson_KafkaSpecJmxTransKafkaQueries(y)),
    'resources': toJson_KafkaSpecJmxTransResources(obj.resources),
    'template': toJson_KafkaSpecJmxTransTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
 *
 * @schema KafkaSpecKafkaExporter
 */
export interface KafkaSpecKafkaExporter {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecKafkaExporter#image
   */
  readonly image?: string;

  /**
   * Regular expression to specify which consumer groups to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#groupRegex
   */
  readonly groupRegex?: string;

  /**
   * Regular expression to specify which topics to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#topicRegex
   */
  readonly topicRegex?: string;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafkaExporter#resources
   */
  readonly resources?: KafkaSpecKafkaExporterResources;

  /**
   * Only log messages with the given severity or above. Valid levels: [`info`, `debug`, `trace`]. Default log level is `info`.
   *
   * @schema KafkaSpecKafkaExporter#logging
   */
  readonly logging?: string;

  /**
   * Enable Sarama logging, a Go client library used by the Kafka Exporter.
   *
   * @schema KafkaSpecKafkaExporter#enableSaramaLogging
   */
  readonly enableSaramaLogging?: boolean;

  /**
   * Customization of deployment templates and pods.
   *
   * @schema KafkaSpecKafkaExporter#template
   */
  readonly template?: KafkaSpecKafkaExporterTemplate;

  /**
   * Pod liveness check.
   *
   * @schema KafkaSpecKafkaExporter#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaExporterLivenessProbe;

  /**
   * Pod readiness check.
   *
   * @schema KafkaSpecKafkaExporter#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaExporterReadinessProbe;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporter(obj: KafkaSpecKafkaExporter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'groupRegex': obj.groupRegex,
    'topicRegex': obj.topicRegex,
    'resources': toJson_KafkaSpecKafkaExporterResources(obj.resources),
    'logging': obj.logging,
    'enableSaramaLogging': obj.enableSaramaLogging,
    'template': toJson_KafkaSpecKafkaExporterTemplate(obj.template),
    'livenessProbe': toJson_KafkaSpecKafkaExporterLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecKafkaExporterReadinessProbe(obj.readinessProbe),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListeners
 */
export interface KafkaSpecKafkaListeners {
  /**
   * Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
   *
   * @schema KafkaSpecKafkaListeners#name
   */
  readonly name: string;

  /**
   * Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
   *
   * @schema KafkaSpecKafkaListeners#port
   */
  readonly port: number;

  /**
   * Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`.
   *
   * * `internal` type exposes Kafka internally only within the Kubernetes cluster.
   * * `route` type uses OpenShift Routes to expose Kafka.
   * * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
   * * `nodeport` type uses NodePort type services to expose Kafka.
   * * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka with TLS passthrought.
   * * `cluster-ip` type uses ClusterIP service with per broker port number. Can be exposed over Nginx Ingress Controller with tcp port config.
   *
   *
   * @schema KafkaSpecKafkaListeners#type
   */
  readonly type: KafkaSpecKafkaListenersType;

  /**
   * Enables TLS encryption on the listener. This is a required property.
   *
   * @schema KafkaSpecKafkaListeners#tls
   */
  readonly tls: boolean;

  /**
   * Authentication configuration for this listener.
   *
   * @schema KafkaSpecKafkaListeners#authentication
   */
  readonly authentication?: KafkaSpecKafkaListenersAuthentication;

  /**
   * Additional listener configuration.
   *
   * @schema KafkaSpecKafkaListeners#configuration
   */
  readonly configuration?: KafkaSpecKafkaListenersConfiguration;

  /**
   * List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
   *
   * @schema KafkaSpecKafkaListeners#networkPolicyPeers
   */
  readonly networkPolicyPeers?: KafkaSpecKafkaListenersNetworkPolicyPeers[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListeners' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListeners(obj: KafkaSpecKafkaListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': obj.port,
    'type': obj.type,
    'tls': obj.tls,
    'authentication': toJson_KafkaSpecKafkaListenersAuthentication(obj.authentication),
    'configuration': toJson_KafkaSpecKafkaListenersConfiguration(obj.configuration),
    'networkPolicyPeers': obj.networkPolicyPeers?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecKafkaStorage
 */
export interface KafkaSpecKafkaStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorage#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#type
   */
  readonly type: KafkaSpecKafkaStorageType;

  /**
   * List of volumes as Storage objects representing the JBOD disks array.
   *
   * @schema KafkaSpecKafkaStorage#volumes
   */
  readonly volumes?: KafkaSpecKafkaStorageVolumes[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorage(obj: KafkaSpecKafkaStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'deleteClaim': obj.deleteClaim,
    'id': obj.id,
    'overrides': obj.overrides?.map(y => toJson_KafkaSpecKafkaStorageOverrides(y)),
    'selector': obj.selector,
    'size': obj.size,
    'sizeLimit': obj.sizeLimit,
    'type': obj.type,
    'volumes': obj.volumes?.map(y => toJson_KafkaSpecKafkaStorageVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization configuration for Kafka brokers.
 *
 * @schema KafkaSpecKafkaAuthorization
 */
export interface KafkaSpecKafkaAuthorization {
  /**
   * Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
   *
   * @default false` - all actions will be denied.
   * @schema KafkaSpecKafkaAuthorization#allowOnError
   */
  readonly allowOnError?: boolean;

  /**
   * Authorization implementation class, which must be available in classpath.
   *
   * @schema KafkaSpecKafkaAuthorization#authorizerClass
   */
  readonly authorizerClass?: string;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#clientId
   */
  readonly clientId?: string;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaSpecKafkaAuthorization#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#delegateToKafkaAcls
   */
  readonly delegateToKafkaAcls?: boolean;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
   *
   * @default 3600000`.
   * @schema KafkaSpecKafkaAuthorization#expireAfterMs
   */
  readonly expireAfterMs?: number;

  /**
   * The time between two consecutive grants refresh runs in seconds. The default value is 60.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPeriodSeconds
   */
  readonly grantsRefreshPeriodSeconds?: number;

  /**
   * The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPoolSize
   */
  readonly grantsRefreshPoolSize?: number;

  /**
   * Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
   *
   * @default 5000`.
   * @schema KafkaSpecKafkaAuthorization#initialCacheCapacity
   */
  readonly initialCacheCapacity?: number;

  /**
   * Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
   *
   * @default 50000`.
   * @schema KafkaSpecKafkaAuthorization#maximumCacheSize
   */
  readonly maximumCacheSize?: number;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaSpecKafkaAuthorization#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * List of super users, which are user principals with unlimited access rights.
   *
   * @schema KafkaSpecKafkaAuthorization#superUsers
   */
  readonly superUsers?: string[];

  /**
   * Indicates whether the custom authorizer supports the APIs for managing ACLs using the Kafka Admin API. Defaults to `false`.
   *
   * @default false`.
   * @schema KafkaSpecKafkaAuthorization#supportsAdminApi
   */
  readonly supportsAdminApi?: boolean;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaSpecKafkaAuthorization#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaSpecKafkaAuthorizationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.
   *
   * @schema KafkaSpecKafkaAuthorization#type
   */
  readonly type: KafkaSpecKafkaAuthorizationType;

  /**
   * The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
   *
   * @schema KafkaSpecKafkaAuthorization#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaAuthorization(obj: KafkaSpecKafkaAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowOnError': obj.allowOnError,
    'authorizerClass': obj.authorizerClass,
    'clientId': obj.clientId,
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'delegateToKafkaAcls': obj.delegateToKafkaAcls,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'expireAfterMs': obj.expireAfterMs,
    'grantsRefreshPeriodSeconds': obj.grantsRefreshPeriodSeconds,
    'grantsRefreshPoolSize': obj.grantsRefreshPoolSize,
    'initialCacheCapacity': obj.initialCacheCapacity,
    'maximumCacheSize': obj.maximumCacheSize,
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'superUsers': obj.superUsers?.map(y => y),
    'supportsAdminApi': obj.supportsAdminApi,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaSpecKafkaAuthorizationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the `broker.rack` broker config.
 *
 * @schema KafkaSpecKafkaRack
 */
export interface KafkaSpecKafkaRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.0.
   *
   * @schema KafkaSpecKafkaRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaRack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaRack(obj: KafkaSpecKafkaRack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaLivenessProbe
 */
export interface KafkaSpecKafkaLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecKafkaLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLivenessProbe(obj: KafkaSpecKafkaLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaReadinessProbe
 */
export interface KafkaSpecKafkaReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecKafkaReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaReadinessProbe(obj: KafkaSpecKafkaReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecKafkaJvmOptions
 */
export interface KafkaSpecKafkaJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecKafkaJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecKafkaJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJvmOptions(obj: KafkaSpecKafkaJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecKafkaJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JMX Options for Kafka brokers.
 *
 * @schema KafkaSpecKafkaJmxOptions
 */
export interface KafkaSpecKafkaJmxOptions {
  /**
   * Authentication configuration for connecting to the JMX port.
   *
   * @schema KafkaSpecKafkaJmxOptions#authentication
   */
  readonly authentication?: KafkaSpecKafkaJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJmxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJmxOptions(obj: KafkaSpecKafkaJmxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaSpecKafkaJmxOptionsAuthentication(obj.authentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaResources
 */
export interface KafkaSpecKafkaResources {
  /**
   * @schema KafkaSpecKafkaResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaResources(obj: KafkaSpecKafkaResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecKafkaMetricsConfig
 */
export interface KafkaSpecKafkaMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaSpecKafkaMetricsConfig#type
   */
  readonly type: KafkaSpecKafkaMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaSpecKafkaMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaSpecKafkaMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfig(obj: KafkaSpecKafkaMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecKafkaMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka.
 *
 * @schema KafkaSpecKafkaLogging
 */
export interface KafkaSpecKafkaLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecKafkaLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecKafkaLogging#type
   */
  readonly type: KafkaSpecKafkaLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaSpecKafkaLogging#valueFrom
   */
  readonly valueFrom?: KafkaSpecKafkaLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLogging(obj: KafkaSpecKafkaLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecKafkaLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka cluster resources. The template allows users to specify how the `StatefulSet`, `Pods`, and `Services` are generated.
 *
 * @schema KafkaSpecKafkaTemplate
 */
export interface KafkaSpecKafkaTemplate {
  /**
   * Template for Kafka `StatefulSet`.
   *
   * @schema KafkaSpecKafkaTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecKafkaTemplateStatefulset;

  /**
   * Template for Kafka `Pods`.
   *
   * @schema KafkaSpecKafkaTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaTemplatePod;

  /**
   * Template for Kafka bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#bootstrapService
   */
  readonly bootstrapService?: KafkaSpecKafkaTemplateBootstrapService;

  /**
   * Template for Kafka broker `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#brokersService
   */
  readonly brokersService?: KafkaSpecKafkaTemplateBrokersService;

  /**
   * Template for Kafka external bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapService
   */
  readonly externalBootstrapService?: KafkaSpecKafkaTemplateExternalBootstrapService;

  /**
   * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodService
   */
  readonly perPodService?: KafkaSpecKafkaTemplatePerPodService;

  /**
   * Template for Kafka external bootstrap `Route`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapRoute
   */
  readonly externalBootstrapRoute?: KafkaSpecKafkaTemplateExternalBootstrapRoute;

  /**
   * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
   *
   * @schema KafkaSpecKafkaTemplate#perPodRoute
   */
  readonly perPodRoute?: KafkaSpecKafkaTemplatePerPodRoute;

  /**
   * Template for Kafka external bootstrap `Ingress`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapIngress
   */
  readonly externalBootstrapIngress?: KafkaSpecKafkaTemplateExternalBootstrapIngress;

  /**
   * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodIngress
   */
  readonly perPodIngress?: KafkaSpecKafkaTemplatePerPodIngress;

  /**
   * Template for all Kafka `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecKafkaTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecKafkaTemplatePersistentVolumeClaim;

  /**
   * Template for Kafka `PodDisruptionBudget`.
   *
   * @schema KafkaSpecKafkaTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecKafkaTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka broker container.
   *
   * @schema KafkaSpecKafkaTemplate#kafkaContainer
   */
  readonly kafkaContainer?: KafkaSpecKafkaTemplateKafkaContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaSpecKafkaTemplate#initContainer
   */
  readonly initContainer?: KafkaSpecKafkaTemplateInitContainer;

  /**
   * Template for Secret with Kafka Cluster certificate public key.
   *
   * @schema KafkaSpecKafkaTemplate#clusterCaCert
   */
  readonly clusterCaCert?: KafkaSpecKafkaTemplateClusterCaCert;

  /**
   * Template for the Kafka service account.
   *
   * @schema KafkaSpecKafkaTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecKafkaTemplateServiceAccount;

  /**
   * Template for Secret of the Kafka Cluster JMX authentication.
   *
   * @schema KafkaSpecKafkaTemplate#jmxSecret
   */
  readonly jmxSecret?: KafkaSpecKafkaTemplateJmxSecret;

  /**
   * Template for the Kafka ClusterRoleBinding.
   *
   * @schema KafkaSpecKafkaTemplate#clusterRoleBinding
   */
  readonly clusterRoleBinding?: KafkaSpecKafkaTemplateClusterRoleBinding;

  /**
   * Template for Kafka `StrimziPodSet` resource.
   *
   * @schema KafkaSpecKafkaTemplate#podSet
   */
  readonly podSet?: KafkaSpecKafkaTemplatePodSet;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplate(obj: KafkaSpecKafkaTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statefulset': toJson_KafkaSpecKafkaTemplateStatefulset(obj.statefulset),
    'pod': toJson_KafkaSpecKafkaTemplatePod(obj.pod),
    'bootstrapService': toJson_KafkaSpecKafkaTemplateBootstrapService(obj.bootstrapService),
    'brokersService': toJson_KafkaSpecKafkaTemplateBrokersService(obj.brokersService),
    'externalBootstrapService': toJson_KafkaSpecKafkaTemplateExternalBootstrapService(obj.externalBootstrapService),
    'perPodService': toJson_KafkaSpecKafkaTemplatePerPodService(obj.perPodService),
    'externalBootstrapRoute': toJson_KafkaSpecKafkaTemplateExternalBootstrapRoute(obj.externalBootstrapRoute),
    'perPodRoute': toJson_KafkaSpecKafkaTemplatePerPodRoute(obj.perPodRoute),
    'externalBootstrapIngress': toJson_KafkaSpecKafkaTemplateExternalBootstrapIngress(obj.externalBootstrapIngress),
    'perPodIngress': toJson_KafkaSpecKafkaTemplatePerPodIngress(obj.perPodIngress),
    'persistentVolumeClaim': toJson_KafkaSpecKafkaTemplatePersistentVolumeClaim(obj.persistentVolumeClaim),
    'podDisruptionBudget': toJson_KafkaSpecKafkaTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'kafkaContainer': toJson_KafkaSpecKafkaTemplateKafkaContainer(obj.kafkaContainer),
    'initContainer': toJson_KafkaSpecKafkaTemplateInitContainer(obj.initContainer),
    'clusterCaCert': toJson_KafkaSpecKafkaTemplateClusterCaCert(obj.clusterCaCert),
    'serviceAccount': toJson_KafkaSpecKafkaTemplateServiceAccount(obj.serviceAccount),
    'jmxSecret': toJson_KafkaSpecKafkaTemplateJmxSecret(obj.jmxSecret),
    'clusterRoleBinding': toJson_KafkaSpecKafkaTemplateClusterRoleBinding(obj.clusterRoleBinding),
    'podSet': toJson_KafkaSpecKafkaTemplatePodSet(obj.podSet),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecZookeeperStorage
 */
export interface KafkaSpecZookeeperStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecZookeeperStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecZookeeperStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecZookeeperStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecZookeeperStorage#overrides
   */
  readonly overrides?: KafkaSpecZookeeperStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecZookeeperStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecZookeeperStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecZookeeperStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecZookeeperStorage#type
   */
  readonly type: KafkaSpecZookeeperStorageType;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperStorage(obj: KafkaSpecZookeeperStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'deleteClaim': obj.deleteClaim,
    'id': obj.id,
    'overrides': obj.overrides?.map(y => toJson_KafkaSpecZookeeperStorageOverrides(y)),
    'selector': obj.selector,
    'size': obj.size,
    'sizeLimit': obj.sizeLimit,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperLivenessProbe
 */
export interface KafkaSpecZookeeperLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecZookeeperLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLivenessProbe(obj: KafkaSpecZookeeperLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperReadinessProbe
 */
export interface KafkaSpecZookeeperReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecZookeeperReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperReadinessProbe(obj: KafkaSpecZookeeperReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecZookeeperJvmOptions
 */
export interface KafkaSpecZookeeperJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecZookeeperJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecZookeeperJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJvmOptions(obj: KafkaSpecZookeeperJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecZookeeperJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JMX Options for Zookeeper nodes.
 *
 * @schema KafkaSpecZookeeperJmxOptions
 */
export interface KafkaSpecZookeeperJmxOptions {
  /**
   * Authentication configuration for connecting to the JMX port.
   *
   * @schema KafkaSpecZookeeperJmxOptions#authentication
   */
  readonly authentication?: KafkaSpecZookeeperJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJmxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJmxOptions(obj: KafkaSpecZookeeperJmxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaSpecZookeeperJmxOptionsAuthentication(obj.authentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperResources
 */
export interface KafkaSpecZookeeperResources {
  /**
   * @schema KafkaSpecZookeeperResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecZookeeperResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperResources(obj: KafkaSpecZookeeperResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecZookeeperMetricsConfig
 */
export interface KafkaSpecZookeeperMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaSpecZookeeperMetricsConfig#type
   */
  readonly type: KafkaSpecZookeeperMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaSpecZookeeperMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaSpecZookeeperMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfig(obj: KafkaSpecZookeeperMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecZookeeperMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for ZooKeeper.
 *
 * @schema KafkaSpecZookeeperLogging
 */
export interface KafkaSpecZookeeperLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecZookeeperLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecZookeeperLogging#type
   */
  readonly type: KafkaSpecZookeeperLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaSpecZookeeperLogging#valueFrom
   */
  readonly valueFrom?: KafkaSpecZookeeperLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLogging(obj: KafkaSpecZookeeperLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecZookeeperLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper cluster resources. The template allows users to specify how the `StatefulSet`, `Pods`, and `Services` are generated.
 *
 * @schema KafkaSpecZookeeperTemplate
 */
export interface KafkaSpecZookeeperTemplate {
  /**
   * Template for ZooKeeper `StatefulSet`.
   *
   * @schema KafkaSpecZookeeperTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecZookeeperTemplateStatefulset;

  /**
   * Template for ZooKeeper `Pods`.
   *
   * @schema KafkaSpecZookeeperTemplate#pod
   */
  readonly pod?: KafkaSpecZookeeperTemplatePod;

  /**
   * Template for ZooKeeper client `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#clientService
   */
  readonly clientService?: KafkaSpecZookeeperTemplateClientService;

  /**
   * Template for ZooKeeper nodes `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#nodesService
   */
  readonly nodesService?: KafkaSpecZookeeperTemplateNodesService;

  /**
   * Template for all ZooKeeper `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecZookeeperTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecZookeeperTemplatePersistentVolumeClaim;

  /**
   * Template for ZooKeeper `PodDisruptionBudget`.
   *
   * @schema KafkaSpecZookeeperTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecZookeeperTemplatePodDisruptionBudget;

  /**
   * Template for the ZooKeeper container.
   *
   * @schema KafkaSpecZookeeperTemplate#zookeeperContainer
   */
  readonly zookeeperContainer?: KafkaSpecZookeeperTemplateZookeeperContainer;

  /**
   * Template for the ZooKeeper service account.
   *
   * @schema KafkaSpecZookeeperTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecZookeeperTemplateServiceAccount;

  /**
   * Template for Secret of the Zookeeper Cluster JMX authentication.
   *
   * @schema KafkaSpecZookeeperTemplate#jmxSecret
   */
  readonly jmxSecret?: KafkaSpecZookeeperTemplateJmxSecret;

  /**
   * Template for ZooKeeper `StrimziPodSet` resource.
   *
   * @schema KafkaSpecZookeeperTemplate#podSet
   */
  readonly podSet?: KafkaSpecZookeeperTemplatePodSet;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplate(obj: KafkaSpecZookeeperTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statefulset': toJson_KafkaSpecZookeeperTemplateStatefulset(obj.statefulset),
    'pod': toJson_KafkaSpecZookeeperTemplatePod(obj.pod),
    'clientService': toJson_KafkaSpecZookeeperTemplateClientService(obj.clientService),
    'nodesService': toJson_KafkaSpecZookeeperTemplateNodesService(obj.nodesService),
    'persistentVolumeClaim': toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaim(obj.persistentVolumeClaim),
    'podDisruptionBudget': toJson_KafkaSpecZookeeperTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'zookeeperContainer': toJson_KafkaSpecZookeeperTemplateZookeeperContainer(obj.zookeeperContainer),
    'serviceAccount': toJson_KafkaSpecZookeeperTemplateServiceAccount(obj.serviceAccount),
    'jmxSecret': toJson_KafkaSpecZookeeperTemplateJmxSecret(obj.jmxSecret),
    'podSet': toJson_KafkaSpecZookeeperTemplatePodSet(obj.podSet),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecEntityOperatorTopicOperator
 */
export interface KafkaSpecEntityOperatorTopicOperator {
  /**
   * The namespace the Topic Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the Topic Operator.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod startup checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#startupProbe
   */
  readonly startupProbe?: KafkaSpecEntityOperatorTopicOperatorStartupProbe;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTopicOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTopicOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTopicOperatorResources;

  /**
   * The number of attempts at getting topic metadata.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#topicMetadataMaxAttempts
   */
  readonly topicMetadataMaxAttempts?: number;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorTopicOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorTopicOperatorJvmOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperator(obj: KafkaSpecEntityOperatorTopicOperator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'watchedNamespace': obj.watchedNamespace,
    'image': obj.image,
    'reconciliationIntervalSeconds': obj.reconciliationIntervalSeconds,
    'zookeeperSessionTimeoutSeconds': obj.zookeeperSessionTimeoutSeconds,
    'startupProbe': toJson_KafkaSpecEntityOperatorTopicOperatorStartupProbe(obj.startupProbe),
    'livenessProbe': toJson_KafkaSpecEntityOperatorTopicOperatorLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecEntityOperatorTopicOperatorReadinessProbe(obj.readinessProbe),
    'resources': toJson_KafkaSpecEntityOperatorTopicOperatorResources(obj.resources),
    'topicMetadataMaxAttempts': obj.topicMetadataMaxAttempts,
    'logging': toJson_KafkaSpecEntityOperatorTopicOperatorLogging(obj.logging),
    'jvmOptions': toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptions(obj.jvmOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the User Operator.
 *
 * @schema KafkaSpecEntityOperatorUserOperator
 */
export interface KafkaSpecEntityOperatorUserOperator {
  /**
   * The namespace the User Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the User Operator.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * The prefix that will be added to the KafkaUser name to be used as the Secret name.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#secretPrefix
   */
  readonly secretPrefix?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorUserOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorUserOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorUserOperatorResources;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorUserOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorUserOperatorJvmOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperator(obj: KafkaSpecEntityOperatorUserOperator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'watchedNamespace': obj.watchedNamespace,
    'image': obj.image,
    'reconciliationIntervalSeconds': obj.reconciliationIntervalSeconds,
    'zookeeperSessionTimeoutSeconds': obj.zookeeperSessionTimeoutSeconds,
    'secretPrefix': obj.secretPrefix,
    'livenessProbe': toJson_KafkaSpecEntityOperatorUserOperatorLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaSpecEntityOperatorUserOperatorReadinessProbe(obj.readinessProbe),
    'resources': toJson_KafkaSpecEntityOperatorUserOperatorResources(obj.resources),
    'logging': toJson_KafkaSpecEntityOperatorUserOperatorLogging(obj.logging),
    'jvmOptions': toJson_KafkaSpecEntityOperatorUserOperatorJvmOptions(obj.jvmOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecar
 */
export interface KafkaSpecEntityOperatorTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecEntityOperatorTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTlsSidecarResources;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecar' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecar(obj: KafkaSpecEntityOperatorTlsSidecar | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'livenessProbe': toJson_KafkaSpecEntityOperatorTlsSidecarLivenessProbe(obj.livenessProbe),
    'logLevel': obj.logLevel,
    'readinessProbe': toJson_KafkaSpecEntityOperatorTlsSidecarReadinessProbe(obj.readinessProbe),
    'resources': toJson_KafkaSpecEntityOperatorTlsSidecarResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
 *
 * @schema KafkaSpecEntityOperatorTemplate
 */
export interface KafkaSpecEntityOperatorTemplate {
  /**
   * Template for Entity Operator `Deployment`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#deployment
   */
  readonly deployment?: KafkaSpecEntityOperatorTemplateDeployment;

  /**
   * Template for Entity Operator `Pods`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#pod
   */
  readonly pod?: KafkaSpecEntityOperatorTemplatePod;

  /**
   * Template for the Entity Topic Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#topicOperatorContainer
   */
  readonly topicOperatorContainer?: KafkaSpecEntityOperatorTemplateTopicOperatorContainer;

  /**
   * Template for the Entity User Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#userOperatorContainer
   */
  readonly userOperatorContainer?: KafkaSpecEntityOperatorTemplateUserOperatorContainer;

  /**
   * Template for the Entity Operator TLS sidecar container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecEntityOperatorTemplateTlsSidecarContainer;

  /**
   * Template for the Entity Operator service account.
   *
   * @schema KafkaSpecEntityOperatorTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecEntityOperatorTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplate(obj: KafkaSpecEntityOperatorTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaSpecEntityOperatorTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaSpecEntityOperatorTemplatePod(obj.pod),
    'topicOperatorContainer': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainer(obj.topicOperatorContainer),
    'userOperatorContainer': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainer(obj.userOperatorContainer),
    'tlsSidecarContainer': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainer(obj.tlsSidecarContainer),
    'serviceAccount': toJson_KafkaSpecEntityOperatorTemplateServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClusterCaCertificateExpirationPolicy
 */
export enum KafkaSpecClusterCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_HYPHEN_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_HYPHEN_KEY = "replace-key",
}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClientsCaCertificateExpirationPolicy
 */
export enum KafkaSpecClientsCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_HYPHEN_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_HYPHEN_KEY = "replace-key",
}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecCruiseControlTlsSidecar
 */
export interface KafkaSpecCruiseControlTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecCruiseControlTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#resources
   */
  readonly resources?: KafkaSpecCruiseControlTlsSidecarResources;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecar' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecar(obj: KafkaSpecCruiseControlTlsSidecar | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'livenessProbe': toJson_KafkaSpecCruiseControlTlsSidecarLivenessProbe(obj.livenessProbe),
    'logLevel': obj.logLevel,
    'readinessProbe': toJson_KafkaSpecCruiseControlTlsSidecarReadinessProbe(obj.readinessProbe),
    'resources': toJson_KafkaSpecCruiseControlTlsSidecarResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlResources
 */
export interface KafkaSpecCruiseControlResources {
  /**
   * @schema KafkaSpecCruiseControlResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlResources(obj: KafkaSpecCruiseControlResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlLivenessProbe
 */
export interface KafkaSpecCruiseControlLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecCruiseControlLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLivenessProbe(obj: KafkaSpecCruiseControlLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlReadinessProbe
 */
export interface KafkaSpecCruiseControlReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecCruiseControlReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlReadinessProbe(obj: KafkaSpecCruiseControlReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlJvmOptions
 */
export interface KafkaSpecCruiseControlJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlJvmOptions(obj: KafkaSpecCruiseControlJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecCruiseControlJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration (Log4j 2) for Cruise Control.
 *
 * @schema KafkaSpecCruiseControlLogging
 */
export interface KafkaSpecCruiseControlLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecCruiseControlLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecCruiseControlLogging#type
   */
  readonly type: KafkaSpecCruiseControlLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaSpecCruiseControlLogging#valueFrom
   */
  readonly valueFrom?: KafkaSpecCruiseControlLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLogging(obj: KafkaSpecCruiseControlLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecCruiseControlLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaSpecCruiseControlTemplate
 */
export interface KafkaSpecCruiseControlTemplate {
  /**
   * Template for Cruise Control `Deployment`.
   *
   * @schema KafkaSpecCruiseControlTemplate#deployment
   */
  readonly deployment?: KafkaSpecCruiseControlTemplateDeployment;

  /**
   * Template for Cruise Control `Pods`.
   *
   * @schema KafkaSpecCruiseControlTemplate#pod
   */
  readonly pod?: KafkaSpecCruiseControlTemplatePod;

  /**
   * Template for Cruise Control API `Service`.
   *
   * @schema KafkaSpecCruiseControlTemplate#apiService
   */
  readonly apiService?: KafkaSpecCruiseControlTemplateApiService;

  /**
   * Template for Cruise Control `PodDisruptionBudget`.
   *
   * @schema KafkaSpecCruiseControlTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecCruiseControlTemplatePodDisruptionBudget;

  /**
   * Template for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControlTemplate#cruiseControlContainer
   */
  readonly cruiseControlContainer?: KafkaSpecCruiseControlTemplateCruiseControlContainer;

  /**
   * Template for the Cruise Control TLS sidecar container.
   *
   * @schema KafkaSpecCruiseControlTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecCruiseControlTemplateTlsSidecarContainer;

  /**
   * Template for the Cruise Control service account.
   *
   * @schema KafkaSpecCruiseControlTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecCruiseControlTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplate(obj: KafkaSpecCruiseControlTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaSpecCruiseControlTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaSpecCruiseControlTemplatePod(obj.pod),
    'apiService': toJson_KafkaSpecCruiseControlTemplateApiService(obj.apiService),
    'podDisruptionBudget': toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'cruiseControlContainer': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainer(obj.cruiseControlContainer),
    'tlsSidecarContainer': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainer(obj.tlsSidecarContainer),
    'serviceAccount': toJson_KafkaSpecCruiseControlTemplateServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Cruise Control `brokerCapacity` configuration.
 *
 * @schema KafkaSpecCruiseControlBrokerCapacity
 */
export interface KafkaSpecCruiseControlBrokerCapacity {
  /**
   * Broker capacity for disk in bytes. Use a number value with either standard Kubernetes byte units (K, M, G, or T), their bibyte (power of two) equivalents (Ki, Mi, Gi, or Ti), or a byte value with or without E notation. For example, 100000M, 100000Mi, 104857600000, or 1e+11.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#disk
   */
  readonly disk?: string;

  /**
   * Broker capacity for CPU resource utilization as a percentage (0 - 100).
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#cpuUtilization
   */
  readonly cpuUtilization?: number;

  /**
   * Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#cpu
   */
  readonly cpu?: string;

  /**
   * Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#inboundNetwork
   */
  readonly inboundNetwork?: string;

  /**
   * Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#outboundNetwork
   */
  readonly outboundNetwork?: string;

  /**
   * Overrides for individual brokers. The `overrides` property lets you specify a different capacity configuration for different brokers.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#overrides
   */
  readonly overrides?: KafkaSpecCruiseControlBrokerCapacityOverrides[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlBrokerCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlBrokerCapacity(obj: KafkaSpecCruiseControlBrokerCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disk': obj.disk,
    'cpuUtilization': obj.cpuUtilization,
    'cpu': obj.cpu,
    'inboundNetwork': obj.inboundNetwork,
    'outboundNetwork': obj.outboundNetwork,
    'overrides': obj.overrides?.map(y => toJson_KafkaSpecCruiseControlBrokerCapacityOverrides(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecCruiseControlMetricsConfig
 */
export interface KafkaSpecCruiseControlMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaSpecCruiseControlMetricsConfig#type
   */
  readonly type: KafkaSpecCruiseControlMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaSpecCruiseControlMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaSpecCruiseControlMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfig(obj: KafkaSpecCruiseControlMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecCruiseControlMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransOutputDefinitions
 */
export interface KafkaSpecJmxTransOutputDefinitions {
  /**
   * Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#outputType
   */
  readonly outputType: string;

  /**
   * The DNS/hostname of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#host
   */
  readonly host?: string;

  /**
   * The port of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#port
   */
  readonly port?: number;

  /**
   * How many seconds the JmxTrans waits before pushing a new set of data out.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#flushDelayInSeconds
   */
  readonly flushDelayInSeconds?: number;

  /**
   * Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#typeNames
   */
  readonly typeNames?: string[];

  /**
   * Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransOutputDefinitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransOutputDefinitions(obj: KafkaSpecJmxTransOutputDefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputType': obj.outputType,
    'host': obj.host,
    'port': obj.port,
    'flushDelayInSeconds': obj.flushDelayInSeconds,
    'typeNames': obj.typeNames?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransKafkaQueries
 */
export interface KafkaSpecJmxTransKafkaQueries {
  /**
   * If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#targetMBean
   */
  readonly targetMBean: string;

  /**
   * Determine which attributes of the targeted MBean should be included.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#attributes
   */
  readonly attributes: string[];

  /**
   * List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#outputs
   */
  readonly outputs: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransKafkaQueries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransKafkaQueries(obj: KafkaSpecJmxTransKafkaQueries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetMBean': obj.targetMBean,
    'attributes': obj.attributes?.map(y => y),
    'outputs': obj.outputs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecJmxTransResources
 */
export interface KafkaSpecJmxTransResources {
  /**
   * @schema KafkaSpecJmxTransResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecJmxTransResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransResources(obj: KafkaSpecJmxTransResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans resources.
 *
 * @schema KafkaSpecJmxTransTemplate
 */
export interface KafkaSpecJmxTransTemplate {
  /**
   * Template for JmxTrans `Deployment`.
   *
   * @schema KafkaSpecJmxTransTemplate#deployment
   */
  readonly deployment?: KafkaSpecJmxTransTemplateDeployment;

  /**
   * Template for JmxTrans `Pods`.
   *
   * @schema KafkaSpecJmxTransTemplate#pod
   */
  readonly pod?: KafkaSpecJmxTransTemplatePod;

  /**
   * Template for JmxTrans container.
   *
   * @schema KafkaSpecJmxTransTemplate#container
   */
  readonly container?: KafkaSpecJmxTransTemplateContainer;

  /**
   * Template for the JMX Trans service account.
   *
   * @schema KafkaSpecJmxTransTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecJmxTransTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplate(obj: KafkaSpecJmxTransTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaSpecJmxTransTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaSpecJmxTransTemplatePod(obj.pod),
    'container': toJson_KafkaSpecJmxTransTemplateContainer(obj.container),
    'serviceAccount': toJson_KafkaSpecJmxTransTemplateServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaExporterResources
 */
export interface KafkaSpecKafkaExporterResources {
  /**
   * @schema KafkaSpecKafkaExporterResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaExporterResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterResources(obj: KafkaSpecKafkaExporterResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Customization of deployment templates and pods.
 *
 * @schema KafkaSpecKafkaExporterTemplate
 */
export interface KafkaSpecKafkaExporterTemplate {
  /**
   * Template for Kafka Exporter `Deployment`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#deployment
   */
  readonly deployment?: KafkaSpecKafkaExporterTemplateDeployment;

  /**
   * Template for Kafka Exporter `Pods`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaExporterTemplatePod;

  /**
   * Template for Kafka Exporter `Service`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#service
   */
  readonly service?: KafkaSpecKafkaExporterTemplateService;

  /**
   * Template for the Kafka Exporter container.
   *
   * @schema KafkaSpecKafkaExporterTemplate#container
   */
  readonly container?: KafkaSpecKafkaExporterTemplateContainer;

  /**
   * Template for the Kafka Exporter service account.
   *
   * @schema KafkaSpecKafkaExporterTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaSpecKafkaExporterTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplate(obj: KafkaSpecKafkaExporterTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaSpecKafkaExporterTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaSpecKafkaExporterTemplatePod(obj.pod),
    'service': toJson_KafkaSpecKafkaExporterTemplateService(obj.service),
    'container': toJson_KafkaSpecKafkaExporterTemplateContainer(obj.container),
    'serviceAccount': toJson_KafkaSpecKafkaExporterTemplateServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness check.
 *
 * @schema KafkaSpecKafkaExporterLivenessProbe
 */
export interface KafkaSpecKafkaExporterLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecKafkaExporterLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterLivenessProbe(obj: KafkaSpecKafkaExporterLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness check.
 *
 * @schema KafkaSpecKafkaExporterReadinessProbe
 */
export interface KafkaSpecKafkaExporterReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecKafkaExporterReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterReadinessProbe(obj: KafkaSpecKafkaExporterReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`.
 *
 * * `internal` type exposes Kafka internally only within the Kubernetes cluster.
 * * `route` type uses OpenShift Routes to expose Kafka.
 * * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
 * * `nodeport` type uses NodePort type services to expose Kafka.
 * * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka with TLS passthrought.
 * * `cluster-ip` type uses ClusterIP service with per broker port number. Can be exposed over Nginx Ingress Controller with tcp port config.
 *
 *
 * @schema KafkaSpecKafkaListenersType
 */
export enum KafkaSpecKafkaListenersType {
  /** internal */
  INTERNAL = "internal",
  /** route */
  ROUTE = "route",
  /** loadbalancer */
  LOADBALANCER = "loadbalancer",
  /** nodeport */
  NODEPORT = "nodeport",
  /** ingress */
  INGRESS = "ingress",
  /** cluster-ip */
  CLUSTER_HYPHEN_IP = "cluster-ip",
}

/**
 * Authentication configuration for this listener.
 *
 * @schema KafkaSpecKafkaListenersAuthentication
 */
export interface KafkaSpecKafkaListenersAuthentication {
  /**
   * Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaSpecKafkaListenersAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaSpecKafkaListenersAuthentication#checkAccessTokenType
   */
  readonly checkAccessTokenType?: boolean;

  /**
   * Enable or disable audience checking. Audience checks identify the recipients of tokens. If audience checking is enabled, the OAuth Client ID also has to be configured using the `clientId` property. The Kafka broker will reject tokens that do not have its `clientId` in their `aud` (audience) claim.Default value is `false`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#checkAudience
   */
  readonly checkAudience?: boolean;

  /**
   * Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#checkIssuer
   */
  readonly checkIssuer?: boolean;

  /**
   * The audience to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#clientAudience
   */
  readonly clientAudience?: string;

  /**
   * OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * The scope to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#clientScope
   */
  readonly clientScope?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaSpecKafkaListenersAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * JsonPath filter query to be applied to the JWT token or to the response of the introspection endpoint for additional token validation. Not set by default.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#customClaimCheck
   */
  readonly customClaimCheck?: string;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable ECDSA support by installing BouncyCastle crypto provider. ECDSA support is always enabled. The BouncyCastle libraries are no longer packaged with Strimzi. Value is ignored.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#enableECDSA
   */
  readonly enableEcdsa?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Enable or disable OAuth authentication over SASL_OAUTHBEARER. Default value is `true`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#enableOauthBearer
   */
  readonly enableOauthBearer?: boolean;

  /**
   * Enable or disable OAuth authentication over SASL_PLAIN. There is no re-authentication support when this mechanism is used. Default value is `false`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#enablePlain
   */
  readonly enablePlain?: boolean;

  /**
   * Enable or disable termination of Kafka broker processes due to potentially recoverable runtime errors during startup. Default value is `true`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#failFast
   */
  readonly failFast?: boolean;

  /**
   * The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#fallbackUserNameClaim
   */
  readonly fallbackUserNameClaim?: string;

  /**
   * The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#fallbackUserNamePrefix
   */
  readonly fallbackUserNamePrefix?: string;

  /**
   * JsonPath query used to extract groups for the user during authentication. Extracted groups can be used by a custom authorizer. By default no groups are extracted.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#groupsClaim
   */
  readonly groupsClaim?: string;

  /**
   * A delimiter used to parse groups when they are extracted as a single String value rather than a JSON array. Default value is ',' (comma).
   *
   * @schema KafkaSpecKafkaListenersAuthentication#groupsClaimDelimiter
   */
  readonly groupsClaimDelimiter?: string;

  /**
   * URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#introspectionEndpointUri
   */
  readonly introspectionEndpointUri?: string;

  /**
   * URI of the JWKS certificate endpoint, which can be used for local JWT validation.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#jwksEndpointUri
   */
  readonly jwksEndpointUri?: string;

  /**
   * Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
   *
   * @default 360 seconds.
   * @schema KafkaSpecKafkaListenersAuthentication#jwksExpirySeconds
   */
  readonly jwksExpirySeconds?: number;

  /**
   * Flag to ignore the 'use' attribute of `key` declarations in a JWKS endpoint response. Default value is `false`.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#jwksIgnoreKeyUse
   */
  readonly jwksIgnoreKeyUse?: boolean;

  /**
   * The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
   *
   * @default 1 second.
   * @schema KafkaSpecKafkaListenersAuthentication#jwksMinRefreshPauseSeconds
   */
  readonly jwksMinRefreshPauseSeconds?: number;

  /**
   * Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
   *
   * @default 300 seconds.
   * @schema KafkaSpecKafkaListenersAuthentication#jwksRefreshSeconds
   */
  readonly jwksRefreshSeconds?: number;

  /**
   * Configuration to be used for a specific listener. All values are prefixed with listener.name._<listener_name>_.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#listenerConfig
   */
  readonly listenerConfig?: any;

  /**
   * Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires. This option only applies to SASL_OAUTHBEARER authentication mechanism (when `enableOauthBearer` is `true`).
   *
   * @schema KafkaSpecKafkaListenersAuthentication#maxSecondsWithoutReauthentication
   */
  readonly maxSecondsWithoutReauthentication?: number;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Enable or disable SASL on this listener.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#sasl
   */
  readonly sasl?: boolean;

  /**
   * Secrets to be mounted to /opt/kafka/custom-authn-secrets/custom-listener-_<listener_name>-<port>_/_<secret_name>_.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#secrets
   */
  readonly secrets?: KafkaSpecKafkaListenersAuthenticationSecrets[];

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates[];

  /**
   * URI of the Token Endpoint to use with SASL_PLAIN mechanism when the client authenticates with `clientId` and a `secret`. If set, the client can authenticate over SASL_PLAIN by either setting `username` to `clientId`, and setting `password` to client `secret`, or by setting `username` to account username, and `password` to access token prefixed with `$accessToken:`. If this option is not set, the `password` is always interpreted as an access token (without a prefix), and `username` as the account username (a so called 'no-client-credentials' mode).
   *
   * @schema KafkaSpecKafkaListenersAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.`custom` type allows for any authentication type to be used.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#type
   */
  readonly type: KafkaSpecKafkaListenersAuthenticationType;

  /**
   * URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#userInfoEndpointUri
   */
  readonly userInfoEndpointUri?: string;

  /**
   * Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
   *
   * @default sub`.
   * @schema KafkaSpecKafkaListenersAuthentication#userNameClaim
   */
  readonly userNameClaim?: string;

  /**
   * URI of the token issuer used for authentication.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#validIssuerUri
   */
  readonly validIssuerUri?: string;

  /**
   * Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
   *
   * @schema KafkaSpecKafkaListenersAuthentication#validTokenType
   */
  readonly validTokenType?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthentication(obj: KafkaSpecKafkaListenersAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'checkAccessTokenType': obj.checkAccessTokenType,
    'checkAudience': obj.checkAudience,
    'checkIssuer': obj.checkIssuer,
    'clientAudience': obj.clientAudience,
    'clientId': obj.clientId,
    'clientScope': obj.clientScope,
    'clientSecret': toJson_KafkaSpecKafkaListenersAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'customClaimCheck': obj.customClaimCheck,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableECDSA': obj.enableEcdsa,
    'enableMetrics': obj.enableMetrics,
    'enableOauthBearer': obj.enableOauthBearer,
    'enablePlain': obj.enablePlain,
    'failFast': obj.failFast,
    'fallbackUserNameClaim': obj.fallbackUserNameClaim,
    'fallbackUserNamePrefix': obj.fallbackUserNamePrefix,
    'groupsClaim': obj.groupsClaim,
    'groupsClaimDelimiter': obj.groupsClaimDelimiter,
    'introspectionEndpointUri': obj.introspectionEndpointUri,
    'jwksEndpointUri': obj.jwksEndpointUri,
    'jwksExpirySeconds': obj.jwksExpirySeconds,
    'jwksIgnoreKeyUse': obj.jwksIgnoreKeyUse,
    'jwksMinRefreshPauseSeconds': obj.jwksMinRefreshPauseSeconds,
    'jwksRefreshSeconds': obj.jwksRefreshSeconds,
    'listenerConfig': obj.listenerConfig,
    'maxSecondsWithoutReauthentication': obj.maxSecondsWithoutReauthentication,
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'sasl': obj.sasl,
    'secrets': obj.secrets?.map(y => toJson_KafkaSpecKafkaListenersAuthenticationSecrets(y)),
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'userInfoEndpointUri': obj.userInfoEndpointUri,
    'userNameClaim': obj.userNameClaim,
    'validIssuerUri': obj.validIssuerUri,
    'validTokenType': obj.validTokenType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional listener configuration.
 *
 * @schema KafkaSpecKafkaListenersConfiguration
 */
export interface KafkaSpecKafkaListenersConfiguration {
  /**
   * Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#brokerCertChainAndKey
   */
  readonly brokerCertChainAndKey?: KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey;

  /**
   * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy;

  /**
   * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. This field can be used only with `loadbalancer` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * Bootstrap configuration.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#bootstrap
   */
  readonly bootstrap?: KafkaSpecKafkaListenersConfigurationBootstrap;

  /**
   * Per-broker configurations.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#brokers
   */
  readonly brokers?: KafkaSpecKafkaListenersConfigurationBrokers[];

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecKafkaListenersConfigurationIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecKafkaListenersConfigurationIpFamilies[];

  /**
   * Whether to create the bootstrap service or not. The bootstrap service is created by default (if not specified differently). This field can be used with the `loadBalancer` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#createBootstrapService
   */
  readonly createBootstrapService?: boolean;

  /**
   * Configures the `Ingress` class that defines which `Ingress` controller will be used. This field can be used only with `ingress` type listener. If not specified, the default Ingress controller will be used.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#class
   */
  readonly class?: string;

  /**
   * A list of finalizers which will be configured for the `LoadBalancer` type Services created for this listener. If supported by the platform, the finalizer `service.kubernetes.io/load-balancer-cleanup` to make sure that the external load balancer is deleted together with the service.For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers. This field can be used only with `loadbalancer` type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#finalizers
   */
  readonly finalizers?: string[];

  /**
   * The maximum connection creation rate we allow in this listener at any time. New connections will be throttled if the limit is reached.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#maxConnectionCreationRate
   */
  readonly maxConnectionCreationRate?: number;

  /**
   * The maximum number of connections we allow for this listener in the broker at any time. New connections are blocked if the limit is reached.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
   *
   * * `ExternalDNS`
   * * `ExternalIP`
   * * `InternalDNS`
   * * `InternalIP`
   * * `Hostname`
   *
   * This field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfiguration#preferredNodePortAddressType
   */
  readonly preferredNodePortAddressType?: KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType;

  /**
   * Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses will contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` type listener.
   *
   * @default false`.This field can be used only with `internal` type listener.
   * @schema KafkaSpecKafkaListenersConfiguration#useServiceDnsDomain
   */
  readonly useServiceDnsDomain?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfiguration(obj: KafkaSpecKafkaListenersConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokerCertChainAndKey': toJson_KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey(obj.brokerCertChainAndKey),
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'bootstrap': toJson_KafkaSpecKafkaListenersConfigurationBootstrap(obj.bootstrap),
    'brokers': obj.brokers?.map(y => toJson_KafkaSpecKafkaListenersConfigurationBrokers(y)),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
    'createBootstrapService': obj.createBootstrapService,
    'class': obj.class,
    'finalizers': obj.finalizers?.map(y => y),
    'maxConnectionCreationRate': obj.maxConnectionCreationRate,
    'maxConnections': obj.maxConnections,
    'preferredNodePortAddressType': obj.preferredNodePortAddressType,
    'useServiceDnsDomain': obj.useServiceDnsDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeers
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeers {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#ipBlock
   */
  readonly ipBlock?: KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#podSelector
   */
  readonly podSelector?: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeers(obj: KafkaSpecKafkaListenersNetworkPolicyPeers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipBlock': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock(obj.ipBlock),
    'namespaceSelector': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector(obj.namespaceSelector),
    'podSelector': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector(obj.podSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaStorageOverrides
 */
export interface KafkaSpecKafkaStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageOverrides(obj: KafkaSpecKafkaStorageOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'broker': obj.broker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
 *
 * @schema KafkaSpecKafkaStorageType
 */
export enum KafkaSpecKafkaStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_HYPHEN_CLAIM = "persistent-claim",
  /** jbod */
  JBOD = "jbod",
}

/**
 * @schema KafkaSpecKafkaStorageVolumes
 */
export interface KafkaSpecKafkaStorageVolumes {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorageVolumes#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorageVolumes#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorageVolumes#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageVolumesOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorageVolumes#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorageVolumes#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorageVolumes#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#type
   */
  readonly type: KafkaSpecKafkaStorageVolumesType;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageVolumes(obj: KafkaSpecKafkaStorageVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'deleteClaim': obj.deleteClaim,
    'id': obj.id,
    'overrides': obj.overrides?.map(y => toJson_KafkaSpecKafkaStorageVolumesOverrides(y)),
    'selector': obj.selector,
    'size': obj.size,
    'sizeLimit': obj.sizeLimit,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaAuthorizationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaAuthorizationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaAuthorizationTlsTrustedCertificates(obj: KafkaSpecKafkaAuthorizationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.
 *
 * @schema KafkaSpecKafkaAuthorizationType
 */
export enum KafkaSpecKafkaAuthorizationType {
  /** simple */
  SIMPLE = "simple",
  /** opa */
  OPA = "opa",
  /** keycloak */
  KEYCLOAK = "keycloak",
  /** custom */
  CUSTOM = "custom",
}

/**
 * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecKafkaJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJvmOptionsJavaSystemProperties(obj: KafkaSpecKafkaJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthentication
 */
export interface KafkaSpecKafkaJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaSpecKafkaJmxOptionsAuthentication#type
   */
  readonly type: KafkaSpecKafkaJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJmxOptionsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJmxOptionsAuthentication(obj: KafkaSpecKafkaJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecKafkaMetricsConfigType
 */
export enum KafkaSpecKafkaMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecKafkaMetricsConfigValueFrom
 */
export interface KafkaSpecKafkaMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecKafkaMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfigValueFrom(obj: KafkaSpecKafkaMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecKafkaLoggingType
 */
export enum KafkaSpecKafkaLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecKafkaLoggingValueFrom
 */
export interface KafkaSpecKafkaLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecKafkaLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecKafkaLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLoggingValueFrom(obj: KafkaSpecKafkaLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecKafkaLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `StatefulSet`.
 *
 * @schema KafkaSpecKafkaTemplateStatefulset
 */
export interface KafkaSpecKafkaTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecKafkaTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateStatefulset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateStatefulset(obj: KafkaSpecKafkaTemplateStatefulset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateStatefulsetMetadata(obj.metadata),
    'podManagementPolicy': obj.podManagementPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `Pods`.
 *
 * @schema KafkaSpecKafkaTemplatePod
 */
export interface KafkaSpecKafkaTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecKafkaTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecKafkaTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecKafkaTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecKafkaTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePod(obj: KafkaSpecKafkaTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecKafkaTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecKafkaTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecKafkaTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecKafkaTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecKafkaTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapService
 */
export interface KafkaSpecKafkaTemplateBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBootstrapServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapService#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecKafkaTemplateBootstrapServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBootstrapService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBootstrapService(obj: KafkaSpecKafkaTemplateBootstrapService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateBootstrapServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka broker `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBrokersService
 */
export interface KafkaSpecKafkaTemplateBrokersService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBrokersService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBrokersServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaTemplateBrokersService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecKafkaTemplateBrokersService#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecKafkaTemplateBrokersServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBrokersService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBrokersService(obj: KafkaSpecKafkaTemplateBrokersService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateBrokersServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapService
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapService(obj: KafkaSpecKafkaTemplateExternalBootstrapService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodService
 */
export interface KafkaSpecKafkaTemplatePerPodService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodService(obj: KafkaSpecKafkaTemplatePerPodService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePerPodServiceMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Route`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapRoute(obj: KafkaSpecKafkaTemplateExternalBootstrapRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRoute
 */
export interface KafkaSpecKafkaTemplatePerPodRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodRouteMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodRoute(obj: KafkaSpecKafkaTemplatePerPodRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePerPodRouteMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Ingress`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapIngress(obj: KafkaSpecKafkaTemplateExternalBootstrapIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngress
 */
export interface KafkaSpecKafkaTemplatePerPodIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodIngressMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodIngress(obj: KafkaSpecKafkaTemplatePerPodIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePerPodIngressMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for all Kafka `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePersistentVolumeClaim(obj: KafkaSpecKafkaTemplatePersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `PodDisruptionBudget`.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudget
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodDisruptionBudget(obj: KafkaSpecKafkaTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka broker container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainer
 */
export interface KafkaSpecKafkaTemplateKafkaContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateKafkaContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateKafkaContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainer(obj: KafkaSpecKafkaTemplateKafkaContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecKafkaTemplateKafkaContainerEnv(y)),
    'securityContext': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainer
 */
export interface KafkaSpecKafkaTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainer(obj: KafkaSpecKafkaTemplateInitContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecKafkaTemplateInitContainerEnv(y)),
    'securityContext': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret with Kafka Cluster certificate public key.
 *
 * @schema KafkaSpecKafkaTemplateClusterCaCert
 */
export interface KafkaSpecKafkaTemplateClusterCaCert {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateClusterCaCert#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateClusterCaCertMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterCaCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterCaCert(obj: KafkaSpecKafkaTemplateClusterCaCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateClusterCaCertMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka service account.
 *
 * @schema KafkaSpecKafkaTemplateServiceAccount
 */
export interface KafkaSpecKafkaTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateServiceAccount(obj: KafkaSpecKafkaTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Kafka Cluster JMX authentication.
 *
 * @schema KafkaSpecKafkaTemplateJmxSecret
 */
export interface KafkaSpecKafkaTemplateJmxSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateJmxSecret#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateJmxSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateJmxSecret(obj: KafkaSpecKafkaTemplateJmxSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateJmxSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka ClusterRoleBinding.
 *
 * @schema KafkaSpecKafkaTemplateClusterRoleBinding
 */
export interface KafkaSpecKafkaTemplateClusterRoleBinding {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateClusterRoleBinding#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateClusterRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterRoleBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterRoleBinding(obj: KafkaSpecKafkaTemplateClusterRoleBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplateClusterRoleBindingMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `StrimziPodSet` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodSet
 */
export interface KafkaSpecKafkaTemplatePodSet {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePodSet#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodSetMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSet(obj: KafkaSpecKafkaTemplatePodSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaTemplatePodSetMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperStorageOverrides
 */
export interface KafkaSpecZookeeperStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecZookeeperStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecZookeeperStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperStorageOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperStorageOverrides(obj: KafkaSpecZookeeperStorageOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'broker': obj.broker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecZookeeperStorageType
 */
export enum KafkaSpecZookeeperStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_HYPHEN_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecZookeeperJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJvmOptionsJavaSystemProperties(obj: KafkaSpecZookeeperJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaSpecZookeeperJmxOptionsAuthentication
 */
export interface KafkaSpecZookeeperJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaSpecZookeeperJmxOptionsAuthentication#type
   */
  readonly type: KafkaSpecZookeeperJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJmxOptionsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJmxOptionsAuthentication(obj: KafkaSpecZookeeperJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecZookeeperMetricsConfigType
 */
export enum KafkaSpecZookeeperMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecZookeeperMetricsConfigValueFrom
 */
export interface KafkaSpecZookeeperMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecZookeeperMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfigValueFrom(obj: KafkaSpecZookeeperMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecZookeeperLoggingType
 */
export enum KafkaSpecZookeeperLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecZookeeperLoggingValueFrom
 */
export interface KafkaSpecZookeeperLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecZookeeperLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLoggingValueFrom(obj: KafkaSpecZookeeperLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `StatefulSet`.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulset
 */
export interface KafkaSpecZookeeperTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecZookeeperTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateStatefulset' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateStatefulset(obj: KafkaSpecZookeeperTemplateStatefulset | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplateStatefulsetMetadata(obj.metadata),
    'podManagementPolicy': obj.podManagementPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `Pods`.
 *
 * @schema KafkaSpecZookeeperTemplatePod
 */
export interface KafkaSpecZookeeperTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecZookeeperTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecZookeeperTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecZookeeperTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecZookeeperTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecZookeeperTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecZookeeperTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecZookeeperTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecZookeeperTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecZookeeperTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecZookeeperTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecZookeeperTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecZookeeperTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecZookeeperTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecZookeeperTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecZookeeperTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePod(obj: KafkaSpecZookeeperTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecZookeeperTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecZookeeperTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecZookeeperTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecZookeeperTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecZookeeperTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper client `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateClientService
 */
export interface KafkaSpecZookeeperTemplateClientService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateClientService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateClientServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecZookeeperTemplateClientService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecZookeeperTemplateClientService#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecZookeeperTemplateClientServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateClientService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateClientService(obj: KafkaSpecZookeeperTemplateClientService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplateClientServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper nodes `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateNodesService
 */
export interface KafkaSpecZookeeperTemplateNodesService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateNodesService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateNodesServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecZookeeperTemplateNodesService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecZookeeperTemplateNodesService#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecZookeeperTemplateNodesServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateNodesService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateNodesService(obj: KafkaSpecZookeeperTemplateNodesService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplateNodesServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for all ZooKeeper `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaim(obj: KafkaSpecZookeeperTemplatePersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `PodDisruptionBudget`.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodDisruptionBudget(obj: KafkaSpecZookeeperTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the ZooKeeper container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainer
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#env
   */
  readonly env?: KafkaSpecZookeeperTemplateZookeeperContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainer(obj: KafkaSpecZookeeperTemplateZookeeperContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecZookeeperTemplateZookeeperContainerEnv(y)),
    'securityContext': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the ZooKeeper service account.
 *
 * @schema KafkaSpecZookeeperTemplateServiceAccount
 */
export interface KafkaSpecZookeeperTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateServiceAccount(obj: KafkaSpecZookeeperTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Zookeeper Cluster JMX authentication.
 *
 * @schema KafkaSpecZookeeperTemplateJmxSecret
 */
export interface KafkaSpecZookeeperTemplateJmxSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateJmxSecret#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateJmxSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateJmxSecret(obj: KafkaSpecZookeeperTemplateJmxSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplateJmxSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `StrimziPodSet` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodSet
 */
export interface KafkaSpecZookeeperTemplatePodSet {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePodSet#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodSetMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSet(obj: KafkaSpecZookeeperTemplatePodSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecZookeeperTemplatePodSetMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod startup checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorStartupProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorStartupProbe(obj: KafkaSpecEntityOperatorTopicOperatorStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLivenessProbe(obj: KafkaSpecEntityOperatorTopicOperatorLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorReadinessProbe(obj: KafkaSpecEntityOperatorTopicOperatorReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorResources
 */
export interface KafkaSpecEntityOperatorTopicOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorResources(obj: KafkaSpecEntityOperatorTopicOperatorResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLogging
 */
export interface KafkaSpecEntityOperatorTopicOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorTopicOperatorLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#valueFrom
   */
  readonly valueFrom?: KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLogging(obj: KafkaSpecEntityOperatorTopicOperatorLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptions(obj: KafkaSpecEntityOperatorTopicOperatorJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLivenessProbe(obj: KafkaSpecEntityOperatorUserOperatorLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorReadinessProbe(obj: KafkaSpecEntityOperatorUserOperatorReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorResources
 */
export interface KafkaSpecEntityOperatorUserOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorResources(obj: KafkaSpecEntityOperatorUserOperatorResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLogging
 */
export interface KafkaSpecEntityOperatorUserOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorUserOperatorLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#valueFrom
   */
  readonly valueFrom?: KafkaSpecEntityOperatorUserOperatorLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLogging(obj: KafkaSpecEntityOperatorUserOperatorLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorJvmOptions(obj: KafkaSpecEntityOperatorUserOperatorJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarLivenessProbe(obj: KafkaSpecEntityOperatorTlsSidecarLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecEntityOperatorTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarReadinessProbe(obj: KafkaSpecEntityOperatorTlsSidecarReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarResources
 */
export interface KafkaSpecEntityOperatorTlsSidecarResources {
  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarResources(obj: KafkaSpecEntityOperatorTlsSidecarResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator `Deployment`.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeployment
 */
export interface KafkaSpecEntityOperatorTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplateDeploymentMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateDeployment(obj: KafkaSpecEntityOperatorTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecEntityOperatorTemplateDeploymentMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator `Pods`.
 *
 * @schema KafkaSpecEntityOperatorTemplatePod
 */
export interface KafkaSpecEntityOperatorTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecEntityOperatorTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecEntityOperatorTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecEntityOperatorTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecEntityOperatorTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecEntityOperatorTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePod(obj: KafkaSpecEntityOperatorTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecEntityOperatorTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Topic Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainer(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv(y)),
    'securityContext': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity User Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainer(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv(y)),
    'securityContext': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Operator TLS sidecar container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainer(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv(y)),
    'securityContext': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Operator service account.
 *
 * @schema KafkaSpecEntityOperatorTemplateServiceAccount
 */
export interface KafkaSpecEntityOperatorTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateServiceAccount(obj: KafkaSpecEntityOperatorTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecEntityOperatorTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarLivenessProbe(obj: KafkaSpecCruiseControlTlsSidecarLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLogLevel
 */
export enum KafkaSpecCruiseControlTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarReadinessProbe(obj: KafkaSpecCruiseControlTlsSidecarReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarResources
 */
export interface KafkaSpecCruiseControlTlsSidecarResources {
  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarResources(obj: KafkaSpecCruiseControlTlsSidecarResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecCruiseControlJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlJvmOptionsJavaSystemProperties(obj: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecCruiseControlLoggingType
 */
export enum KafkaSpecCruiseControlLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecCruiseControlLoggingValueFrom
 */
export interface KafkaSpecCruiseControlLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecCruiseControlLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLoggingValueFrom(obj: KafkaSpecCruiseControlLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `Deployment`.
 *
 * @schema KafkaSpecCruiseControlTemplateDeployment
 */
export interface KafkaSpecCruiseControlTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateDeploymentMetadata;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateDeployment(obj: KafkaSpecCruiseControlTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecCruiseControlTemplateDeploymentMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `Pods`.
 *
 * @schema KafkaSpecCruiseControlTemplatePod
 */
export interface KafkaSpecCruiseControlTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecCruiseControlTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecCruiseControlTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecCruiseControlTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecCruiseControlTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecCruiseControlTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePod(obj: KafkaSpecCruiseControlTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecCruiseControlTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecCruiseControlTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecCruiseControlTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecCruiseControlTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecCruiseControlTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control API `Service`.
 *
 * @schema KafkaSpecCruiseControlTemplateApiService
 */
export interface KafkaSpecCruiseControlTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateApiService#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateApiServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecCruiseControlTemplateApiService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaSpecCruiseControlTemplateApiService#ipFamilies
   */
  readonly ipFamilies?: KafkaSpecCruiseControlTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateApiService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateApiService(obj: KafkaSpecCruiseControlTemplateApiService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecCruiseControlTemplateApiServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `PodDisruptionBudget`.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudget(obj: KafkaSpecCruiseControlTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainer(obj: KafkaSpecCruiseControlTemplateCruiseControlContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerEnv(y)),
    'securityContext': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control TLS sidecar container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainer(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv(y)),
    'securityContext': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control service account.
 *
 * @schema KafkaSpecCruiseControlTemplateServiceAccount
 */
export interface KafkaSpecCruiseControlTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateServiceAccount(obj: KafkaSpecCruiseControlTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecCruiseControlTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlBrokerCapacityOverrides
 */
export interface KafkaSpecCruiseControlBrokerCapacityOverrides {
  /**
   * List of Kafka brokers (broker identifiers).
   *
   * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#brokers
   */
  readonly brokers: number[];

  /**
   * Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#cpu
   */
  readonly cpu?: string;

  /**
   * Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#inboundNetwork
   */
  readonly inboundNetwork?: string;

  /**
   * Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#outboundNetwork
   */
  readonly outboundNetwork?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlBrokerCapacityOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlBrokerCapacityOverrides(obj: KafkaSpecCruiseControlBrokerCapacityOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brokers': obj.brokers?.map(y => y),
    'cpu': obj.cpu,
    'inboundNetwork': obj.inboundNetwork,
    'outboundNetwork': obj.outboundNetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigType
 */
export enum KafkaSpecCruiseControlMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigValueFrom
 */
export interface KafkaSpecCruiseControlMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecCruiseControlMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfigValueFrom(obj: KafkaSpecCruiseControlMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans `Deployment`.
 *
 * @schema KafkaSpecJmxTransTemplateDeployment
 */
export interface KafkaSpecJmxTransTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplateDeploymentMetadata;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateDeployment(obj: KafkaSpecJmxTransTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecJmxTransTemplateDeploymentMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans `Pods`.
 *
 * @schema KafkaSpecJmxTransTemplatePod
 */
export interface KafkaSpecJmxTransTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecJmxTransTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecJmxTransTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecJmxTransTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecJmxTransTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecJmxTransTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecJmxTransTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecJmxTransTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecJmxTransTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecJmxTransTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecJmxTransTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecJmxTransTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecJmxTransTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecJmxTransTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecJmxTransTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecJmxTransTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePod(obj: KafkaSpecJmxTransTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecJmxTransTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecJmxTransTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecJmxTransTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecJmxTransTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecJmxTransTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecJmxTransTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans container.
 *
 * @schema KafkaSpecJmxTransTemplateContainer
 */
export interface KafkaSpecJmxTransTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#env
   */
  readonly env?: KafkaSpecJmxTransTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplateContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainer(obj: KafkaSpecJmxTransTemplateContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecJmxTransTemplateContainerEnv(y)),
    'securityContext': toJson_KafkaSpecJmxTransTemplateContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the JMX Trans service account.
 *
 * @schema KafkaSpecJmxTransTemplateServiceAccount
 */
export interface KafkaSpecJmxTransTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateServiceAccount(obj: KafkaSpecJmxTransTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecJmxTransTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Deployment`.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeployment
 */
export interface KafkaSpecKafkaExporterTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateDeploymentMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateDeployment(obj: KafkaSpecKafkaExporterTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaExporterTemplateDeploymentMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Pods`.
 *
 * @schema KafkaSpecKafkaExporterTemplatePod
 */
export interface KafkaSpecKafkaExporterTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaExporterTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaExporterTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaExporterTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaExporterTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaExporterTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePod(obj: KafkaSpecKafkaExporterTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaExporterTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Service`.
 *
 * @schema KafkaSpecKafkaExporterTemplateService
 */
export interface KafkaSpecKafkaExporterTemplateService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateService#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateService(obj: KafkaSpecKafkaExporterTemplateService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaExporterTemplateServiceMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Exporter container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainer
 */
export interface KafkaSpecKafkaExporterTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#env
   */
  readonly env?: KafkaSpecKafkaExporterTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplateContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainer(obj: KafkaSpecKafkaExporterTemplateContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaSpecKafkaExporterTemplateContainerEnv(y)),
    'securityContext': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Exporter service account.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceAccount
 */
export interface KafkaSpecKafkaExporterTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceAccount(obj: KafkaSpecKafkaExporterTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaSpecKafkaExporterTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
 *
 * @schema KafkaSpecKafkaListenersAuthenticationClientSecret
 */
export interface KafkaSpecKafkaListenersAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationClientSecret(obj: KafkaSpecKafkaListenersAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersAuthenticationSecrets
 */
export interface KafkaSpecKafkaListenersAuthenticationSecrets {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationSecrets#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationSecrets#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationSecrets(obj: KafkaSpecKafkaListenersAuthenticationSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates(obj: KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.`custom` type allows for any authentication type to be used.
 *
 * @schema KafkaSpecKafkaListenersAuthenticationType
 */
export enum KafkaSpecKafkaListenersAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** oauth */
  OAUTH = "oauth",
  /** custom */
  CUSTOM = "custom",
}

/**
 * Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
 *
 * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey
 */
export interface KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey(obj: KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
 *
 * @schema KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy
 */
export enum KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Bootstrap configuration.
 *
 * @schema KafkaSpecKafkaListenersConfigurationBootstrap
 */
export interface KafkaSpecKafkaListenersConfigurationBootstrap {
  /**
   * Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#alternativeNames
   */
  readonly alternativeNames?: string[];

  /**
   * The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#host
   */
  readonly host?: string;

  /**
   * Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#nodePort
   */
  readonly nodePort?: number;

  /**
   * The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * Annotations that will be added to the `Ingress`, `Route`, or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#annotations
   */
  readonly annotations?: any;

  /**
   * Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBootstrap#labels
   */
  readonly labels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBootstrap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBootstrap(obj: KafkaSpecKafkaListenersConfigurationBootstrap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeNames': obj.alternativeNames?.map(y => y),
    'host': obj.host,
    'nodePort': obj.nodePort,
    'loadBalancerIP': obj.loadBalancerIp,
    'annotations': obj.annotations,
    'labels': obj.labels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersConfigurationBrokers
 */
export interface KafkaSpecKafkaListenersConfigurationBrokers {
  /**
   * ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#broker
   */
  readonly broker: number;

  /**
   * The host name which will be used in the brokers' `advertised.brokers`.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#advertisedHost
   */
  readonly advertisedHost?: string;

  /**
   * The port number which will be used in the brokers' `advertised.brokers`.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#advertisedPort
   */
  readonly advertisedPort?: number;

  /**
   * The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#host
   */
  readonly host?: string;

  /**
   * Node port for the per-broker service. This field can be used only with `nodeport` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#nodePort
   */
  readonly nodePort?: number;

  /**
   * The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#annotations
   */
  readonly annotations?: any;

  /**
   * Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
   *
   * @schema KafkaSpecKafkaListenersConfigurationBrokers#labels
   */
  readonly labels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBrokers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBrokers(obj: KafkaSpecKafkaListenersConfigurationBrokers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'broker': obj.broker,
    'advertisedHost': obj.advertisedHost,
    'advertisedPort': obj.advertisedPort,
    'host': obj.host,
    'nodePort': obj.nodePort,
    'loadBalancerIP': obj.loadBalancerIp,
    'annotations': obj.annotations,
    'labels': obj.labels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaListenersConfigurationIpFamilyPolicy
 */
export enum KafkaSpecKafkaListenersConfigurationIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaListenersConfigurationIpFamilies
 */
export enum KafkaSpecKafkaListenersConfigurationIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
 *
 * * `ExternalDNS`
 * * `ExternalIP`
 * * `InternalDNS`
 * * `InternalIP`
 * * `Hostname`
 *
 * This field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.
 *
 * @schema KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType
 */
export enum KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType {
  /** ExternalIP */
  EXTERNAL_IP = "ExternalIP",
  /** ExternalDNS */
  EXTERNAL_DNS = "ExternalDNS",
  /** InternalIP */
  INTERNAL_IP = "InternalIP",
  /** InternalDNS */
  INTERNAL_DNS = "InternalDNS",
  /** Hostname */
  HOSTNAME = "Hostname",
}

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock#cidr
   */
  readonly cidr?: string;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock(obj: KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector(obj: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector(obj: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaStorageVolumesOverrides
 */
export interface KafkaSpecKafkaStorageVolumesOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageVolumesOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageVolumesOverrides(obj: KafkaSpecKafkaStorageVolumesOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'broker': obj.broker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecKafkaStorageVolumesType
 */
export enum KafkaSpecKafkaStorageVolumesType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_HYPHEN_CLAIM = "persistent-claim",
}

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthenticationType
 */
export enum KafkaSpecKafkaJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecKafkaLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLoggingValueFromConfigMapKeyRef(obj: KafkaSpecKafkaLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateStatefulsetMetadata
 */
export interface KafkaSpecKafkaTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateStatefulsetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateStatefulsetMetadata(obj: KafkaSpecKafkaTemplateStatefulsetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodMetadata
 */
export interface KafkaSpecKafkaTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodMetadata(obj: KafkaSpecKafkaTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodImagePullSecrets(obj: KafkaSpecKafkaTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContext(obj: KafkaSpecKafkaTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecKafkaTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaTemplatePodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinity(obj: KafkaSpecKafkaTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTolerations
 */
export interface KafkaSpecKafkaTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTolerations(obj: KafkaSpecKafkaTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodHostAliases
 */
export interface KafkaSpecKafkaTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodHostAliases(obj: KafkaSpecKafkaTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraints(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBootstrapServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBootstrapServiceMetadata(obj: KafkaSpecKafkaTemplateBootstrapServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy
 */
export enum KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaTemplateBootstrapServiceIpFamilies
 */
export enum KafkaSpecKafkaTemplateBootstrapServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBrokersServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBrokersServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBrokersServiceMetadata(obj: KafkaSpecKafkaTemplateBrokersServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy
 */
export enum KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaTemplateBrokersServiceIpFamilies
 */
export enum KafkaSpecKafkaTemplateBrokersServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodServiceMetadata(obj: KafkaSpecKafkaTemplatePerPodServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodRouteMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodRouteMetadata(obj: KafkaSpecKafkaTemplatePerPodRouteMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodIngressMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodIngressMetadata(obj: KafkaSpecKafkaTemplatePerPodIngressMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata(obj: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerEnv
 */
export interface KafkaSpecKafkaTemplateKafkaContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerEnv(obj: KafkaSpecKafkaTemplateKafkaContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContext(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerEnv
 */
export interface KafkaSpecKafkaTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerEnv(obj: KafkaSpecKafkaTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContext(obj: KafkaSpecKafkaTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata
 */
export interface KafkaSpecKafkaTemplateClusterCaCertMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterCaCertMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterCaCertMetadata(obj: KafkaSpecKafkaTemplateClusterCaCertMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateServiceAccountMetadata
 */
export interface KafkaSpecKafkaTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateServiceAccountMetadata(obj: KafkaSpecKafkaTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateJmxSecretMetadata
 */
export interface KafkaSpecKafkaTemplateJmxSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateJmxSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateJmxSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateJmxSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateJmxSecretMetadata(obj: KafkaSpecKafkaTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata
 */
export interface KafkaSpecKafkaTemplateClusterRoleBindingMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterRoleBindingMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterRoleBindingMetadata(obj: KafkaSpecKafkaTemplateClusterRoleBindingMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodSetMetadata
 */
export interface KafkaSpecKafkaTemplatePodSetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodSetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodSetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSetMetadata(obj: KafkaSpecKafkaTemplatePodSetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecZookeeperJmxOptionsAuthenticationType
 */
export enum KafkaSpecZookeeperJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef(obj: KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata
 */
export interface KafkaSpecZookeeperTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateStatefulsetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateStatefulsetMetadata(obj: KafkaSpecZookeeperTemplateStatefulsetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodMetadata
 */
export interface KafkaSpecZookeeperTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodMetadata(obj: KafkaSpecZookeeperTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets
 */
export interface KafkaSpecZookeeperTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodImagePullSecrets(obj: KafkaSpecZookeeperTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecZookeeperTemplatePodSecurityContext
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecZookeeperTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContext(obj: KafkaSpecZookeeperTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecZookeeperTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperTemplatePodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinity(obj: KafkaSpecZookeeperTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTolerations
 */
export interface KafkaSpecZookeeperTemplatePodTolerations {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTolerations(obj: KafkaSpecZookeeperTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodHostAliases
 */
export interface KafkaSpecZookeeperTemplatePodHostAliases {
  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodHostAliases(obj: KafkaSpecZookeeperTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraints(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateClientServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateClientServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateClientServiceMetadata(obj: KafkaSpecZookeeperTemplateClientServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy
 */
export enum KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecZookeeperTemplateClientServiceIpFamilies
 */
export enum KafkaSpecZookeeperTemplateClientServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateNodesServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateNodesServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateNodesServiceMetadata(obj: KafkaSpecZookeeperTemplateNodesServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy
 */
export enum KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecZookeeperTemplateNodesServiceIpFamilies
 */
export enum KafkaSpecZookeeperTemplateNodesServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata(obj: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerEnv(obj: KafkaSpecZookeeperTemplateZookeeperContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata
 */
export interface KafkaSpecZookeeperTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateServiceAccountMetadata(obj: KafkaSpecZookeeperTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata
 */
export interface KafkaSpecZookeeperTemplateJmxSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateJmxSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateJmxSecretMetadata(obj: KafkaSpecZookeeperTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodSetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodSetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodSetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodSetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSetMetadata(obj: KafkaSpecZookeeperTemplatePodSetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorTopicOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom
 */
export interface KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom(obj: KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties(obj: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorUserOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFrom
 */
export interface KafkaSpecEntityOperatorUserOperatorLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFrom(obj: KafkaSpecEntityOperatorUserOperatorLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties(obj: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata
 */
export interface KafkaSpecEntityOperatorTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateDeploymentMetadata(obj: KafkaSpecEntityOperatorTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodMetadata
 */
export interface KafkaSpecEntityOperatorTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodMetadata(obj: KafkaSpecEntityOperatorTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets
 */
export interface KafkaSpecEntityOperatorTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodImagePullSecrets(obj: KafkaSpecEntityOperatorTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContext(obj: KafkaSpecEntityOperatorTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTolerations
 */
export interface KafkaSpecEntityOperatorTemplatePodTolerations {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTolerations(obj: KafkaSpecEntityOperatorTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodHostAliases
 */
export interface KafkaSpecEntityOperatorTemplatePodHostAliases {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodHostAliases(obj: KafkaSpecEntityOperatorTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata
 */
export interface KafkaSpecEntityOperatorTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateServiceAccountMetadata(obj: KafkaSpecEntityOperatorTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef(obj: KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata
 */
export interface KafkaSpecCruiseControlTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateDeploymentMetadata(obj: KafkaSpecCruiseControlTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodMetadata(obj: KafkaSpecCruiseControlTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets
 */
export interface KafkaSpecCruiseControlTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodImagePullSecrets(obj: KafkaSpecCruiseControlTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContext
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContext(obj: KafkaSpecCruiseControlTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecCruiseControlTemplatePodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTolerations
 */
export interface KafkaSpecCruiseControlTemplatePodTolerations {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTolerations(obj: KafkaSpecCruiseControlTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodHostAliases
 */
export interface KafkaSpecCruiseControlTemplatePodHostAliases {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodHostAliases(obj: KafkaSpecCruiseControlTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata
 */
export interface KafkaSpecCruiseControlTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateApiServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateApiServiceMetadata(obj: KafkaSpecCruiseControlTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecCruiseControlTemplateApiServiceIpFamilies
 */
export enum KafkaSpecCruiseControlTemplateApiServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerEnv(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata
 */
export interface KafkaSpecCruiseControlTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateServiceAccountMetadata(obj: KafkaSpecCruiseControlTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateDeploymentMetadata
 */
export interface KafkaSpecJmxTransTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateDeploymentMetadata(obj: KafkaSpecJmxTransTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplatePodMetadata
 */
export interface KafkaSpecJmxTransTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodMetadata(obj: KafkaSpecJmxTransTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets
 */
export interface KafkaSpecJmxTransTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodImagePullSecrets(obj: KafkaSpecJmxTransTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecJmxTransTemplatePodSecurityContext
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecJmxTransTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContext(obj: KafkaSpecJmxTransTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecJmxTransTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecJmxTransTemplatePodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinity(obj: KafkaSpecJmxTransTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTolerations
 */
export interface KafkaSpecJmxTransTemplatePodTolerations {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTolerations(obj: KafkaSpecJmxTransTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodHostAliases
 */
export interface KafkaSpecJmxTransTemplatePodHostAliases {
  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodHostAliases(obj: KafkaSpecJmxTransTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraints(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerEnv
 */
export interface KafkaSpecJmxTransTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerEnv(obj: KafkaSpecJmxTransTemplateContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContext
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContext(obj: KafkaSpecJmxTransTemplateContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata
 */
export interface KafkaSpecJmxTransTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateServiceAccountMetadata(obj: KafkaSpecJmxTransTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata
 */
export interface KafkaSpecKafkaExporterTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateDeploymentMetadata(obj: KafkaSpecKafkaExporterTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodMetadata
 */
export interface KafkaSpecKafkaExporterTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodMetadata(obj: KafkaSpecKafkaExporterTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaExporterTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodImagePullSecrets(obj: KafkaSpecKafkaExporterTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContext(obj: KafkaSpecKafkaExporterTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTolerations
 */
export interface KafkaSpecKafkaExporterTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTolerations(obj: KafkaSpecKafkaExporterTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodHostAliases
 */
export interface KafkaSpecKafkaExporterTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodHostAliases(obj: KafkaSpecKafkaExporterTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceMetadata(obj: KafkaSpecKafkaExporterTemplateServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerEnv
 */
export interface KafkaSpecKafkaExporterTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerEnv(obj: KafkaSpecKafkaExporterTemplateContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContext(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceAccountMetadata(obj: KafkaSpecKafkaExporterTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions(obj: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSysctls(obj: KafkaSpecKafkaTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinity(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinity(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSysctls(obj: KafkaSpecZookeeperTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef(obj: KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef(obj: KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSysctls(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSysctls(obj: KafkaSpecJmxTransTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities(obj: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions(obj: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile(obj: KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions(obj: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaBridge
 */
export class KafkaBridge extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaBridge"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaBridge',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaBridge".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaBridgeProps = {}): any {
    return {
      ...KafkaBridge.GVK,
      ...toJson_KafkaBridgeProps(props),
    };
  }

  /**
   * Defines a "KafkaBridge" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaBridgeProps = {}) {
    super(scope, id, {
      ...KafkaBridge.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaBridge.GVK,
      ...toJson_KafkaBridgeProps(resolved),
    };
  }
}

/**
 * @schema KafkaBridge
 */
export interface KafkaBridgeProps {
  /**
   * @schema KafkaBridge#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka Bridge.
   *
   * @schema KafkaBridge#spec
   */
  readonly spec?: KafkaBridgeSpec;

}

/**
 * Converts an object of type 'KafkaBridgeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeProps(obj: KafkaBridgeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaBridgeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka Bridge.
 *
 * @schema KafkaBridgeSpec
 */
export interface KafkaBridgeSpec {
  /**
   * The number of pods in the `Deployment`.
   *
   * @schema KafkaBridgeSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaBridgeSpec#image
   */
  readonly image?: string;

  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaBridgeSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration for connecting Kafka Bridge to the cluster.
   *
   * @schema KafkaBridgeSpec#tls
   */
  readonly tls?: KafkaBridgeSpecTls;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaBridgeSpec#authentication
   */
  readonly authentication?: KafkaBridgeSpecAuthentication;

  /**
   * The HTTP related configuration.
   *
   * @schema KafkaBridgeSpec#http
   */
  readonly http?: KafkaBridgeSpecHttp;

  /**
   * Kafka AdminClient related configuration.
   *
   * @schema KafkaBridgeSpec#adminClient
   */
  readonly adminClient?: KafkaBridgeSpecAdminClient;

  /**
   * Kafka consumer related configuration.
   *
   * @schema KafkaBridgeSpec#consumer
   */
  readonly consumer?: KafkaBridgeSpecConsumer;

  /**
   * Kafka producer related configuration.
   *
   * @schema KafkaBridgeSpec#producer
   */
  readonly producer?: KafkaBridgeSpecProducer;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaBridgeSpec#resources
   */
  readonly resources?: KafkaBridgeSpecResources;

  /**
   * **Currently not supported** JVM Options for pods.
   *
   * @schema KafkaBridgeSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaBridgeSpecJvmOptions;

  /**
   * Logging configuration for Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#logging
   */
  readonly logging?: KafkaBridgeSpecLogging;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaBridgeSpec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * Configuration of the node label which will be used as the client.rack consumer configuration.
   *
   * @schema KafkaBridgeSpec#rack
   */
  readonly rack?: KafkaBridgeSpecRack;

  /**
   * Enable the metrics for the Kafka Bridge. Default is false.
   *
   * @default false.
   * @schema KafkaBridgeSpec#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaBridgeSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaBridgeSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaBridgeSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaBridgeSpecReadinessProbe;

  /**
   * Template for Kafka Bridge resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
   *
   * @schema KafkaBridgeSpec#template
   */
  readonly template?: KafkaBridgeSpecTemplate;

  /**
   * The configuration of tracing in Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#tracing
   */
  readonly tracing?: KafkaBridgeSpecTracing;

}

/**
 * Converts an object of type 'KafkaBridgeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpec(obj: KafkaBridgeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas,
    'image': obj.image,
    'bootstrapServers': obj.bootstrapServers,
    'tls': toJson_KafkaBridgeSpecTls(obj.tls),
    'authentication': toJson_KafkaBridgeSpecAuthentication(obj.authentication),
    'http': toJson_KafkaBridgeSpecHttp(obj.http),
    'adminClient': toJson_KafkaBridgeSpecAdminClient(obj.adminClient),
    'consumer': toJson_KafkaBridgeSpecConsumer(obj.consumer),
    'producer': toJson_KafkaBridgeSpecProducer(obj.producer),
    'resources': toJson_KafkaBridgeSpecResources(obj.resources),
    'jvmOptions': toJson_KafkaBridgeSpecJvmOptions(obj.jvmOptions),
    'logging': toJson_KafkaBridgeSpecLogging(obj.logging),
    'clientRackInitImage': obj.clientRackInitImage,
    'rack': toJson_KafkaBridgeSpecRack(obj.rack),
    'enableMetrics': obj.enableMetrics,
    'livenessProbe': toJson_KafkaBridgeSpecLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaBridgeSpecReadinessProbe(obj.readinessProbe),
    'template': toJson_KafkaBridgeSpecTemplate(obj.template),
    'tracing': toJson_KafkaBridgeSpecTracing(obj.tracing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for connecting Kafka Bridge to the cluster.
 *
 * @schema KafkaBridgeSpecTls
 */
export interface KafkaBridgeSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaBridgeSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaBridgeSpecTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTls(obj: KafkaBridgeSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaBridgeSpecTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaBridgeSpecAuthentication
 */
export interface KafkaBridgeSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaBridgeSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaBridgeSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaBridgeSpecAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaBridgeSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaBridgeSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaBridgeSpecAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaBridgeSpecAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaBridgeSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaBridgeSpecAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaBridgeSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaBridgeSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaBridgeSpecAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaBridgeSpecAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaBridgeSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaBridgeSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaBridgeSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaBridgeSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaBridgeSpecAuthentication#type
   */
  readonly type: KafkaBridgeSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaBridgeSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthentication(obj: KafkaBridgeSpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaBridgeSpecAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaBridgeSpecAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaBridgeSpecAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaBridgeSpecAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaBridgeSpecAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaBridgeSpecAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The HTTP related configuration.
 *
 * @schema KafkaBridgeSpecHttp
 */
export interface KafkaBridgeSpecHttp {
  /**
   * The port which is the server listening on.
   *
   * @schema KafkaBridgeSpecHttp#port
   */
  readonly port?: number;

  /**
   * CORS configuration for the HTTP Bridge.
   *
   * @schema KafkaBridgeSpecHttp#cors
   */
  readonly cors?: KafkaBridgeSpecHttpCors;

}

/**
 * Converts an object of type 'KafkaBridgeSpecHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecHttp(obj: KafkaBridgeSpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'cors': toJson_KafkaBridgeSpecHttpCors(obj.cors),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kafka AdminClient related configuration.
 *
 * @schema KafkaBridgeSpecAdminClient
 */
export interface KafkaBridgeSpecAdminClient {
  /**
   * The Kafka AdminClient configuration used for AdminClient instances created by the bridge.
   *
   * @schema KafkaBridgeSpecAdminClient#config
   */
  readonly config?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAdminClient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAdminClient(obj: KafkaBridgeSpecAdminClient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kafka consumer related configuration.
 *
 * @schema KafkaBridgeSpecConsumer
 */
export interface KafkaBridgeSpecConsumer {
  /**
   * The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecConsumer#config
   */
  readonly config?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecConsumer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecConsumer(obj: KafkaBridgeSpecConsumer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kafka producer related configuration.
 *
 * @schema KafkaBridgeSpecProducer
 */
export interface KafkaBridgeSpecProducer {
  /**
   * The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecProducer#config
   */
  readonly config?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecProducer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecProducer(obj: KafkaBridgeSpecProducer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaBridgeSpecResources
 */
export interface KafkaBridgeSpecResources {
  /**
   * @schema KafkaBridgeSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaBridgeSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecResources(obj: KafkaBridgeSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * **Currently not supported** JVM Options for pods.
 *
 * @schema KafkaBridgeSpecJvmOptions
 */
export interface KafkaBridgeSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaBridgeSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaBridgeSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecJvmOptions(obj: KafkaBridgeSpecJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaBridgeSpecJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka Bridge.
 *
 * @schema KafkaBridgeSpecLogging
 */
export interface KafkaBridgeSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaBridgeSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaBridgeSpecLogging#type
   */
  readonly type: KafkaBridgeSpecLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaBridgeSpecLogging#valueFrom
   */
  readonly valueFrom?: KafkaBridgeSpecLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaBridgeSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecLogging(obj: KafkaBridgeSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaBridgeSpecLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the node label which will be used as the client.rack consumer configuration.
 *
 * @schema KafkaBridgeSpecRack
 */
export interface KafkaBridgeSpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.0.
   *
   * @schema KafkaBridgeSpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecRack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecRack(obj: KafkaBridgeSpecRack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaBridgeSpecLivenessProbe
 */
export interface KafkaBridgeSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaBridgeSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecLivenessProbe(obj: KafkaBridgeSpecLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaBridgeSpecReadinessProbe
 */
export interface KafkaBridgeSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaBridgeSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecReadinessProbe(obj: KafkaBridgeSpecReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Bridge resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
 *
 * @schema KafkaBridgeSpecTemplate
 */
export interface KafkaBridgeSpecTemplate {
  /**
   * Template for Kafka Bridge `Deployment`.
   *
   * @schema KafkaBridgeSpecTemplate#deployment
   */
  readonly deployment?: KafkaBridgeSpecTemplateDeployment;

  /**
   * Template for Kafka Bridge `Pods`.
   *
   * @schema KafkaBridgeSpecTemplate#pod
   */
  readonly pod?: KafkaBridgeSpecTemplatePod;

  /**
   * Template for Kafka Bridge API `Service`.
   *
   * @schema KafkaBridgeSpecTemplate#apiService
   */
  readonly apiService?: KafkaBridgeSpecTemplateApiService;

  /**
   * Template for Kafka Bridge `PodDisruptionBudget`.
   *
   * @schema KafkaBridgeSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaBridgeSpecTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka Bridge container.
   *
   * @schema KafkaBridgeSpecTemplate#bridgeContainer
   */
  readonly bridgeContainer?: KafkaBridgeSpecTemplateBridgeContainer;

  /**
   * Template for the Kafka Bridge service account.
   *
   * @schema KafkaBridgeSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaBridgeSpecTemplateServiceAccount;

  /**
   * Template for the Kafka Bridge init container.
   *
   * @schema KafkaBridgeSpecTemplate#initContainer
   */
  readonly initContainer?: KafkaBridgeSpecTemplateInitContainer;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplate(obj: KafkaBridgeSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaBridgeSpecTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaBridgeSpecTemplatePod(obj.pod),
    'apiService': toJson_KafkaBridgeSpecTemplateApiService(obj.apiService),
    'podDisruptionBudget': toJson_KafkaBridgeSpecTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'bridgeContainer': toJson_KafkaBridgeSpecTemplateBridgeContainer(obj.bridgeContainer),
    'serviceAccount': toJson_KafkaBridgeSpecTemplateServiceAccount(obj.serviceAccount),
    'initContainer': toJson_KafkaBridgeSpecTemplateInitContainer(obj.initContainer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of tracing in Kafka Bridge.
 *
 * @schema KafkaBridgeSpecTracing
 */
export interface KafkaBridgeSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
   *
   * @schema KafkaBridgeSpecTracing#type
   */
  readonly type: KafkaBridgeSpecTracingType;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTracing(obj: KafkaBridgeSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTlsTrustedCertificates
 */
export interface KafkaBridgeSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTlsTrustedCertificates(obj: KafkaBridgeSpecTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationAccessToken
 */
export interface KafkaBridgeSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationAccessToken(obj: KafkaBridgeSpecAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaBridgeSpecAuthenticationCertificateAndKey
 */
export interface KafkaBridgeSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationCertificateAndKey(obj: KafkaBridgeSpecAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaBridgeSpecAuthenticationClientSecret
 */
export interface KafkaBridgeSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationClientSecret(obj: KafkaBridgeSpecAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaBridgeSpecAuthenticationPasswordSecret
 */
export interface KafkaBridgeSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationPasswordSecret(obj: KafkaBridgeSpecAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationRefreshToken
 */
export interface KafkaBridgeSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationRefreshToken(obj: KafkaBridgeSpecAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaBridgeSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecAuthenticationTlsTrustedCertificates(obj: KafkaBridgeSpecAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaBridgeSpecAuthenticationType
 */
export enum KafkaBridgeSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_HYPHEN_SHA_HYPHEN_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * CORS configuration for the HTTP Bridge.
 *
 * @schema KafkaBridgeSpecHttpCors
 */
export interface KafkaBridgeSpecHttpCors {
  /**
   * List of allowed origins. Java regular expressions can be used.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedOrigins
   */
  readonly allowedOrigins: string[];

  /**
   * List of allowed HTTP methods.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedMethods
   */
  readonly allowedMethods: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecHttpCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecHttpCors(obj: KafkaBridgeSpecHttpCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedOrigins': obj.allowedOrigins?.map(y => y),
    'allowedMethods': obj.allowedMethods?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaBridgeSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecJvmOptionsJavaSystemProperties(obj: KafkaBridgeSpecJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaBridgeSpecLoggingType
 */
export enum KafkaBridgeSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaBridgeSpecLoggingValueFrom
 */
export interface KafkaBridgeSpecLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaBridgeSpecLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaBridgeSpecLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaBridgeSpecLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecLoggingValueFrom(obj: KafkaBridgeSpecLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaBridgeSpecLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Bridge `Deployment`.
 *
 * @schema KafkaBridgeSpecTemplateDeployment
 */
export interface KafkaBridgeSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateDeploymentMetadata;

  /**
   * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
   *
   * @default RollingUpdate`.
   * @schema KafkaBridgeSpecTemplateDeployment#deploymentStrategy
   */
  readonly deploymentStrategy?: KafkaBridgeSpecTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateDeployment(obj: KafkaBridgeSpecTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaBridgeSpecTemplateDeploymentMetadata(obj.metadata),
    'deploymentStrategy': obj.deploymentStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Bridge `Pods`.
 *
 * @schema KafkaBridgeSpecTemplatePod
 */
export interface KafkaBridgeSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaBridgeSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaBridgeSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaBridgeSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaBridgeSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaBridgeSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaBridgeSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaBridgeSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaBridgeSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaBridgeSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaBridgeSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaBridgeSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaBridgeSpecTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaBridgeSpecTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaBridgeSpecTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaBridgeSpecTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaBridgeSpecTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePod(obj: KafkaBridgeSpecTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaBridgeSpecTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaBridgeSpecTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaBridgeSpecTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaBridgeSpecTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaBridgeSpecTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaBridgeSpecTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Bridge API `Service`.
 *
 * @schema KafkaBridgeSpecTemplateApiService
 */
export interface KafkaBridgeSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateApiServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaBridgeSpecTemplateApiService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaBridgeSpecTemplateApiService#ipFamilies
   */
  readonly ipFamilies?: KafkaBridgeSpecTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateApiService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateApiService(obj: KafkaBridgeSpecTemplateApiService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaBridgeSpecTemplateApiServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Bridge `PodDisruptionBudget`.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudget
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodDisruptionBudget(obj: KafkaBridgeSpecTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Bridge container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainer
 */
export interface KafkaBridgeSpecTemplateBridgeContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#env
   */
  readonly env?: KafkaBridgeSpecTemplateBridgeContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplateBridgeContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainer(obj: KafkaBridgeSpecTemplateBridgeContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaBridgeSpecTemplateBridgeContainerEnv(y)),
    'securityContext': toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Bridge service account.
 *
 * @schema KafkaBridgeSpecTemplateServiceAccount
 */
export interface KafkaBridgeSpecTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateServiceAccount(obj: KafkaBridgeSpecTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaBridgeSpecTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Bridge init container.
 *
 * @schema KafkaBridgeSpecTemplateInitContainer
 */
export interface KafkaBridgeSpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaBridgeSpecTemplateInitContainer#env
   */
  readonly env?: KafkaBridgeSpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaBridgeSpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainer(obj: KafkaBridgeSpecTemplateInitContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaBridgeSpecTemplateInitContainerEnv(y)),
    'securityContext': toJson_KafkaBridgeSpecTemplateInitContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
 *
 * @schema KafkaBridgeSpecTracingType
 */
export enum KafkaBridgeSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
  /** opentelemetry */
  OPENTELEMETRY = "opentelemetry",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaBridgeSpecLoggingValueFromConfigMapKeyRef
 */
export interface KafkaBridgeSpecLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaBridgeSpecLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaBridgeSpecLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaBridgeSpecLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecLoggingValueFromConfigMapKeyRef(obj: KafkaBridgeSpecLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateDeploymentMetadata
 */
export interface KafkaBridgeSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateDeploymentMetadata(obj: KafkaBridgeSpecTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaBridgeSpecTemplateDeploymentDeploymentStrategy
 */
export enum KafkaBridgeSpecTemplateDeploymentDeploymentStrategy {
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplatePodMetadata
 */
export interface KafkaBridgeSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodMetadata(obj: KafkaBridgeSpecTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodImagePullSecrets
 */
export interface KafkaBridgeSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaBridgeSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodImagePullSecrets(obj: KafkaBridgeSpecTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaBridgeSpecTemplatePodSecurityContext
 */
export interface KafkaBridgeSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaBridgeSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodSecurityContext(obj: KafkaBridgeSpecTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaBridgeSpecTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaBridgeSpecTemplatePodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaBridgeSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinity(obj: KafkaBridgeSpecTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodTolerations
 */
export interface KafkaBridgeSpecTemplatePodTolerations {
  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodTolerations(obj: KafkaBridgeSpecTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodHostAliases
 */
export interface KafkaBridgeSpecTemplatePodHostAliases {
  /**
   * @schema KafkaBridgeSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodHostAliases(obj: KafkaBridgeSpecTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints
 */
export interface KafkaBridgeSpecTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraints(obj: KafkaBridgeSpecTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateApiServiceMetadata
 */
export interface KafkaBridgeSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateApiServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateApiServiceMetadata(obj: KafkaBridgeSpecTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaBridgeSpecTemplateApiServiceIpFamilies
 */
export enum KafkaBridgeSpecTemplateApiServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata(obj: KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerEnv
 */
export interface KafkaBridgeSpecTemplateBridgeContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerEnv(obj: KafkaBridgeSpecTemplateBridgeContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContext(obj: KafkaBridgeSpecTemplateBridgeContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateServiceAccountMetadata
 */
export interface KafkaBridgeSpecTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateServiceAccountMetadata(obj: KafkaBridgeSpecTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateInitContainerEnv
 */
export interface KafkaBridgeSpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaBridgeSpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaBridgeSpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerEnv(obj: KafkaBridgeSpecTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext
 */
export interface KafkaBridgeSpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerSecurityContext(obj: KafkaBridgeSpecTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions(obj: KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile(obj: KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodSecurityContextSysctls(obj: KafkaBridgeSpecTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions(obj: KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinity(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinity(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities(obj: KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions(obj: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile(obj: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions(obj: KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities(obj: KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaConnect
 */
export class KafkaConnect extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnect"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaConnect',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnect".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectProps = {}): any {
    return {
      ...KafkaConnect.GVK,
      ...toJson_KafkaConnectProps(props),
    };
  }

  /**
   * Defines a "KafkaConnect" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectProps = {}) {
    super(scope, id, {
      ...KafkaConnect.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaConnect.GVK,
      ...toJson_KafkaConnectProps(resolved),
    };
  }
}

/**
 * @schema KafkaConnect
 */
export interface KafkaConnectProps {
  /**
   * @schema KafkaConnect#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka Connect cluster.
   *
   * @schema KafkaConnect#spec
   */
  readonly spec?: KafkaConnectSpec;

}

/**
 * Converts an object of type 'KafkaConnectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectProps(obj: KafkaConnectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaConnectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka Connect cluster.
 *
 * @schema KafkaConnectSpec
 */
export interface KafkaConnectSpec {
  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaConnectSpec#version
   */
  readonly version?: string;

  /**
   * The number of pods in the Kafka Connect group.
   *
   * @schema KafkaConnectSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaConnectSpec#image
   */
  readonly image?: string;

  /**
   * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
   *
   * @schema KafkaConnectSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration.
   *
   * @schema KafkaConnectSpec#tls
   */
  readonly tls?: KafkaConnectSpecTls;

  /**
   * Authentication configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#authentication
   */
  readonly authentication?: KafkaConnectSpecAuthentication;

  /**
   * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaConnectSpec#config
   */
  readonly config?: any;

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaConnectSpec#resources
   */
  readonly resources?: KafkaConnectSpecResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaConnectSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaConnectSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaConnectSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaConnectSpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaConnectSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaConnectSpecJvmOptions;

  /**
   * JMX Options.
   *
   * @schema KafkaConnectSpec#jmxOptions
   */
  readonly jmxOptions?: KafkaConnectSpecJmxOptions;

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#logging
   */
  readonly logging?: KafkaConnectSpecLogging;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaConnectSpec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * Configuration of the node label which will be used as the `client.rack` consumer configuration.
   *
   * @schema KafkaConnectSpec#rack
   */
  readonly rack?: KafkaConnectSpecRack;

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaConnectSpec#tracing
   */
  readonly tracing?: KafkaConnectSpecTracing;

  /**
   * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaConnectSpec#template
   */
  readonly template?: KafkaConnectSpecTemplate;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaConnectSpec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaConnectSpecExternalConfiguration;

  /**
   * Configures how the Connect container image should be built. Optional.
   *
   * @schema KafkaConnectSpec#build
   */
  readonly build?: KafkaConnectSpecBuild;

  /**
   * Metrics configuration.
   *
   * @schema KafkaConnectSpec#metricsConfig
   */
  readonly metricsConfig?: KafkaConnectSpecMetricsConfig;

}

/**
 * Converts an object of type 'KafkaConnectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpec(obj: KafkaConnectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'replicas': obj.replicas,
    'image': obj.image,
    'bootstrapServers': obj.bootstrapServers,
    'tls': toJson_KafkaConnectSpecTls(obj.tls),
    'authentication': toJson_KafkaConnectSpecAuthentication(obj.authentication),
    'config': obj.config,
    'resources': toJson_KafkaConnectSpecResources(obj.resources),
    'livenessProbe': toJson_KafkaConnectSpecLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaConnectSpecReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaConnectSpecJvmOptions(obj.jvmOptions),
    'jmxOptions': toJson_KafkaConnectSpecJmxOptions(obj.jmxOptions),
    'logging': toJson_KafkaConnectSpecLogging(obj.logging),
    'clientRackInitImage': obj.clientRackInitImage,
    'rack': toJson_KafkaConnectSpecRack(obj.rack),
    'tracing': toJson_KafkaConnectSpecTracing(obj.tracing),
    'template': toJson_KafkaConnectSpecTemplate(obj.template),
    'externalConfiguration': toJson_KafkaConnectSpecExternalConfiguration(obj.externalConfiguration),
    'build': toJson_KafkaConnectSpecBuild(obj.build),
    'metricsConfig': toJson_KafkaConnectSpecMetricsConfig(obj.metricsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration.
 *
 * @schema KafkaConnectSpecTls
 */
export interface KafkaConnectSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaConnectSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaConnectSpecTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTls(obj: KafkaConnectSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaConnectSpecTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecAuthentication
 */
export interface KafkaConnectSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaConnectSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaConnectSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaConnectSpecAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaConnectSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaConnectSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaConnectSpecAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaConnectSpecAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaConnectSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaConnectSpecAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaConnectSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaConnectSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaConnectSpecAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaConnectSpecAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaConnectSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaConnectSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaConnectSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaConnectSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaConnectSpecAuthentication#type
   */
  readonly type: KafkaConnectSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaConnectSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthentication(obj: KafkaConnectSpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaConnectSpecAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaConnectSpecAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaConnectSpecAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaConnectSpecAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaConnectSpecAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaConnectSpecAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaConnectSpecResources
 */
export interface KafkaConnectSpecResources {
  /**
   * @schema KafkaConnectSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecResources(obj: KafkaConnectSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaConnectSpecLivenessProbe
 */
export interface KafkaConnectSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaConnectSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLivenessProbe(obj: KafkaConnectSpecLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaConnectSpecReadinessProbe
 */
export interface KafkaConnectSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaConnectSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecReadinessProbe(obj: KafkaConnectSpecReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaConnectSpecJvmOptions
 */
export interface KafkaConnectSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaConnectSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaConnectSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaConnectSpecJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJvmOptions(obj: KafkaConnectSpecJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaConnectSpecJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JMX Options.
 *
 * @schema KafkaConnectSpecJmxOptions
 */
export interface KafkaConnectSpecJmxOptions {
  /**
   * Authentication configuration for connecting to the JMX port.
   *
   * @schema KafkaConnectSpecJmxOptions#authentication
   */
  readonly authentication?: KafkaConnectSpecJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaConnectSpecJmxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJmxOptions(obj: KafkaConnectSpecJmxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaConnectSpecJmxOptionsAuthentication(obj.authentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecLogging
 */
export interface KafkaConnectSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaConnectSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaConnectSpecLogging#type
   */
  readonly type: KafkaConnectSpecLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaConnectSpecLogging#valueFrom
   */
  readonly valueFrom?: KafkaConnectSpecLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLogging(obj: KafkaConnectSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaConnectSpecLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the node label which will be used as the `client.rack` consumer configuration.
 *
 * @schema KafkaConnectSpecRack
 */
export interface KafkaConnectSpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.0.
   *
   * @schema KafkaConnectSpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecRack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecRack(obj: KafkaConnectSpecRack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaConnectSpecTracing
 */
export interface KafkaConnectSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
   *
   * @schema KafkaConnectSpecTracing#type
   */
  readonly type: KafkaConnectSpecTracingType;

}

/**
 * Converts an object of type 'KafkaConnectSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTracing(obj: KafkaConnectSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaConnectSpecTemplate
 */
export interface KafkaConnectSpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaConnectSpecTemplate#deployment
   */
  readonly deployment?: KafkaConnectSpecTemplateDeployment;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaConnectSpecTemplate#pod
   */
  readonly pod?: KafkaConnectSpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaConnectSpecTemplate#apiService
   */
  readonly apiService?: KafkaConnectSpecTemplateApiService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaConnectSpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaConnectSpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaConnectSpecTemplate#initContainer
   */
  readonly initContainer?: KafkaConnectSpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaConnectSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaConnectSpecTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka Connect service account.
   *
   * @schema KafkaConnectSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaConnectSpecTemplateServiceAccount;

  /**
   * Template for the Kafka Connect ClusterRoleBinding.
   *
   * @schema KafkaConnectSpecTemplate#clusterRoleBinding
   */
  readonly clusterRoleBinding?: KafkaConnectSpecTemplateClusterRoleBinding;

  /**
   * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
   *
   * @schema KafkaConnectSpecTemplate#buildPod
   */
  readonly buildPod?: KafkaConnectSpecTemplateBuildPod;

  /**
   * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
   *
   * @schema KafkaConnectSpecTemplate#buildContainer
   */
  readonly buildContainer?: KafkaConnectSpecTemplateBuildContainer;

  /**
   * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
   *
   * @schema KafkaConnectSpecTemplate#buildConfig
   */
  readonly buildConfig?: KafkaConnectSpecTemplateBuildConfig;

  /**
   * Template for the Kafka Connect Build service account.
   *
   * @schema KafkaConnectSpecTemplate#buildServiceAccount
   */
  readonly buildServiceAccount?: KafkaConnectSpecTemplateBuildServiceAccount;

  /**
   * Template for Secret of the Kafka Connect Cluster JMX authentication.
   *
   * @schema KafkaConnectSpecTemplate#jmxSecret
   */
  readonly jmxSecret?: KafkaConnectSpecTemplateJmxSecret;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplate(obj: KafkaConnectSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaConnectSpecTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaConnectSpecTemplatePod(obj.pod),
    'apiService': toJson_KafkaConnectSpecTemplateApiService(obj.apiService),
    'connectContainer': toJson_KafkaConnectSpecTemplateConnectContainer(obj.connectContainer),
    'initContainer': toJson_KafkaConnectSpecTemplateInitContainer(obj.initContainer),
    'podDisruptionBudget': toJson_KafkaConnectSpecTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'serviceAccount': toJson_KafkaConnectSpecTemplateServiceAccount(obj.serviceAccount),
    'clusterRoleBinding': toJson_KafkaConnectSpecTemplateClusterRoleBinding(obj.clusterRoleBinding),
    'buildPod': toJson_KafkaConnectSpecTemplateBuildPod(obj.buildPod),
    'buildContainer': toJson_KafkaConnectSpecTemplateBuildContainer(obj.buildContainer),
    'buildConfig': toJson_KafkaConnectSpecTemplateBuildConfig(obj.buildConfig),
    'buildServiceAccount': toJson_KafkaConnectSpecTemplateBuildServiceAccount(obj.buildServiceAccount),
    'jmxSecret': toJson_KafkaConnectSpecTemplateJmxSecret(obj.jmxSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaConnectSpecExternalConfiguration
 */
export interface KafkaConnectSpecExternalConfiguration {
  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as environment variables.
   *
   * @schema KafkaConnectSpecExternalConfiguration#env
   */
  readonly env?: KafkaConnectSpecExternalConfigurationEnv[];

  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as volumes.
   *
   * @schema KafkaConnectSpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaConnectSpecExternalConfigurationVolumes[];

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfiguration(obj: KafkaConnectSpecExternalConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecExternalConfigurationEnv(y)),
    'volumes': obj.volumes?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how the Connect container image should be built. Optional.
 *
 * @schema KafkaConnectSpecBuild
 */
export interface KafkaConnectSpecBuild {
  /**
   * Configures where should the newly built image be stored. Required.
   *
   * @schema KafkaConnectSpecBuild#output
   */
  readonly output: KafkaConnectSpecBuildOutput;

  /**
   * CPU and memory resources to reserve for the build.
   *
   * @schema KafkaConnectSpecBuild#resources
   */
  readonly resources?: KafkaConnectSpecBuildResources;

  /**
   * List of connector plugins which should be added to the Kafka Connect. Required.
   *
   * @schema KafkaConnectSpecBuild#plugins
   */
  readonly plugins: KafkaConnectSpecBuildPlugins[];

}

/**
 * Converts an object of type 'KafkaConnectSpecBuild' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuild(obj: KafkaConnectSpecBuild | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'output': toJson_KafkaConnectSpecBuildOutput(obj.output),
    'resources': toJson_KafkaConnectSpecBuildResources(obj.resources),
    'plugins': obj.plugins?.map(y => toJson_KafkaConnectSpecBuildPlugins(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaConnectSpecMetricsConfig
 */
export interface KafkaConnectSpecMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaConnectSpecMetricsConfig#type
   */
  readonly type: KafkaConnectSpecMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaConnectSpecMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaConnectSpecMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfig(obj: KafkaConnectSpecMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaConnectSpecMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTlsTrustedCertificates
 */
export interface KafkaConnectSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTlsTrustedCertificates(obj: KafkaConnectSpecTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationAccessToken
 */
export interface KafkaConnectSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationAccessToken(obj: KafkaConnectSpecAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaConnectSpecAuthenticationCertificateAndKey
 */
export interface KafkaConnectSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationCertificateAndKey(obj: KafkaConnectSpecAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaConnectSpecAuthenticationClientSecret
 */
export interface KafkaConnectSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationClientSecret(obj: KafkaConnectSpecAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaConnectSpecAuthenticationPasswordSecret
 */
export interface KafkaConnectSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationPasswordSecret(obj: KafkaConnectSpecAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationRefreshToken
 */
export interface KafkaConnectSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationRefreshToken(obj: KafkaConnectSpecAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaConnectSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationTlsTrustedCertificates(obj: KafkaConnectSpecAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaConnectSpecAuthenticationType
 */
export enum KafkaConnectSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_HYPHEN_SHA_HYPHEN_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaConnectSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJvmOptionsJavaSystemProperties(obj: KafkaConnectSpecJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaConnectSpecJmxOptionsAuthentication
 */
export interface KafkaConnectSpecJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaConnectSpecJmxOptionsAuthentication#type
   */
  readonly type: KafkaConnectSpecJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaConnectSpecJmxOptionsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJmxOptionsAuthentication(obj: KafkaConnectSpecJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaConnectSpecLoggingType
 */
export enum KafkaConnectSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaConnectSpecLoggingValueFrom
 */
export interface KafkaConnectSpecLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaConnectSpecLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLoggingValueFrom(obj: KafkaConnectSpecLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
 *
 * @schema KafkaConnectSpecTracingType
 */
export enum KafkaConnectSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
  /** opentelemetry */
  OPENTELEMETRY = "opentelemetry",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaConnectSpecTemplateDeployment
 */
export interface KafkaConnectSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateDeploymentMetadata;

  /**
   * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
   *
   * @default RollingUpdate`.
   * @schema KafkaConnectSpecTemplateDeployment#deploymentStrategy
   */
  readonly deploymentStrategy?: KafkaConnectSpecTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateDeployment(obj: KafkaConnectSpecTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateDeploymentMetadata(obj.metadata),
    'deploymentStrategy': obj.deploymentStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaConnectSpecTemplatePod
 */
export interface KafkaConnectSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaConnectSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaConnectSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaConnectSpecTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaConnectSpecTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaConnectSpecTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaConnectSpecTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaConnectSpecTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePod(obj: KafkaConnectSpecTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaConnectSpecTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaConnectSpecTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaConnectSpecTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaConnectSpecTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaConnectSpecTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaConnectSpecTemplateApiService
 */
export interface KafkaConnectSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateApiServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateApiService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaConnectSpecTemplateApiServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateApiService#ipFamilies
   */
  readonly ipFamilies?: KafkaConnectSpecTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateApiService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateApiService(obj: KafkaConnectSpecTemplateApiService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateApiServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainer
 */
export interface KafkaConnectSpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateConnectContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainer(obj: KafkaConnectSpecTemplateConnectContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateConnectContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaConnectSpecTemplateInitContainer
 */
export interface KafkaConnectSpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainer(obj: KafkaConnectSpecTemplateInitContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateInitContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateInitContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudget
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodDisruptionBudget(obj: KafkaConnectSpecTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect service account.
 *
 * @schema KafkaConnectSpecTemplateServiceAccount
 */
export interface KafkaConnectSpecTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateServiceAccount(obj: KafkaConnectSpecTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect ClusterRoleBinding.
 *
 * @schema KafkaConnectSpecTemplateClusterRoleBinding
 */
export interface KafkaConnectSpecTemplateClusterRoleBinding {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBinding#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateClusterRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateClusterRoleBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateClusterRoleBinding(obj: KafkaConnectSpecTemplateClusterRoleBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateClusterRoleBindingMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
 *
 * @schema KafkaConnectSpecTemplateBuildPod
 */
export interface KafkaConnectSpecTemplateBuildPod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildPodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectSpecTemplateBuildPodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateBuildPodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectSpecTemplateBuildPod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#affinity
   */
  readonly affinity?: KafkaConnectSpecTemplateBuildPodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTemplateBuildPodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#hostAliases
   */
  readonly hostAliases?: KafkaConnectSpecTemplateBuildPodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPod(obj: KafkaConnectSpecTemplateBuildPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildPodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaConnectSpecTemplateBuildPodImagePullSecrets(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateBuildPodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaConnectSpecTemplateBuildPodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaConnectSpecTemplateBuildPodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
 *
 * @schema KafkaConnectSpecTemplateBuildContainer
 */
export interface KafkaConnectSpecTemplateBuildContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateBuildContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateBuildContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateBuildContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateBuildContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainer(obj: KafkaConnectSpecTemplateBuildContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateBuildContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
 *
 * @schema KafkaConnectSpecTemplateBuildConfig
 */
export interface KafkaConnectSpecTemplateBuildConfig {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaConnectSpecTemplateBuildConfig#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildConfigMetadata;

  /**
   * Container Registry Secret with the credentials for pulling the base image.
   *
   * @schema KafkaConnectSpecTemplateBuildConfig#pullSecret
   */
  readonly pullSecret?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildConfig(obj: KafkaConnectSpecTemplateBuildConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildConfigMetadata(obj.metadata),
    'pullSecret': obj.pullSecret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build service account.
 *
 * @schema KafkaConnectSpecTemplateBuildServiceAccount
 */
export interface KafkaConnectSpecTemplateBuildServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccount#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildServiceAccount(obj: KafkaConnectSpecTemplateBuildServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Kafka Connect Cluster JMX authentication.
 *
 * @schema KafkaConnectSpecTemplateJmxSecret
 */
export interface KafkaConnectSpecTemplateJmxSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateJmxSecret#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateJmxSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateJmxSecret(obj: KafkaConnectSpecTemplateJmxSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateJmxSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationEnv
 */
export interface KafkaConnectSpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaConnectSpecExternalConfigurationEnvValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnv(obj: KafkaConnectSpecExternalConfigurationEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': toJson_KafkaConnectSpecExternalConfigurationEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumes
 */
export interface KafkaConnectSpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaConnectSpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaConnectSpecExternalConfigurationVolumesSecret;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumes(obj: KafkaConnectSpecExternalConfigurationVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMap(obj.configMap),
    'name': obj.name,
    'secret': toJson_KafkaConnectSpecExternalConfigurationVolumesSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures where should the newly built image be stored. Required.
 *
 * @schema KafkaConnectSpecBuildOutput
 */
export interface KafkaConnectSpecBuildOutput {
  /**
   * Configures additional options which will be passed to the Kaniko executor when building the new Connect image. Allowed options are: --customPlatform, --insecure, --insecure-pull, --insecure-registry, --log-format, --log-timestamp, --registry-mirror, --reproducible, --single-snapshot, --skip-tls-verify, --skip-tls-verify-pull, --skip-tls-verify-registry, --verbosity, --snapshotMode, --use-new-run. These options will be used only on Kubernetes where the Kaniko executor is used. They will be ignored on OpenShift. The options are described in the link:https://github.com/GoogleContainerTools/kaniko[Kaniko GitHub repository^]. Changing this field does not trigger new build of the Kafka Connect image.
   *
   * @schema KafkaConnectSpecBuildOutput#additionalKanikoOptions
   */
  readonly additionalKanikoOptions?: string[];

  /**
   * The name of the image which will be built. Required.
   *
   * @schema KafkaConnectSpecBuildOutput#image
   */
  readonly image: string;

  /**
   * Container Registry Secret with the credentials for pushing the newly built image.
   *
   * @schema KafkaConnectSpecBuildOutput#pushSecret
   */
  readonly pushSecret?: string;

  /**
   * Output type. Must be either `docker` for pushing the newly build image to Docker compatible registry or `imagestream` for pushing the image to OpenShift ImageStream. Required.
   *
   * @schema KafkaConnectSpecBuildOutput#type
   */
  readonly type: KafkaConnectSpecBuildOutputType;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildOutput(obj: KafkaConnectSpecBuildOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalKanikoOptions': obj.additionalKanikoOptions?.map(y => y),
    'image': obj.image,
    'pushSecret': obj.pushSecret,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve for the build.
 *
 * @schema KafkaConnectSpecBuildResources
 */
export interface KafkaConnectSpecBuildResources {
  /**
   * @schema KafkaConnectSpecBuildResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectSpecBuildResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildResources(obj: KafkaConnectSpecBuildResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecBuildPlugins
 */
export interface KafkaConnectSpecBuildPlugins {
  /**
   * The unique name of the connector plugin. Will be used to generate the path where the connector artifacts will be stored. The name has to be unique within the KafkaConnect resource. The name has to follow the following pattern: `^[a-z][-_a-z0-9]*[a-z]$`. Required.
   *
   * @schema KafkaConnectSpecBuildPlugins#name
   */
  readonly name: string;

  /**
   * List of artifacts which belong to this connector plugin. Required.
   *
   * @schema KafkaConnectSpecBuildPlugins#artifacts
   */
  readonly artifacts: KafkaConnectSpecBuildPluginsArtifacts[];

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildPlugins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildPlugins(obj: KafkaConnectSpecBuildPlugins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'artifacts': obj.artifacts?.map(y => toJson_KafkaConnectSpecBuildPluginsArtifacts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaConnectSpecMetricsConfigType
 */
export enum KafkaConnectSpecMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaConnectSpecMetricsConfigValueFrom
 */
export interface KafkaConnectSpecMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaConnectSpecMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfigValueFrom(obj: KafkaConnectSpecMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaConnectSpecJmxOptionsAuthenticationType
 */
export enum KafkaConnectSpecJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLoggingValueFromConfigMapKeyRef(obj: KafkaConnectSpecLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateDeploymentMetadata
 */
export interface KafkaConnectSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateDeploymentMetadata(obj: KafkaConnectSpecTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaConnectSpecTemplateDeploymentDeploymentStrategy
 */
export enum KafkaConnectSpecTemplateDeploymentDeploymentStrategy {
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplatePodMetadata
 */
export interface KafkaConnectSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodMetadata(obj: KafkaConnectSpecTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodImagePullSecrets
 */
export interface KafkaConnectSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaConnectSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodImagePullSecrets(obj: KafkaConnectSpecTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectSpecTemplatePodSecurityContext
 */
export interface KafkaConnectSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContext(obj: KafkaConnectSpecTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaConnectSpecTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaConnectSpecTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecTemplatePodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinity(obj: KafkaConnectSpecTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTolerations
 */
export interface KafkaConnectSpecTemplatePodTolerations {
  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTolerations(obj: KafkaConnectSpecTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodHostAliases
 */
export interface KafkaConnectSpecTemplatePodHostAliases {
  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodHostAliases(obj: KafkaConnectSpecTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraints(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateApiServiceMetadata
 */
export interface KafkaConnectSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateApiServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateApiServiceMetadata(obj: KafkaConnectSpecTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaConnectSpecTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaConnectSpecTemplateApiServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaConnectSpecTemplateApiServiceIpFamilies
 */
export enum KafkaConnectSpecTemplateApiServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerEnv
 */
export interface KafkaConnectSpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerEnv(obj: KafkaConnectSpecTemplateConnectContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContext(obj: KafkaConnectSpecTemplateConnectContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerEnv
 */
export interface KafkaConnectSpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerEnv(obj: KafkaConnectSpecTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContext(obj: KafkaConnectSpecTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodDisruptionBudgetMetadata(obj: KafkaConnectSpecTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateServiceAccountMetadata
 */
export interface KafkaConnectSpecTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateServiceAccountMetadata(obj: KafkaConnectSpecTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata
 */
export interface KafkaConnectSpecTemplateClusterRoleBindingMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateClusterRoleBindingMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateClusterRoleBindingMetadata(obj: KafkaConnectSpecTemplateClusterRoleBindingMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateBuildPodMetadata
 */
export interface KafkaConnectSpecTemplateBuildPodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildPodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildPodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodMetadata(obj: KafkaConnectSpecTemplateBuildPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodImagePullSecrets
 */
export interface KafkaConnectSpecTemplateBuildPodImagePullSecrets {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodImagePullSecrets(obj: KafkaConnectSpecTemplateBuildPodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContext
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectSpecTemplateBuildPodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContext(obj: KafkaConnectSpecTemplateBuildPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecTemplateBuildPodAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTolerations
 */
export interface KafkaConnectSpecTemplateBuildPodTolerations {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTolerations(obj: KafkaConnectSpecTemplateBuildPodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodHostAliases
 */
export interface KafkaConnectSpecTemplateBuildPodHostAliases {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodHostAliases(obj: KafkaConnectSpecTemplateBuildPodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerEnv
 */
export interface KafkaConnectSpecTemplateBuildContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateBuildContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateBuildContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerEnv(obj: KafkaConnectSpecTemplateBuildContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContext(obj: KafkaConnectSpecTemplateBuildContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaConnectSpecTemplateBuildConfigMetadata
 */
export interface KafkaConnectSpecTemplateBuildConfigMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildConfigMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildConfigMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildConfigMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildConfigMetadata(obj: KafkaConnectSpecTemplateBuildConfigMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata
 */
export interface KafkaConnectSpecTemplateBuildServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildServiceAccountMetadata(obj: KafkaConnectSpecTemplateBuildServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateJmxSecretMetadata
 */
export interface KafkaConnectSpecTemplateJmxSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateJmxSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateJmxSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateJmxSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateJmxSecretMetadata(obj: KafkaConnectSpecTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFrom {
  /**
   * Reference to a key in a ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFrom(obj: KafkaConnectSpecExternalConfigurationEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMap(obj: KafkaConnectSpecExternalConfigurationVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecret
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesSecret(obj: KafkaConnectSpecExternalConfigurationVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Output type. Must be either `docker` for pushing the newly build image to Docker compatible registry or `imagestream` for pushing the image to OpenShift ImageStream. Required.
 *
 * @schema KafkaConnectSpecBuildOutputType
 */
export enum KafkaConnectSpecBuildOutputType {
  /** docker */
  DOCKER = "docker",
  /** imagestream */
  IMAGESTREAM = "imagestream",
}

/**
 * @schema KafkaConnectSpecBuildPluginsArtifacts
 */
export interface KafkaConnectSpecBuildPluginsArtifacts {
  /**
   * Maven artifact id. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#artifact
   */
  readonly artifact?: string;

  /**
   * Name under which the artifact will be stored.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#fileName
   */
  readonly fileName?: string;

  /**
   * Maven group id. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#group
   */
  readonly group?: string;

  /**
   * By default, connections using TLS are verified to check they are secure. The server certificate used must be valid, trusted, and contain the server name. By setting this option to `true`, all TLS verification is disabled and the artifact will be downloaded, even when the server is considered insecure.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#insecure
   */
  readonly insecure?: boolean;

  /**
   * Maven repository to download the artifact from. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#repository
   */
  readonly repository?: string;

  /**
   * SHA512 checksum of the artifact. Optional. If specified, the checksum will be verified while building the new container. If not specified, the downloaded artifact will not be verified. Not applicable to the `maven` artifact type.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#sha512sum
   */
  readonly sha512Sum?: string;

  /**
   * Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`, `other` and `maven`.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#type
   */
  readonly type: KafkaConnectSpecBuildPluginsArtifactsType;

  /**
   * URL of the artifact which will be downloaded. Strimzi does not do any security scanning of the downloaded artifacts. For security reasons, you should first verify the artifacts manually and configure the checksum verification to make sure the same artifact is used in the automated build. Required for `jar`, `zip`, `tgz` and `other` artifacts. Not applicable to the `maven` artifact type.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#url
   */
  readonly url?: string;

  /**
   * Maven version number. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildPluginsArtifacts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildPluginsArtifacts(obj: KafkaConnectSpecBuildPluginsArtifacts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifact': obj.artifact,
    'fileName': obj.fileName,
    'group': obj.group,
    'insecure': obj.insecure,
    'repository': obj.repository,
    'sha512sum': obj.sha512Sum,
    'type': obj.type,
    'url': obj.url,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef(obj: KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSysctls(obj: KafkaConnectSpecTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinity(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinity(obj: KafkaConnectSpecTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinity(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSysctls {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSysctls(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj: KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef(obj: KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMapItems(obj: KafkaConnectSpecExternalConfigurationVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesSecretItems(obj: KafkaConnectSpecExternalConfigurationVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`, `other` and `maven`.
 *
 * @schema KafkaConnectSpecBuildPluginsArtifactsType
 */
export enum KafkaConnectSpecBuildPluginsArtifactsType {
  /** jar */
  JAR = "jar",
  /** tgz */
  TGZ = "tgz",
  /** zip */
  ZIP = "zip",
  /** maven */
  MAVEN = "maven",
  /** other */
  OTHER = "other",
}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaConnector
 */
export class KafkaConnector extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnector"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaConnector',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnector".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectorProps = {}): any {
    return {
      ...KafkaConnector.GVK,
      ...toJson_KafkaConnectorProps(props),
    };
  }

  /**
   * Defines a "KafkaConnector" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectorProps = {}) {
    super(scope, id, {
      ...KafkaConnector.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaConnector.GVK,
      ...toJson_KafkaConnectorProps(resolved),
    };
  }
}

/**
 * @schema KafkaConnector
 */
export interface KafkaConnectorProps {
  /**
   * @schema KafkaConnector#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka Connector.
   *
   * @schema KafkaConnector#spec
   */
  readonly spec?: KafkaConnectorSpec;

}

/**
 * Converts an object of type 'KafkaConnectorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectorProps(obj: KafkaConnectorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaConnectorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka Connector.
 *
 * @schema KafkaConnectorSpec
 */
export interface KafkaConnectorSpec {
  /**
   * The Class for the Kafka Connector.
   *
   * @schema KafkaConnectorSpec#class
   */
  readonly class?: string;

  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaConnectorSpec#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaConnectorSpec#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaConnectorSpec#pause
   */
  readonly pause?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectorSpec(obj: KafkaConnectorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'tasksMax': obj.tasksMax,
    'config': obj.config,
    'pause': obj.pause,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaMirrorMaker
 */
export class KafkaMirrorMaker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaMirrorMaker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaMirrorMaker',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaMirrorMaker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaMirrorMakerProps = {}): any {
    return {
      ...KafkaMirrorMaker.GVK,
      ...toJson_KafkaMirrorMakerProps(props),
    };
  }

  /**
   * Defines a "KafkaMirrorMaker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaMirrorMakerProps = {}) {
    super(scope, id, {
      ...KafkaMirrorMaker.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaMirrorMaker.GVK,
      ...toJson_KafkaMirrorMakerProps(resolved),
    };
  }
}

/**
 * @schema KafkaMirrorMaker
 */
export interface KafkaMirrorMakerProps {
  /**
   * @schema KafkaMirrorMaker#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of Kafka MirrorMaker.
   *
   * @schema KafkaMirrorMaker#spec
   */
  readonly spec?: KafkaMirrorMakerSpec;

}

/**
 * Converts an object of type 'KafkaMirrorMakerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerProps(obj: KafkaMirrorMakerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaMirrorMakerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of Kafka MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpec
 */
export interface KafkaMirrorMakerSpec {
  /**
   * The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaMirrorMakerSpec#version
   */
  readonly version?: string;

  /**
   * The number of pods in the `Deployment`.
   *
   * @schema KafkaMirrorMakerSpec#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaMirrorMakerSpec#image
   */
  readonly image?: string;

  /**
   * Configuration of source cluster.
   *
   * @schema KafkaMirrorMakerSpec#consumer
   */
  readonly consumer: KafkaMirrorMakerSpecConsumer;

  /**
   * Configuration of target cluster.
   *
   * @schema KafkaMirrorMakerSpec#producer
   */
  readonly producer: KafkaMirrorMakerSpecProducer;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaMirrorMakerSpec#resources
   */
  readonly resources?: KafkaMirrorMakerSpecResources;

  /**
   * List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the expression `A\|B`. Or, as a special case, you can mirror all topics using the regular expression `*`. You can also specify multiple regular expressions separated by commas.
   *
   * @schema KafkaMirrorMakerSpec#whitelist
   */
  readonly whitelist?: string;

  /**
   * List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the expression `A\|B`. Or, as a special case, you can mirror all topics using the regular expression `*`. You can also specify multiple regular expressions separated by commas.
   *
   * @schema KafkaMirrorMakerSpec#include
   */
  readonly include?: string;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaMirrorMakerSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaMirrorMakerSpecJvmOptions;

  /**
   * Logging configuration for MirrorMaker.
   *
   * @schema KafkaMirrorMakerSpec#logging
   */
  readonly logging?: KafkaMirrorMakerSpecLogging;

  /**
   * Metrics configuration.
   *
   * @schema KafkaMirrorMakerSpec#metricsConfig
   */
  readonly metricsConfig?: KafkaMirrorMakerSpecMetricsConfig;

  /**
   * The configuration of tracing in Kafka MirrorMaker.
   *
   * @schema KafkaMirrorMakerSpec#tracing
   */
  readonly tracing?: KafkaMirrorMakerSpecTracing;

  /**
   * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
   *
   * @schema KafkaMirrorMakerSpec#template
   */
  readonly template?: KafkaMirrorMakerSpecTemplate;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaMirrorMakerSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaMirrorMakerSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaMirrorMakerSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaMirrorMakerSpecReadinessProbe;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpec(obj: KafkaMirrorMakerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'replicas': obj.replicas,
    'image': obj.image,
    'consumer': toJson_KafkaMirrorMakerSpecConsumer(obj.consumer),
    'producer': toJson_KafkaMirrorMakerSpecProducer(obj.producer),
    'resources': toJson_KafkaMirrorMakerSpecResources(obj.resources),
    'whitelist': obj.whitelist,
    'include': obj.include,
    'jvmOptions': toJson_KafkaMirrorMakerSpecJvmOptions(obj.jvmOptions),
    'logging': toJson_KafkaMirrorMakerSpecLogging(obj.logging),
    'metricsConfig': toJson_KafkaMirrorMakerSpecMetricsConfig(obj.metricsConfig),
    'tracing': toJson_KafkaMirrorMakerSpecTracing(obj.tracing),
    'template': toJson_KafkaMirrorMakerSpecTemplate(obj.template),
    'livenessProbe': toJson_KafkaMirrorMakerSpecLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaMirrorMakerSpecReadinessProbe(obj.readinessProbe),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of source cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumer
 */
export interface KafkaMirrorMakerSpecConsumer {
  /**
   * Specifies the number of consumer stream threads to create.
   *
   * @schema KafkaMirrorMakerSpecConsumer#numStreams
   */
  readonly numStreams?: number;

  /**
   * Specifies the offset auto-commit interval in ms. Default value is 60000.
   *
   * @schema KafkaMirrorMakerSpecConsumer#offsetCommitInterval
   */
  readonly offsetCommitInterval?: number;

  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * A unique string that identifies the consumer group this consumer belongs to.
   *
   * @schema KafkaMirrorMakerSpecConsumer#groupId
   */
  readonly groupId: string;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#authentication
   */
  readonly authentication?: KafkaMirrorMakerSpecConsumerAuthentication;

  /**
   * The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMakerSpecConsumer#config
   */
  readonly config?: any;

  /**
   * TLS configuration for connecting MirrorMaker to the cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#tls
   */
  readonly tls?: KafkaMirrorMakerSpecConsumerTls;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumer(obj: KafkaMirrorMakerSpecConsumer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numStreams': obj.numStreams,
    'offsetCommitInterval': obj.offsetCommitInterval,
    'bootstrapServers': obj.bootstrapServers,
    'groupId': obj.groupId,
    'authentication': toJson_KafkaMirrorMakerSpecConsumerAuthentication(obj.authentication),
    'config': obj.config,
    'tls': toJson_KafkaMirrorMakerSpecConsumerTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of target cluster.
 *
 * @schema KafkaMirrorMakerSpecProducer
 */
export interface KafkaMirrorMakerSpecProducer {
  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
   *
   * @schema KafkaMirrorMakerSpecProducer#abortOnSendFailure
   */
  readonly abortOnSendFailure?: boolean;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#authentication
   */
  readonly authentication?: KafkaMirrorMakerSpecProducerAuthentication;

  /**
   * The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMakerSpecProducer#config
   */
  readonly config?: any;

  /**
   * TLS configuration for connecting MirrorMaker to the cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#tls
   */
  readonly tls?: KafkaMirrorMakerSpecProducerTls;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducer(obj: KafkaMirrorMakerSpecProducer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootstrapServers': obj.bootstrapServers,
    'abortOnSendFailure': obj.abortOnSendFailure,
    'authentication': toJson_KafkaMirrorMakerSpecProducerAuthentication(obj.authentication),
    'config': obj.config,
    'tls': toJson_KafkaMirrorMakerSpecProducerTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaMirrorMakerSpecResources
 */
export interface KafkaMirrorMakerSpecResources {
  /**
   * @schema KafkaMirrorMakerSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaMirrorMakerSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecResources(obj: KafkaMirrorMakerSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaMirrorMakerSpecJvmOptions
 */
export interface KafkaMirrorMakerSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecJvmOptions(obj: KafkaMirrorMakerSpecJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpecLogging
 */
export interface KafkaMirrorMakerSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaMirrorMakerSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaMirrorMakerSpecLogging#type
   */
  readonly type: KafkaMirrorMakerSpecLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaMirrorMakerSpecLogging#valueFrom
   */
  readonly valueFrom?: KafkaMirrorMakerSpecLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecLogging(obj: KafkaMirrorMakerSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaMirrorMakerSpecLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaMirrorMakerSpecMetricsConfig
 */
export interface KafkaMirrorMakerSpecMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaMirrorMakerSpecMetricsConfig#type
   */
  readonly type: KafkaMirrorMakerSpecMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaMirrorMakerSpecMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaMirrorMakerSpecMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecMetricsConfig(obj: KafkaMirrorMakerSpecMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaMirrorMakerSpecMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of tracing in Kafka MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpecTracing
 */
export interface KafkaMirrorMakerSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
   *
   * @schema KafkaMirrorMakerSpecTracing#type
   */
  readonly type: KafkaMirrorMakerSpecTracingType;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTracing(obj: KafkaMirrorMakerSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaMirrorMakerSpecTemplate
 */
export interface KafkaMirrorMakerSpecTemplate {
  /**
   * Template for Kafka MirrorMaker `Deployment`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#deployment
   */
  readonly deployment?: KafkaMirrorMakerSpecTemplateDeployment;

  /**
   * Template for Kafka MirrorMaker `Pods`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#pod
   */
  readonly pod?: KafkaMirrorMakerSpecTemplatePod;

  /**
   * Template for Kafka MirrorMaker `PodDisruptionBudget`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaMirrorMakerSpecTemplatePodDisruptionBudget;

  /**
   * Template for Kafka MirrorMaker container.
   *
   * @schema KafkaMirrorMakerSpecTemplate#mirrorMakerContainer
   */
  readonly mirrorMakerContainer?: KafkaMirrorMakerSpecTemplateMirrorMakerContainer;

  /**
   * Template for the Kafka MirrorMaker service account.
   *
   * @schema KafkaMirrorMakerSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaMirrorMakerSpecTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplate(obj: KafkaMirrorMakerSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaMirrorMakerSpecTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaMirrorMakerSpecTemplatePod(obj.pod),
    'podDisruptionBudget': toJson_KafkaMirrorMakerSpecTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'mirrorMakerContainer': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainer(obj.mirrorMakerContainer),
    'serviceAccount': toJson_KafkaMirrorMakerSpecTemplateServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaMirrorMakerSpecLivenessProbe
 */
export interface KafkaMirrorMakerSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaMirrorMakerSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecLivenessProbe(obj: KafkaMirrorMakerSpecLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaMirrorMakerSpecReadinessProbe
 */
export interface KafkaMirrorMakerSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaMirrorMakerSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecReadinessProbe(obj: KafkaMirrorMakerSpecReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthentication
 */
export interface KafkaMirrorMakerSpecConsumerAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMakerSpecConsumerAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMakerSpecConsumerAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#type
   */
  readonly type: KafkaMirrorMakerSpecConsumerAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthentication(obj: KafkaMirrorMakerSpecConsumerAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaMirrorMakerSpecConsumerAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaMirrorMakerSpecConsumerAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for connecting MirrorMaker to the cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumerTls
 */
export interface KafkaMirrorMakerSpecConsumerTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMakerSpecConsumerTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMakerSpecConsumerTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerTls(obj: KafkaMirrorMakerSpecConsumerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaMirrorMakerSpecConsumerTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthentication
 */
export interface KafkaMirrorMakerSpecProducerAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMakerSpecProducerAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMakerSpecProducerAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMakerSpecProducerAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMakerSpecProducerAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#type
   */
  readonly type: KafkaMirrorMakerSpecProducerAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthentication(obj: KafkaMirrorMakerSpecProducerAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaMirrorMakerSpecProducerAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaMirrorMakerSpecProducerAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaMirrorMakerSpecProducerAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for connecting MirrorMaker to the cluster.
 *
 * @schema KafkaMirrorMakerSpecProducerTls
 */
export interface KafkaMirrorMakerSpecProducerTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMakerSpecProducerTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMakerSpecProducerTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerTls(obj: KafkaMirrorMakerSpecProducerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaMirrorMakerSpecProducerTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties(obj: KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaMirrorMakerSpecLoggingType
 */
export enum KafkaMirrorMakerSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaMirrorMakerSpecLoggingValueFrom
 */
export interface KafkaMirrorMakerSpecLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaMirrorMakerSpecLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecLoggingValueFrom(obj: KafkaMirrorMakerSpecLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaMirrorMakerSpecMetricsConfigType
 */
export enum KafkaMirrorMakerSpecMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaMirrorMakerSpecMetricsConfigValueFrom
 */
export interface KafkaMirrorMakerSpecMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaMirrorMakerSpecMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecMetricsConfigValueFrom(obj: KafkaMirrorMakerSpecMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
 *
 * @schema KafkaMirrorMakerSpecTracingType
 */
export enum KafkaMirrorMakerSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
  /** opentelemetry */
  OPENTELEMETRY = "opentelemetry",
}

/**
 * Template for Kafka MirrorMaker `Deployment`.
 *
 * @schema KafkaMirrorMakerSpecTemplateDeployment
 */
export interface KafkaMirrorMakerSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplateDeploymentMetadata;

  /**
   * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
   *
   * @default RollingUpdate`.
   * @schema KafkaMirrorMakerSpecTemplateDeployment#deploymentStrategy
   */
  readonly deploymentStrategy?: KafkaMirrorMakerSpecTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateDeployment(obj: KafkaMirrorMakerSpecTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMakerSpecTemplateDeploymentMetadata(obj.metadata),
    'deploymentStrategy': obj.deploymentStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka MirrorMaker `Pods`.
 *
 * @schema KafkaMirrorMakerSpecTemplatePod
 */
export interface KafkaMirrorMakerSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaMirrorMakerSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaMirrorMakerSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaMirrorMakerSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaMirrorMakerSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaMirrorMakerSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaMirrorMakerSpecTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePod(obj: KafkaMirrorMakerSpecTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMakerSpecTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaMirrorMakerSpecTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaMirrorMakerSpecTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka MirrorMaker `PodDisruptionBudget`.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget
 */
export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodDisruptionBudget(obj: KafkaMirrorMakerSpecTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka MirrorMaker container.
 *
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer#env
   */
  readonly env?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainer(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv(y)),
    'securityContext': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka MirrorMaker service account.
 *
 * @schema KafkaMirrorMakerSpecTemplateServiceAccount
 */
export interface KafkaMirrorMakerSpecTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMakerSpecTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateServiceAccount(obj: KafkaMirrorMakerSpecTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMakerSpecTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationAccessToken(obj: KafkaMirrorMakerSpecConsumerAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey(obj: KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationClientSecret(obj: KafkaMirrorMakerSpecConsumerAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret(obj: KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken(obj: KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates(obj: KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationType
 */
export enum KafkaMirrorMakerSpecConsumerAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_HYPHEN_SHA_HYPHEN_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecConsumerTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecConsumerTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecConsumerTlsTrustedCertificates(obj: KafkaMirrorMakerSpecConsumerTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationAccessToken(obj: KafkaMirrorMakerSpecProducerAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey(obj: KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationClientSecret(obj: KafkaMirrorMakerSpecProducerAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret(obj: KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationRefreshToken(obj: KafkaMirrorMakerSpecProducerAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates(obj: KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationType
 */
export enum KafkaMirrorMakerSpecProducerAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_HYPHEN_SHA_HYPHEN_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecProducerTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecProducerTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecProducerTlsTrustedCertificates(obj: KafkaMirrorMakerSpecProducerTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef(obj: KafkaMirrorMakerSpecLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef(obj: KafkaMirrorMakerSpecMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata
 */
export interface KafkaMirrorMakerSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateDeploymentMetadata(obj: KafkaMirrorMakerSpecTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaMirrorMakerSpecTemplateDeploymentDeploymentStrategy
 */
export enum KafkaMirrorMakerSpecTemplateDeploymentDeploymentStrategy {
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodMetadata
 */
export interface KafkaMirrorMakerSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodMetadata(obj: KafkaMirrorMakerSpecTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodImagePullSecrets
 */
export interface KafkaMirrorMakerSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodImagePullSecrets(obj: KafkaMirrorMakerSpecTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodSecurityContext(obj: KafkaMirrorMakerSpecTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinity(obj: KafkaMirrorMakerSpecTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodTolerations
 */
export interface KafkaMirrorMakerSpecTemplatePodTolerations {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodTolerations(obj: KafkaMirrorMakerSpecTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodHostAliases
 */
export interface KafkaMirrorMakerSpecTemplatePodHostAliases {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodHostAliases(obj: KafkaMirrorMakerSpecTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints
 */
export interface KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints(obj: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata(obj: KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMakerSpecTemplateServiceAccountMetadata
 */
export interface KafkaMirrorMakerSpecTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateServiceAccountMetadata(obj: KafkaMirrorMakerSpecTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions(obj: KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile(obj: KafkaMirrorMakerSpecTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls(obj: KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions(obj: KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions(obj: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaMirrorMaker2
 */
export class KafkaMirrorMaker2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaMirrorMaker2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaMirrorMaker2',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaMirrorMaker2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaMirrorMaker2Props = {}): any {
    return {
      ...KafkaMirrorMaker2.GVK,
      ...toJson_KafkaMirrorMaker2Props(props),
    };
  }

  /**
   * Defines a "KafkaMirrorMaker2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaMirrorMaker2Props = {}) {
    super(scope, id, {
      ...KafkaMirrorMaker2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaMirrorMaker2.GVK,
      ...toJson_KafkaMirrorMaker2Props(resolved),
    };
  }
}

/**
 * @schema KafkaMirrorMaker2
 */
export interface KafkaMirrorMaker2Props {
  /**
   * @schema KafkaMirrorMaker2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka MirrorMaker 2.0 cluster.
   *
   * @schema KafkaMirrorMaker2#spec
   */
  readonly spec?: KafkaMirrorMaker2Spec;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2Props(obj: KafkaMirrorMaker2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaMirrorMaker2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka MirrorMaker 2.0 cluster.
 *
 * @schema KafkaMirrorMaker2Spec
 */
export interface KafkaMirrorMaker2Spec {
  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaMirrorMaker2Spec#version
   */
  readonly version?: string;

  /**
   * The number of pods in the Kafka Connect group.
   *
   * @schema KafkaMirrorMaker2Spec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaMirrorMaker2Spec#image
   */
  readonly image?: string;

  /**
   * The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2Spec#connectCluster
   */
  readonly connectCluster: string;

  /**
   * Kafka clusters for mirroring.
   *
   * @schema KafkaMirrorMaker2Spec#clusters
   */
  readonly clusters?: KafkaMirrorMaker2SpecClusters[];

  /**
   * Configuration of the MirrorMaker 2.0 connectors.
   *
   * @schema KafkaMirrorMaker2Spec#mirrors
   */
  readonly mirrors?: KafkaMirrorMaker2SpecMirrors[];

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaMirrorMaker2Spec#resources
   */
  readonly resources?: KafkaMirrorMaker2SpecResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaMirrorMaker2Spec#livenessProbe
   */
  readonly livenessProbe?: KafkaMirrorMaker2SpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaMirrorMaker2Spec#readinessProbe
   */
  readonly readinessProbe?: KafkaMirrorMaker2SpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaMirrorMaker2Spec#jvmOptions
   */
  readonly jvmOptions?: KafkaMirrorMaker2SpecJvmOptions;

  /**
   * JMX Options.
   *
   * @schema KafkaMirrorMaker2Spec#jmxOptions
   */
  readonly jmxOptions?: KafkaMirrorMaker2SpecJmxOptions;

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaMirrorMaker2Spec#logging
   */
  readonly logging?: KafkaMirrorMaker2SpecLogging;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaMirrorMaker2Spec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * Configuration of the node label which will be used as the `client.rack` consumer configuration.
   *
   * @schema KafkaMirrorMaker2Spec#rack
   */
  readonly rack?: KafkaMirrorMaker2SpecRack;

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaMirrorMaker2Spec#tracing
   */
  readonly tracing?: KafkaMirrorMaker2SpecTracing;

  /**
   * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaMirrorMaker2Spec#template
   */
  readonly template?: KafkaMirrorMaker2SpecTemplate;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaMirrorMaker2Spec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaMirrorMaker2SpecExternalConfiguration;

  /**
   * Metrics configuration.
   *
   * @schema KafkaMirrorMaker2Spec#metricsConfig
   */
  readonly metricsConfig?: KafkaMirrorMaker2SpecMetricsConfig;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2Spec(obj: KafkaMirrorMaker2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'replicas': obj.replicas,
    'image': obj.image,
    'connectCluster': obj.connectCluster,
    'clusters': obj.clusters?.map(y => toJson_KafkaMirrorMaker2SpecClusters(y)),
    'mirrors': obj.mirrors?.map(y => toJson_KafkaMirrorMaker2SpecMirrors(y)),
    'resources': toJson_KafkaMirrorMaker2SpecResources(obj.resources),
    'livenessProbe': toJson_KafkaMirrorMaker2SpecLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaMirrorMaker2SpecReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaMirrorMaker2SpecJvmOptions(obj.jvmOptions),
    'jmxOptions': toJson_KafkaMirrorMaker2SpecJmxOptions(obj.jmxOptions),
    'logging': toJson_KafkaMirrorMaker2SpecLogging(obj.logging),
    'clientRackInitImage': obj.clientRackInitImage,
    'rack': toJson_KafkaMirrorMaker2SpecRack(obj.rack),
    'tracing': toJson_KafkaMirrorMaker2SpecTracing(obj.tracing),
    'template': toJson_KafkaMirrorMaker2SpecTemplate(obj.template),
    'externalConfiguration': toJson_KafkaMirrorMaker2SpecExternalConfiguration(obj.externalConfiguration),
    'metricsConfig': toJson_KafkaMirrorMaker2SpecMetricsConfig(obj.metricsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecClusters
 */
export interface KafkaMirrorMaker2SpecClusters {
  /**
   * Alias used to reference the Kafka cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#alias
   */
  readonly alias: string;

  /**
   * A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#tls
   */
  readonly tls?: KafkaMirrorMaker2SpecClustersTls;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#authentication
   */
  readonly authentication?: KafkaMirrorMaker2SpecClustersAuthentication;

  /**
   * The MirrorMaker 2.0 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMaker2SpecClusters#config
   */
  readonly config?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClusters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClusters(obj: KafkaMirrorMaker2SpecClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'bootstrapServers': obj.bootstrapServers,
    'tls': toJson_KafkaMirrorMaker2SpecClustersTls(obj.tls),
    'authentication': toJson_KafkaMirrorMaker2SpecClustersAuthentication(obj.authentication),
    'config': obj.config,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecMirrors
 */
export interface KafkaMirrorMaker2SpecMirrors {
  /**
   * The alias of the source cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#sourceCluster
   */
  readonly sourceCluster: string;

  /**
   * The alias of the target cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#targetCluster
   */
  readonly targetCluster: string;

  /**
   * The specification of the Kafka MirrorMaker 2.0 source connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#sourceConnector
   */
  readonly sourceConnector?: KafkaMirrorMaker2SpecMirrorsSourceConnector;

  /**
   * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#heartbeatConnector
   */
  readonly heartbeatConnector?: KafkaMirrorMaker2SpecMirrorsHeartbeatConnector;

  /**
   * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#checkpointConnector
   */
  readonly checkpointConnector?: KafkaMirrorMaker2SpecMirrorsCheckpointConnector;

  /**
   * A regular expression matching the topics to be mirrored, for example, "topic1\|topic2\|topic3". Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#topicsPattern
   */
  readonly topicsPattern?: string;

  /**
   * A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#topicsBlacklistPattern
   */
  readonly topicsBlacklistPattern?: string;

  /**
   * A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#topicsExcludePattern
   */
  readonly topicsExcludePattern?: string;

  /**
   * A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#groupsPattern
   */
  readonly groupsPattern?: string;

  /**
   * A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#groupsBlacklistPattern
   */
  readonly groupsBlacklistPattern?: string;

  /**
   * A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#groupsExcludePattern
   */
  readonly groupsExcludePattern?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMirrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMirrors(obj: KafkaMirrorMaker2SpecMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sourceCluster': obj.sourceCluster,
    'targetCluster': obj.targetCluster,
    'sourceConnector': toJson_KafkaMirrorMaker2SpecMirrorsSourceConnector(obj.sourceConnector),
    'heartbeatConnector': toJson_KafkaMirrorMaker2SpecMirrorsHeartbeatConnector(obj.heartbeatConnector),
    'checkpointConnector': toJson_KafkaMirrorMaker2SpecMirrorsCheckpointConnector(obj.checkpointConnector),
    'topicsPattern': obj.topicsPattern,
    'topicsBlacklistPattern': obj.topicsBlacklistPattern,
    'topicsExcludePattern': obj.topicsExcludePattern,
    'groupsPattern': obj.groupsPattern,
    'groupsBlacklistPattern': obj.groupsBlacklistPattern,
    'groupsExcludePattern': obj.groupsExcludePattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaMirrorMaker2SpecResources
 */
export interface KafkaMirrorMaker2SpecResources {
  /**
   * @schema KafkaMirrorMaker2SpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaMirrorMaker2SpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecResources(obj: KafkaMirrorMaker2SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaMirrorMaker2SpecLivenessProbe
 */
export interface KafkaMirrorMaker2SpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecLivenessProbe(obj: KafkaMirrorMaker2SpecLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaMirrorMaker2SpecReadinessProbe
 */
export interface KafkaMirrorMaker2SpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecReadinessProbe(obj: KafkaMirrorMaker2SpecReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaMirrorMaker2SpecJvmOptions
 */
export interface KafkaMirrorMaker2SpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecJvmOptions(obj: KafkaMirrorMaker2SpecJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JMX Options.
 *
 * @schema KafkaMirrorMaker2SpecJmxOptions
 */
export interface KafkaMirrorMaker2SpecJmxOptions {
  /**
   * Authentication configuration for connecting to the JMX port.
   *
   * @schema KafkaMirrorMaker2SpecJmxOptions#authentication
   */
  readonly authentication?: KafkaMirrorMaker2SpecJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecJmxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecJmxOptions(obj: KafkaMirrorMaker2SpecJmxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaMirrorMaker2SpecJmxOptionsAuthentication(obj.authentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaMirrorMaker2SpecLogging
 */
export interface KafkaMirrorMaker2SpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaMirrorMaker2SpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaMirrorMaker2SpecLogging#type
   */
  readonly type: KafkaMirrorMaker2SpecLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaMirrorMaker2SpecLogging#valueFrom
   */
  readonly valueFrom?: KafkaMirrorMaker2SpecLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecLogging(obj: KafkaMirrorMaker2SpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaMirrorMaker2SpecLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the node label which will be used as the `client.rack` consumer configuration.
 *
 * @schema KafkaMirrorMaker2SpecRack
 */
export interface KafkaMirrorMaker2SpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.0.
   *
   * @schema KafkaMirrorMaker2SpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecRack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecRack(obj: KafkaMirrorMaker2SpecRack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaMirrorMaker2SpecTracing
 */
export interface KafkaMirrorMaker2SpecTracing {
  /**
   * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
   *
   * @schema KafkaMirrorMaker2SpecTracing#type
   */
  readonly type: KafkaMirrorMaker2SpecTracingType;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTracing(obj: KafkaMirrorMaker2SpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaMirrorMaker2SpecTemplate
 */
export interface KafkaMirrorMaker2SpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#deployment
   */
  readonly deployment?: KafkaMirrorMaker2SpecTemplateDeployment;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#pod
   */
  readonly pod?: KafkaMirrorMaker2SpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#apiService
   */
  readonly apiService?: KafkaMirrorMaker2SpecTemplateApiService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaMirrorMaker2SpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#initContainer
   */
  readonly initContainer?: KafkaMirrorMaker2SpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaMirrorMaker2SpecTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka Connect service account.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaMirrorMaker2SpecTemplateServiceAccount;

  /**
   * Template for the Kafka Connect ClusterRoleBinding.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#clusterRoleBinding
   */
  readonly clusterRoleBinding?: KafkaMirrorMaker2SpecTemplateClusterRoleBinding;

  /**
   * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#buildPod
   */
  readonly buildPod?: KafkaMirrorMaker2SpecTemplateBuildPod;

  /**
   * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#buildContainer
   */
  readonly buildContainer?: KafkaMirrorMaker2SpecTemplateBuildContainer;

  /**
   * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#buildConfig
   */
  readonly buildConfig?: KafkaMirrorMaker2SpecTemplateBuildConfig;

  /**
   * Template for the Kafka Connect Build service account.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#buildServiceAccount
   */
  readonly buildServiceAccount?: KafkaMirrorMaker2SpecTemplateBuildServiceAccount;

  /**
   * Template for Secret of the Kafka Connect Cluster JMX authentication.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#jmxSecret
   */
  readonly jmxSecret?: KafkaMirrorMaker2SpecTemplateJmxSecret;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplate(obj: KafkaMirrorMaker2SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaMirrorMaker2SpecTemplateDeployment(obj.deployment),
    'pod': toJson_KafkaMirrorMaker2SpecTemplatePod(obj.pod),
    'apiService': toJson_KafkaMirrorMaker2SpecTemplateApiService(obj.apiService),
    'connectContainer': toJson_KafkaMirrorMaker2SpecTemplateConnectContainer(obj.connectContainer),
    'initContainer': toJson_KafkaMirrorMaker2SpecTemplateInitContainer(obj.initContainer),
    'podDisruptionBudget': toJson_KafkaMirrorMaker2SpecTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'serviceAccount': toJson_KafkaMirrorMaker2SpecTemplateServiceAccount(obj.serviceAccount),
    'clusterRoleBinding': toJson_KafkaMirrorMaker2SpecTemplateClusterRoleBinding(obj.clusterRoleBinding),
    'buildPod': toJson_KafkaMirrorMaker2SpecTemplateBuildPod(obj.buildPod),
    'buildContainer': toJson_KafkaMirrorMaker2SpecTemplateBuildContainer(obj.buildContainer),
    'buildConfig': toJson_KafkaMirrorMaker2SpecTemplateBuildConfig(obj.buildConfig),
    'buildServiceAccount': toJson_KafkaMirrorMaker2SpecTemplateBuildServiceAccount(obj.buildServiceAccount),
    'jmxSecret': toJson_KafkaMirrorMaker2SpecTemplateJmxSecret(obj.jmxSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfiguration
 */
export interface KafkaMirrorMaker2SpecExternalConfiguration {
  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as environment variables.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfiguration#env
   */
  readonly env?: KafkaMirrorMaker2SpecExternalConfigurationEnv[];

  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as volumes.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaMirrorMaker2SpecExternalConfigurationVolumes[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfiguration(obj: KafkaMirrorMaker2SpecExternalConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaMirrorMaker2SpecExternalConfigurationEnv(y)),
    'volumes': obj.volumes?.map(y => toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaMirrorMaker2SpecMetricsConfig
 */
export interface KafkaMirrorMaker2SpecMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaMirrorMaker2SpecMetricsConfig#type
   */
  readonly type: KafkaMirrorMaker2SpecMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaMirrorMaker2SpecMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaMirrorMaker2SpecMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMetricsConfig(obj: KafkaMirrorMaker2SpecMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaMirrorMaker2SpecMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
 *
 * @schema KafkaMirrorMaker2SpecClustersTls
 */
export interface KafkaMirrorMaker2SpecClustersTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMaker2SpecClustersTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMaker2SpecClustersTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersTls(obj: KafkaMirrorMaker2SpecClustersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaMirrorMaker2SpecClustersTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthentication
 */
export interface KafkaMirrorMaker2SpecClustersAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMaker2SpecClustersAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMaker2SpecClustersAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#type
   */
  readonly type: KafkaMirrorMaker2SpecClustersAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthentication(obj: KafkaMirrorMaker2SpecClustersAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaMirrorMaker2SpecClustersAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaMirrorMaker2SpecClustersAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka MirrorMaker 2.0 source connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsSourceConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMirrorsSourceConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMirrorsSourceConnector(obj: KafkaMirrorMaker2SpecMirrorsSourceConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tasksMax': obj.tasksMax,
    'config': obj.config,
    'pause': obj.pause,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsHeartbeatConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMirrorsHeartbeatConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMirrorsHeartbeatConnector(obj: KafkaMirrorMaker2SpecMirrorsHeartbeatConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tasksMax': obj.tasksMax,
    'config': obj.config,
    'pause': obj.pause,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsCheckpointConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMirrorsCheckpointConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMirrorsCheckpointConnector(obj: KafkaMirrorMaker2SpecMirrorsCheckpointConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tasksMax': obj.tasksMax,
    'config': obj.config,
    'pause': obj.pause,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties
 */
export interface KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties(obj: KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaMirrorMaker2SpecJmxOptionsAuthentication
 */
export interface KafkaMirrorMaker2SpecJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaMirrorMaker2SpecJmxOptionsAuthentication#type
   */
  readonly type: KafkaMirrorMaker2SpecJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecJmxOptionsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecJmxOptionsAuthentication(obj: KafkaMirrorMaker2SpecJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaMirrorMaker2SpecLoggingType
 */
export enum KafkaMirrorMaker2SpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaMirrorMaker2SpecLoggingValueFrom
 */
export interface KafkaMirrorMaker2SpecLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaMirrorMaker2SpecLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecLoggingValueFrom(obj: KafkaMirrorMaker2SpecLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
 *
 * @schema KafkaMirrorMaker2SpecTracingType
 */
export enum KafkaMirrorMaker2SpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
  /** opentelemetry */
  OPENTELEMETRY = "opentelemetry",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaMirrorMaker2SpecTemplateDeployment
 */
export interface KafkaMirrorMaker2SpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateDeploymentMetadata;

  /**
   * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
   *
   * @default RollingUpdate`.
   * @schema KafkaMirrorMaker2SpecTemplateDeployment#deploymentStrategy
   */
  readonly deploymentStrategy?: KafkaMirrorMaker2SpecTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateDeployment(obj: KafkaMirrorMaker2SpecTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateDeploymentMetadata(obj.metadata),
    'deploymentStrategy': obj.deploymentStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePod
 */
export interface KafkaMirrorMaker2SpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaMirrorMaker2SpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaMirrorMaker2SpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#affinity
   */
  readonly affinity?: KafkaMirrorMaker2SpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaMirrorMaker2SpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaMirrorMaker2SpecTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePod(obj: KafkaMirrorMaker2SpecTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaMirrorMaker2SpecTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaMirrorMaker2SpecTemplateApiService
 */
export interface KafkaMirrorMaker2SpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateApiServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaMirrorMaker2SpecTemplateApiServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiService#ipFamilies
   */
  readonly ipFamilies?: KafkaMirrorMaker2SpecTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateApiService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateApiService(obj: KafkaMirrorMaker2SpecTemplateApiService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateApiServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainer
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainer#env
   */
  readonly env?: KafkaMirrorMaker2SpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainer(obj: KafkaMirrorMaker2SpecTemplateConnectContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaMirrorMaker2SpecTemplateConnectContainerEnv(y)),
    'securityContext': toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateInitContainer
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainer#env
   */
  readonly env?: KafkaMirrorMaker2SpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainer(obj: KafkaMirrorMaker2SpecTemplateInitContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaMirrorMaker2SpecTemplateInitContainerEnv(y)),
    'securityContext': toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget
 */
export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodDisruptionBudget(obj: KafkaMirrorMaker2SpecTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect service account.
 *
 * @schema KafkaMirrorMaker2SpecTemplateServiceAccount
 */
export interface KafkaMirrorMaker2SpecTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateServiceAccount(obj: KafkaMirrorMaker2SpecTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect ClusterRoleBinding.
 *
 * @schema KafkaMirrorMaker2SpecTemplateClusterRoleBinding
 */
export interface KafkaMirrorMaker2SpecTemplateClusterRoleBinding {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateClusterRoleBinding#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateClusterRoleBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateClusterRoleBinding(obj: KafkaMirrorMaker2SpecTemplateClusterRoleBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildPod
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateBuildPodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#affinity
   */
  readonly affinity?: KafkaMirrorMaker2SpecTemplateBuildPodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#tolerations
   */
  readonly tolerations?: KafkaMirrorMaker2SpecTemplateBuildPodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#hostAliases
   */
  readonly hostAliases?: KafkaMirrorMaker2SpecTemplateBuildPodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPod(obj: KafkaMirrorMaker2SpecTemplateBuildPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateBuildPodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets(y)),
    'securityContext': toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainer
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainer#env
   */
  readonly env?: KafkaMirrorMaker2SpecTemplateBuildContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainer(obj: KafkaMirrorMaker2SpecTemplateBuildContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildContainerEnv(y)),
    'securityContext': toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildConfig
 */
export interface KafkaMirrorMaker2SpecTemplateBuildConfig {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildConfig#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateBuildConfigMetadata;

  /**
   * Container Registry Secret with the credentials for pulling the base image.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildConfig#pullSecret
   */
  readonly pullSecret?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildConfig(obj: KafkaMirrorMaker2SpecTemplateBuildConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateBuildConfigMetadata(obj.metadata),
    'pullSecret': obj.pullSecret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build service account.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildServiceAccount
 */
export interface KafkaMirrorMaker2SpecTemplateBuildServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildServiceAccount#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildServiceAccount(obj: KafkaMirrorMaker2SpecTemplateBuildServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Kafka Connect Cluster JMX authentication.
 *
 * @schema KafkaMirrorMaker2SpecTemplateJmxSecret
 */
export interface KafkaMirrorMaker2SpecTemplateJmxSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateJmxSecret#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateJmxSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateJmxSecret(obj: KafkaMirrorMaker2SpecTemplateJmxSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaMirrorMaker2SpecTemplateJmxSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationEnv(obj: KafkaMirrorMaker2SpecExternalConfigurationEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumes(obj: KafkaMirrorMaker2SpecExternalConfigurationVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap(obj.configMap),
    'name': obj.name,
    'secret': toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaMirrorMaker2SpecMetricsConfigType
 */
export enum KafkaMirrorMaker2SpecMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaMirrorMaker2SpecMetricsConfigValueFrom
 */
export interface KafkaMirrorMaker2SpecMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaMirrorMaker2SpecMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMetricsConfigValueFrom(obj: KafkaMirrorMaker2SpecMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates
 */
export interface KafkaMirrorMaker2SpecClustersTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersTlsTrustedCertificates(obj: KafkaMirrorMaker2SpecClustersTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationAccessToken(obj: KafkaMirrorMaker2SpecClustersAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey(obj: KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationClientSecret(obj: KafkaMirrorMaker2SpecClustersAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret(obj: KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken(obj: KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates(obj: KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationType
 */
export enum KafkaMirrorMaker2SpecClustersAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_HYPHEN_SHA_HYPHEN_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaMirrorMaker2SpecJmxOptionsAuthenticationType
 */
export enum KafkaMirrorMaker2SpecJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef(obj: KafkaMirrorMaker2SpecLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateDeploymentMetadata(obj: KafkaMirrorMaker2SpecTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentStrategy which will be used for this Deployment. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaMirrorMaker2SpecTemplateDeploymentDeploymentStrategy
 */
export enum KafkaMirrorMaker2SpecTemplateDeploymentDeploymentStrategy {
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodMetadata
 */
export interface KafkaMirrorMaker2SpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodMetadata(obj: KafkaMirrorMaker2SpecTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodImagePullSecrets
 */
export interface KafkaMirrorMaker2SpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodImagePullSecrets(obj: KafkaMirrorMaker2SpecTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContext(obj: KafkaMirrorMaker2SpecTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinity(obj: KafkaMirrorMaker2SpecTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodTolerations
 */
export interface KafkaMirrorMaker2SpecTemplatePodTolerations {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodTolerations(obj: KafkaMirrorMaker2SpecTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases
 */
export interface KafkaMirrorMaker2SpecTemplatePodHostAliases {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodHostAliases(obj: KafkaMirrorMaker2SpecTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints
 */
export interface KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints(obj: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateApiServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateApiServiceMetadata(obj: KafkaMirrorMaker2SpecTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaMirrorMaker2SpecTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaMirrorMaker2SpecTemplateApiServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaMirrorMaker2SpecTemplateApiServiceIpFamilies
 */
export enum KafkaMirrorMaker2SpecTemplateApiServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerEnv(obj: KafkaMirrorMaker2SpecTemplateConnectContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext(obj: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerEnv(obj: KafkaMirrorMaker2SpecTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext(obj: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata(obj: KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateServiceAccountMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateServiceAccountMetadata(obj: KafkaMirrorMaker2SpecTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata(obj: KafkaMirrorMaker2SpecTemplateClusterRoleBindingMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodMetadata(obj: KafkaMirrorMaker2SpecTemplateBuildPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets(obj: KafkaMirrorMaker2SpecTemplateBuildPodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext(obj: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinity(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodTolerations {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodTolerations(obj: KafkaMirrorMaker2SpecTemplateBuildPodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodHostAliases
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodHostAliases {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodHostAliases(obj: KafkaMirrorMaker2SpecTemplateBuildPodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints(obj: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerEnv
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerEnv(obj: KafkaMirrorMaker2SpecTemplateBuildContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext(obj: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildConfigMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateBuildConfigMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildConfigMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildConfigMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildConfigMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildConfigMetadata(obj: KafkaMirrorMaker2SpecTemplateBuildConfigMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata(obj: KafkaMirrorMaker2SpecTemplateBuildServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateJmxSecretMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateJmxSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateJmxSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateJmxSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateJmxSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateJmxSecretMetadata(obj: KafkaMirrorMaker2SpecTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom {
  /**
   * Reference to a key in a ConfigMap.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom(obj: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap(obj: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret(obj: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef(obj: KafkaMirrorMaker2SpecMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions(obj: KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile(obj: KafkaMirrorMaker2SpecTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls(obj: KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions(obj: KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities(obj: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile(obj: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions(obj: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities(obj: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions(obj: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile(obj: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls(obj: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions(obj: KafkaMirrorMaker2SpecTemplateBuildPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities(obj: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile(obj: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions(obj: KafkaMirrorMaker2SpecTemplateBuildContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef(obj: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems(obj: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems(obj: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaMirrorMaker2SpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaRebalance
 */
export class KafkaRebalance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaRebalance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaRebalance',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaRebalance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaRebalanceProps = {}): any {
    return {
      ...KafkaRebalance.GVK,
      ...toJson_KafkaRebalanceProps(props),
    };
  }

  /**
   * Defines a "KafkaRebalance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaRebalanceProps = {}) {
    super(scope, id, {
      ...KafkaRebalance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaRebalance.GVK,
      ...toJson_KafkaRebalanceProps(resolved),
    };
  }
}

/**
 * @schema KafkaRebalance
 */
export interface KafkaRebalanceProps {
  /**
   * @schema KafkaRebalance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka rebalance.
   *
   * @schema KafkaRebalance#spec
   */
  readonly spec?: KafkaRebalanceSpec;

}

/**
 * Converts an object of type 'KafkaRebalanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaRebalanceProps(obj: KafkaRebalanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaRebalanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka rebalance.
 *
 * @schema KafkaRebalanceSpec
 */
export interface KafkaRebalanceSpec {
  /**
   * Mode to run the rebalancing. The supported modes are `full`, `add-brokers`, `remove-brokers`.
   * If not specified, the `full` mode is used by default.
   *
   * * `full` mode runs the rebalancing across all the brokers in the cluster.
   * * `add-brokers` mode can be used after scaling up the cluster to move some replicas to the newly added brokers.
   * * `remove-brokers` mode can be used before scaling down the cluster to move replicas out of the brokers to be removed.
   *
   *
   * @schema KafkaRebalanceSpec#mode
   */
  readonly mode?: KafkaRebalanceSpecMode;

  /**
   * The list of newly added brokers in case of scaling up or the ones to be removed in case of scaling down to use for rebalancing. This list can be used only with rebalancing mode `add-brokers` and `removed-brokers`. It is ignored with `full` mode.
   *
   * @schema KafkaRebalanceSpec#brokers
   */
  readonly brokers?: number[];

  /**
   * A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.
   *
   * @schema KafkaRebalanceSpec#goals
   */
  readonly goals?: string[];

  /**
   * Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.
   *
   * @default false.
   * @schema KafkaRebalanceSpec#skipHardGoalCheck
   */
  readonly skipHardGoalCheck?: boolean;

  /**
   * Enables intra-broker disk balancing, which balances disk space utilization between disks on the same broker. Only applies to Kafka deployments that use JBOD storage with multiple disks. When enabled, inter-broker balancing is disabled. Default is false.
   *
   * @default false.
   * @schema KafkaRebalanceSpec#rebalanceDisk
   */
  readonly rebalanceDisk?: boolean;

  /**
   * A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported format consult the documentation for that class.
   *
   * @schema KafkaRebalanceSpec#excludedTopics
   */
  readonly excludedTopics?: string;

  /**
   * The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.
   *
   * @default 5.
   * @schema KafkaRebalanceSpec#concurrentPartitionMovementsPerBroker
   */
  readonly concurrentPartitionMovementsPerBroker?: number;

  /**
   * The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.
   *
   * @default 2.
   * @schema KafkaRebalanceSpec#concurrentIntraBrokerPartitionMovements
   */
  readonly concurrentIntraBrokerPartitionMovements?: number;

  /**
   * The upper bound of ongoing partition leadership movements. Default is 1000.
   *
   * @default 1000.
   * @schema KafkaRebalanceSpec#concurrentLeaderMovements
   */
  readonly concurrentLeaderMovements?: number;

  /**
   * The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.
   *
   * @schema KafkaRebalanceSpec#replicationThrottle
   */
  readonly replicationThrottle?: number;

  /**
   * A list of strategy class names used to determine the execution order for the replica movements in the generated optimization proposal. By default BaseReplicaMovementStrategy is used, which will execute the replica movements in the order that they were generated.
   *
   * @schema KafkaRebalanceSpec#replicaMovementStrategies
   */
  readonly replicaMovementStrategies?: string[];

}

/**
 * Converts an object of type 'KafkaRebalanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaRebalanceSpec(obj: KafkaRebalanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'brokers': obj.brokers?.map(y => y),
    'goals': obj.goals?.map(y => y),
    'skipHardGoalCheck': obj.skipHardGoalCheck,
    'rebalanceDisk': obj.rebalanceDisk,
    'excludedTopics': obj.excludedTopics,
    'concurrentPartitionMovementsPerBroker': obj.concurrentPartitionMovementsPerBroker,
    'concurrentIntraBrokerPartitionMovements': obj.concurrentIntraBrokerPartitionMovements,
    'concurrentLeaderMovements': obj.concurrentLeaderMovements,
    'replicationThrottle': obj.replicationThrottle,
    'replicaMovementStrategies': obj.replicaMovementStrategies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode to run the rebalancing. The supported modes are `full`, `add-brokers`, `remove-brokers`.
 * If not specified, the `full` mode is used by default.
 *
 * * `full` mode runs the rebalancing across all the brokers in the cluster.
 * * `add-brokers` mode can be used after scaling up the cluster to move some replicas to the newly added brokers.
 * * `remove-brokers` mode can be used before scaling down the cluster to move replicas out of the brokers to be removed.
 *
 *
 * @schema KafkaRebalanceSpecMode
 */
export enum KafkaRebalanceSpecMode {
  /** full */
  FULL = "full",
  /** add-brokers */
  ADD_HYPHEN_BROKERS = "add-brokers",
  /** remove-brokers */
  REMOVE_HYPHEN_BROKERS = "remove-brokers",
}


/**
 *
 *
 * @schema KafkaTopic
 */
export class KafkaTopic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaTopic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaTopic',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaTopic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaTopicProps = {}): any {
    return {
      ...KafkaTopic.GVK,
      ...toJson_KafkaTopicProps(props),
    };
  }

  /**
   * Defines a "KafkaTopic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaTopicProps = {}) {
    super(scope, id, {
      ...KafkaTopic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaTopic.GVK,
      ...toJson_KafkaTopicProps(resolved),
    };
  }
}

/**
 * @schema KafkaTopic
 */
export interface KafkaTopicProps {
  /**
   * @schema KafkaTopic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the topic.
   *
   * @schema KafkaTopic#spec
   */
  readonly spec?: KafkaTopicSpec;

}

/**
 * Converts an object of type 'KafkaTopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicProps(obj: KafkaTopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaTopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the topic.
 *
 * @schema KafkaTopicSpec
 */
export interface KafkaTopicSpec {
  /**
   * The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning. When absent this will default to the broker configuration for `num.partitions`.
   *
   * @schema KafkaTopicSpec#partitions
   */
  readonly partitions?: number;

  /**
   * The number of replicas the topic should have. When absent this will default to the broker configuration for `default.replication.factor`.
   *
   * @schema KafkaTopicSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The topic configuration.
   *
   * @schema KafkaTopicSpec#config
   */
  readonly config?: any;

  /**
   * The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
   *
   * @schema KafkaTopicSpec#topicName
   */
  readonly topicName?: string;

}

/**
 * Converts an object of type 'KafkaTopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicSpec(obj: KafkaTopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitions': obj.partitions,
    'replicas': obj.replicas,
    'config': obj.config,
    'topicName': obj.topicName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaTopicV1Beta1
 */
export class KafkaTopicV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaTopicV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaTopic',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaTopicV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaTopicV1Beta1Props = {}): any {
    return {
      ...KafkaTopicV1Beta1.GVK,
      ...toJson_KafkaTopicV1Beta1Props(props),
    };
  }

  /**
   * Defines a "KafkaTopicV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaTopicV1Beta1Props = {}) {
    super(scope, id, {
      ...KafkaTopicV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaTopicV1Beta1.GVK,
      ...toJson_KafkaTopicV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema KafkaTopicV1Beta1
 */
export interface KafkaTopicV1Beta1Props {
  /**
   * @schema KafkaTopicV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the topic.
   *
   * @schema KafkaTopicV1Beta1#spec
   */
  readonly spec?: KafkaTopicV1Beta1Spec;

}

/**
 * Converts an object of type 'KafkaTopicV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicV1Beta1Props(obj: KafkaTopicV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaTopicV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the topic.
 *
 * @schema KafkaTopicV1Beta1Spec
 */
export interface KafkaTopicV1Beta1Spec {
  /**
   * The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning. When absent this will default to the broker configuration for `num.partitions`.
   *
   * @schema KafkaTopicV1Beta1Spec#partitions
   */
  readonly partitions?: number;

  /**
   * The number of replicas the topic should have. When absent this will default to the broker configuration for `default.replication.factor`.
   *
   * @schema KafkaTopicV1Beta1Spec#replicas
   */
  readonly replicas?: number;

  /**
   * The topic configuration.
   *
   * @schema KafkaTopicV1Beta1Spec#config
   */
  readonly config?: any;

  /**
   * The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
   *
   * @schema KafkaTopicV1Beta1Spec#topicName
   */
  readonly topicName?: string;

}

/**
 * Converts an object of type 'KafkaTopicV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicV1Beta1Spec(obj: KafkaTopicV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitions': obj.partitions,
    'replicas': obj.replicas,
    'config': obj.config,
    'topicName': obj.topicName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaTopicV1Alpha1
 */
export class KafkaTopicV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaTopicV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaTopic',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaTopicV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaTopicV1Alpha1Props = {}): any {
    return {
      ...KafkaTopicV1Alpha1.GVK,
      ...toJson_KafkaTopicV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "KafkaTopicV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaTopicV1Alpha1Props = {}) {
    super(scope, id, {
      ...KafkaTopicV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaTopicV1Alpha1.GVK,
      ...toJson_KafkaTopicV1Alpha1Props(resolved),
    };
  }
}

/**
 * @schema KafkaTopicV1Alpha1
 */
export interface KafkaTopicV1Alpha1Props {
  /**
   * @schema KafkaTopicV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the topic.
   *
   * @schema KafkaTopicV1Alpha1#spec
   */
  readonly spec?: KafkaTopicV1Alpha1Spec;

}

/**
 * Converts an object of type 'KafkaTopicV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicV1Alpha1Props(obj: KafkaTopicV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaTopicV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the topic.
 *
 * @schema KafkaTopicV1Alpha1Spec
 */
export interface KafkaTopicV1Alpha1Spec {
  /**
   * The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning. When absent this will default to the broker configuration for `num.partitions`.
   *
   * @schema KafkaTopicV1Alpha1Spec#partitions
   */
  readonly partitions?: number;

  /**
   * The number of replicas the topic should have. When absent this will default to the broker configuration for `default.replication.factor`.
   *
   * @schema KafkaTopicV1Alpha1Spec#replicas
   */
  readonly replicas?: number;

  /**
   * The topic configuration.
   *
   * @schema KafkaTopicV1Alpha1Spec#config
   */
  readonly config?: any;

  /**
   * The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
   *
   * @schema KafkaTopicV1Alpha1Spec#topicName
   */
  readonly topicName?: string;

}

/**
 * Converts an object of type 'KafkaTopicV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaTopicV1Alpha1Spec(obj: KafkaTopicV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitions': obj.partitions,
    'replicas': obj.replicas,
    'config': obj.config,
    'topicName': obj.topicName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema KafkaUser
 */
export class KafkaUser extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaUser"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaUser',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaUser".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaUserProps = {}): any {
    return {
      ...KafkaUser.GVK,
      ...toJson_KafkaUserProps(props),
    };
  }

  /**
   * Defines a "KafkaUser" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaUserProps = {}) {
    super(scope, id, {
      ...KafkaUser.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaUser.GVK,
      ...toJson_KafkaUserProps(resolved),
    };
  }
}

/**
 * @schema KafkaUser
 */
export interface KafkaUserProps {
  /**
   * @schema KafkaUser#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the user.
   *
   * @schema KafkaUser#spec
   */
  readonly spec?: KafkaUserSpec;

}

/**
 * Converts an object of type 'KafkaUserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserProps(obj: KafkaUserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaUserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the user.
 *
 * @schema KafkaUserSpec
 */
export interface KafkaUserSpec {
  /**
   * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
   *
   * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
   * * `tls` generates a secret with user certificate for mutual TLS authentication.
   * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
   * ACLs and quotas set for this user are configured in the `CN=<username>` format.
   *
   * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
   *
   * @schema KafkaUserSpec#authentication
   */
  readonly authentication?: KafkaUserSpecAuthentication;

  /**
   * Authorization rules for this Kafka user.
   *
   * @schema KafkaUserSpec#authorization
   */
  readonly authorization?: KafkaUserSpecAuthorization;

  /**
   * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
   *
   * @schema KafkaUserSpec#quotas
   */
  readonly quotas?: KafkaUserSpecQuotas;

  /**
   * Template to specify how Kafka User `Secrets` are generated.
   *
   * @schema KafkaUserSpec#template
   */
  readonly template?: KafkaUserSpecTemplate;

}

/**
 * Converts an object of type 'KafkaUserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpec(obj: KafkaUserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaUserSpecAuthentication(obj.authentication),
    'authorization': toJson_KafkaUserSpecAuthorization(obj.authorization),
    'quotas': toJson_KafkaUserSpecQuotas(obj.quotas),
    'template': toJson_KafkaUserSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
 *
 * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
 * * `tls` generates a secret with user certificate for mutual TLS authentication.
 * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
 * ACLs and quotas set for this user are configured in the `CN=<username>` format.
 *
 * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
 *
 * @schema KafkaUserSpecAuthentication
 */
export interface KafkaUserSpecAuthentication {
  /**
   * Specify the password for the user. If not set, a new password is generated by the User Operator.
   *
   * @schema KafkaUserSpecAuthentication#password
   */
  readonly password?: KafkaUserSpecAuthenticationPassword;

  /**
   * Authentication type.
   *
   * @schema KafkaUserSpecAuthentication#type
   */
  readonly type: KafkaUserSpecAuthenticationType;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthentication(obj: KafkaUserSpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_KafkaUserSpecAuthenticationPassword(obj.password),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization rules for this Kafka user.
 *
 * @schema KafkaUserSpecAuthorization
 */
export interface KafkaUserSpecAuthorization {
  /**
   * List of ACL rules which should be applied to this user.
   *
   * @schema KafkaUserSpecAuthorization#acls
   */
  readonly acls: KafkaUserSpecAuthorizationAcls[];

  /**
   * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
   *
   * @schema KafkaUserSpecAuthorization#type
   */
  readonly type: KafkaUserSpecAuthorizationType;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthorization(obj: KafkaUserSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acls': obj.acls?.map(y => toJson_KafkaUserSpecAuthorizationAcls(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
 *
 * @schema KafkaUserSpecQuotas
 */
export interface KafkaUserSpecQuotas {
  /**
   * A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserSpecQuotas#consumerByteRate
   */
  readonly consumerByteRate?: number;

  /**
   * A quota on the rate at which mutations are accepted for the create topics request, the create partitions request and the delete topics request. The rate is accumulated by the number of partitions created or deleted.
   *
   * @schema KafkaUserSpecQuotas#controllerMutationRate
   */
  readonly controllerMutationRate?: number;

  /**
   * A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserSpecQuotas#producerByteRate
   */
  readonly producerByteRate?: number;

  /**
   * A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
   *
   * @schema KafkaUserSpecQuotas#requestPercentage
   */
  readonly requestPercentage?: number;

}

/**
 * Converts an object of type 'KafkaUserSpecQuotas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecQuotas(obj: KafkaUserSpecQuotas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerByteRate': obj.consumerByteRate,
    'controllerMutationRate': obj.controllerMutationRate,
    'producerByteRate': obj.producerByteRate,
    'requestPercentage': obj.requestPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Kafka User `Secrets` are generated.
 *
 * @schema KafkaUserSpecTemplate
 */
export interface KafkaUserSpecTemplate {
  /**
   * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
   *
   * @schema KafkaUserSpecTemplate#secret
   */
  readonly secret?: KafkaUserSpecTemplateSecret;

}

/**
 * Converts an object of type 'KafkaUserSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecTemplate(obj: KafkaUserSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': toJson_KafkaUserSpecTemplateSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify the password for the user. If not set, a new password is generated by the User Operator.
 *
 * @schema KafkaUserSpecAuthenticationPassword
 */
export interface KafkaUserSpecAuthenticationPassword {
  /**
   * Secret from which the password should be read.
   *
   * @schema KafkaUserSpecAuthenticationPassword#valueFrom
   */
  readonly valueFrom: KafkaUserSpecAuthenticationPasswordValueFrom;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthenticationPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthenticationPassword(obj: KafkaUserSpecAuthenticationPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'valueFrom': toJson_KafkaUserSpecAuthenticationPasswordValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type.
 *
 * @schema KafkaUserSpecAuthenticationType
 */
export enum KafkaUserSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** tls-external */
  TLS_HYPHEN_EXTERNAL = "tls-external",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
}

/**
 * @schema KafkaUserSpecAuthorizationAcls
 */
export interface KafkaUserSpecAuthorizationAcls {
  /**
   * The host from which the action described in the ACL rule is allowed or denied.
   *
   * @schema KafkaUserSpecAuthorizationAcls#host
   */
  readonly host?: string;

  /**
   * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserSpecAuthorizationAcls#operation
   */
  readonly operation?: KafkaUserSpecAuthorizationAclsOperation;

  /**
   * List of operations which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserSpecAuthorizationAcls#operations
   */
  readonly operations?: KafkaUserSpecAuthorizationAclsOperations[];

  /**
   * Indicates the resource for which given ACL rule applies.
   *
   * @schema KafkaUserSpecAuthorizationAcls#resource
   */
  readonly resource: KafkaUserSpecAuthorizationAclsResource;

  /**
   * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
   *
   * @schema KafkaUserSpecAuthorizationAcls#type
   */
  readonly type?: KafkaUserSpecAuthorizationAclsType;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthorizationAcls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthorizationAcls(obj: KafkaUserSpecAuthorizationAcls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'operation': obj.operation,
    'operations': obj.operations?.map(y => y),
    'resource': toJson_KafkaUserSpecAuthorizationAclsResource(obj.resource),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
 *
 * @schema KafkaUserSpecAuthorizationType
 */
export enum KafkaUserSpecAuthorizationType {
  /** simple */
  SIMPLE = "simple",
}

/**
 * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
 *
 * @schema KafkaUserSpecTemplateSecret
 */
export interface KafkaUserSpecTemplateSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaUserSpecTemplateSecret#metadata
   */
  readonly metadata?: KafkaUserSpecTemplateSecretMetadata;

}

/**
 * Converts an object of type 'KafkaUserSpecTemplateSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecTemplateSecret(obj: KafkaUserSpecTemplateSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaUserSpecTemplateSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret from which the password should be read.
 *
 * @schema KafkaUserSpecAuthenticationPasswordValueFrom
 */
export interface KafkaUserSpecAuthenticationPasswordValueFrom {
  /**
   * Selects a key of a Secret in the resource's namespace.
   *
   * @schema KafkaUserSpecAuthenticationPasswordValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthenticationPasswordValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthenticationPasswordValueFrom(obj: KafkaUserSpecAuthenticationPasswordValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
 *
 * @schema KafkaUserSpecAuthorizationAclsOperation
 */
export enum KafkaUserSpecAuthorizationAclsOperation {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * @schema KafkaUserSpecAuthorizationAclsOperations
 */
export enum KafkaUserSpecAuthorizationAclsOperations {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * Indicates the resource for which given ACL rule applies.
 *
 * @schema KafkaUserSpecAuthorizationAclsResource
 */
export interface KafkaUserSpecAuthorizationAclsResource {
  /**
   * Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#name
   */
  readonly name?: string;

  /**
   * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#patternType
   */
  readonly patternType?: KafkaUserSpecAuthorizationAclsResourcePatternType;

  /**
   * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#type
   */
  readonly type: KafkaUserSpecAuthorizationAclsResourceType;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthorizationAclsResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthorizationAclsResource(obj: KafkaUserSpecAuthorizationAclsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patternType': obj.patternType,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
 *
 * @schema KafkaUserSpecAuthorizationAclsType
 */
export enum KafkaUserSpecAuthorizationAclsType {
  /** allow */
  ALLOW = "allow",
  /** deny */
  DENY = "deny",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaUserSpecTemplateSecretMetadata
 */
export interface KafkaUserSpecTemplateSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserSpecTemplateSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserSpecTemplateSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaUserSpecTemplateSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecTemplateSecretMetadata(obj: KafkaUserSpecTemplateSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the resource's namespace.
 *
 * @schema KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef
 */
export interface KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef {
  /**
   * @schema KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef(obj: KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
 *
 * @schema KafkaUserSpecAuthorizationAclsResourcePatternType
 */
export enum KafkaUserSpecAuthorizationAclsResourcePatternType {
  /** literal */
  LITERAL = "literal",
  /** prefix */
  PREFIX = "prefix",
}

/**
 * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
 *
 * @schema KafkaUserSpecAuthorizationAclsResourceType
 */
export enum KafkaUserSpecAuthorizationAclsResourceType {
  /** topic */
  TOPIC = "topic",
  /** group */
  GROUP = "group",
  /** cluster */
  CLUSTER = "cluster",
  /** transactionalId */
  TRANSACTIONAL_ID = "transactionalId",
}


/**
 *
 *
 * @schema KafkaUserV1Beta1
 */
export class KafkaUserV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaUserV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaUser',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaUserV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaUserV1Beta1Props = {}): any {
    return {
      ...KafkaUserV1Beta1.GVK,
      ...toJson_KafkaUserV1Beta1Props(props),
    };
  }

  /**
   * Defines a "KafkaUserV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaUserV1Beta1Props = {}) {
    super(scope, id, {
      ...KafkaUserV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaUserV1Beta1.GVK,
      ...toJson_KafkaUserV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema KafkaUserV1Beta1
 */
export interface KafkaUserV1Beta1Props {
  /**
   * @schema KafkaUserV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the user.
   *
   * @schema KafkaUserV1Beta1#spec
   */
  readonly spec?: KafkaUserV1Beta1Spec;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1Props(obj: KafkaUserV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaUserV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the user.
 *
 * @schema KafkaUserV1Beta1Spec
 */
export interface KafkaUserV1Beta1Spec {
  /**
   * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
   *
   * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
   * * `tls` generates a secret with user certificate for mutual TLS authentication.
   * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
   * ACLs and quotas set for this user are configured in the `CN=<username>` format.
   *
   * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
   *
   * @schema KafkaUserV1Beta1Spec#authentication
   */
  readonly authentication?: KafkaUserV1Beta1SpecAuthentication;

  /**
   * Authorization rules for this Kafka user.
   *
   * @schema KafkaUserV1Beta1Spec#authorization
   */
  readonly authorization?: KafkaUserV1Beta1SpecAuthorization;

  /**
   * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
   *
   * @schema KafkaUserV1Beta1Spec#quotas
   */
  readonly quotas?: KafkaUserV1Beta1SpecQuotas;

  /**
   * Template to specify how Kafka User `Secrets` are generated.
   *
   * @schema KafkaUserV1Beta1Spec#template
   */
  readonly template?: KafkaUserV1Beta1SpecTemplate;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1Spec(obj: KafkaUserV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaUserV1Beta1SpecAuthentication(obj.authentication),
    'authorization': toJson_KafkaUserV1Beta1SpecAuthorization(obj.authorization),
    'quotas': toJson_KafkaUserV1Beta1SpecQuotas(obj.quotas),
    'template': toJson_KafkaUserV1Beta1SpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
 *
 * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
 * * `tls` generates a secret with user certificate for mutual TLS authentication.
 * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
 * ACLs and quotas set for this user are configured in the `CN=<username>` format.
 *
 * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
 *
 * @schema KafkaUserV1Beta1SpecAuthentication
 */
export interface KafkaUserV1Beta1SpecAuthentication {
  /**
   * Specify the password for the user. If not set, a new password is generated by the User Operator.
   *
   * @schema KafkaUserV1Beta1SpecAuthentication#password
   */
  readonly password?: KafkaUserV1Beta1SpecAuthenticationPassword;

  /**
   * Authentication type.
   *
   * @schema KafkaUserV1Beta1SpecAuthentication#type
   */
  readonly type: KafkaUserV1Beta1SpecAuthenticationType;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthentication(obj: KafkaUserV1Beta1SpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_KafkaUserV1Beta1SpecAuthenticationPassword(obj.password),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization rules for this Kafka user.
 *
 * @schema KafkaUserV1Beta1SpecAuthorization
 */
export interface KafkaUserV1Beta1SpecAuthorization {
  /**
   * List of ACL rules which should be applied to this user.
   *
   * @schema KafkaUserV1Beta1SpecAuthorization#acls
   */
  readonly acls: KafkaUserV1Beta1SpecAuthorizationAcls[];

  /**
   * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
   *
   * @schema KafkaUserV1Beta1SpecAuthorization#type
   */
  readonly type: KafkaUserV1Beta1SpecAuthorizationType;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthorization(obj: KafkaUserV1Beta1SpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acls': obj.acls?.map(y => toJson_KafkaUserV1Beta1SpecAuthorizationAcls(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
 *
 * @schema KafkaUserV1Beta1SpecQuotas
 */
export interface KafkaUserV1Beta1SpecQuotas {
  /**
   * A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserV1Beta1SpecQuotas#consumerByteRate
   */
  readonly consumerByteRate?: number;

  /**
   * A quota on the rate at which mutations are accepted for the create topics request, the create partitions request and the delete topics request. The rate is accumulated by the number of partitions created or deleted.
   *
   * @schema KafkaUserV1Beta1SpecQuotas#controllerMutationRate
   */
  readonly controllerMutationRate?: number;

  /**
   * A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserV1Beta1SpecQuotas#producerByteRate
   */
  readonly producerByteRate?: number;

  /**
   * A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
   *
   * @schema KafkaUserV1Beta1SpecQuotas#requestPercentage
   */
  readonly requestPercentage?: number;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecQuotas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecQuotas(obj: KafkaUserV1Beta1SpecQuotas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerByteRate': obj.consumerByteRate,
    'controllerMutationRate': obj.controllerMutationRate,
    'producerByteRate': obj.producerByteRate,
    'requestPercentage': obj.requestPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Kafka User `Secrets` are generated.
 *
 * @schema KafkaUserV1Beta1SpecTemplate
 */
export interface KafkaUserV1Beta1SpecTemplate {
  /**
   * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
   *
   * @schema KafkaUserV1Beta1SpecTemplate#secret
   */
  readonly secret?: KafkaUserV1Beta1SpecTemplateSecret;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecTemplate(obj: KafkaUserV1Beta1SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': toJson_KafkaUserV1Beta1SpecTemplateSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify the password for the user. If not set, a new password is generated by the User Operator.
 *
 * @schema KafkaUserV1Beta1SpecAuthenticationPassword
 */
export interface KafkaUserV1Beta1SpecAuthenticationPassword {
  /**
   * Secret from which the password should be read.
   *
   * @schema KafkaUserV1Beta1SpecAuthenticationPassword#valueFrom
   */
  readonly valueFrom: KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthenticationPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthenticationPassword(obj: KafkaUserV1Beta1SpecAuthenticationPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'valueFrom': toJson_KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type.
 *
 * @schema KafkaUserV1Beta1SpecAuthenticationType
 */
export enum KafkaUserV1Beta1SpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** tls-external */
  TLS_HYPHEN_EXTERNAL = "tls-external",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
}

/**
 * @schema KafkaUserV1Beta1SpecAuthorizationAcls
 */
export interface KafkaUserV1Beta1SpecAuthorizationAcls {
  /**
   * The host from which the action described in the ACL rule is allowed or denied.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAcls#host
   */
  readonly host?: string;

  /**
   * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAcls#operation
   */
  readonly operation?: KafkaUserV1Beta1SpecAuthorizationAclsOperation;

  /**
   * List of operations which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAcls#operations
   */
  readonly operations?: KafkaUserV1Beta1SpecAuthorizationAclsOperations[];

  /**
   * Indicates the resource for which given ACL rule applies.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAcls#resource
   */
  readonly resource: KafkaUserV1Beta1SpecAuthorizationAclsResource;

  /**
   * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAcls#type
   */
  readonly type?: KafkaUserV1Beta1SpecAuthorizationAclsType;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthorizationAcls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthorizationAcls(obj: KafkaUserV1Beta1SpecAuthorizationAcls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'operation': obj.operation,
    'operations': obj.operations?.map(y => y),
    'resource': toJson_KafkaUserV1Beta1SpecAuthorizationAclsResource(obj.resource),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationType
 */
export enum KafkaUserV1Beta1SpecAuthorizationType {
  /** simple */
  SIMPLE = "simple",
}

/**
 * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
 *
 * @schema KafkaUserV1Beta1SpecTemplateSecret
 */
export interface KafkaUserV1Beta1SpecTemplateSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaUserV1Beta1SpecTemplateSecret#metadata
   */
  readonly metadata?: KafkaUserV1Beta1SpecTemplateSecretMetadata;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecTemplateSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecTemplateSecret(obj: KafkaUserV1Beta1SpecTemplateSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaUserV1Beta1SpecTemplateSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret from which the password should be read.
 *
 * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom
 */
export interface KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom {
  /**
   * Selects a key of a Secret in the resource's namespace.
   *
   * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom(obj: KafkaUserV1Beta1SpecAuthenticationPasswordValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsOperation
 */
export enum KafkaUserV1Beta1SpecAuthorizationAclsOperation {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsOperations
 */
export enum KafkaUserV1Beta1SpecAuthorizationAclsOperations {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * Indicates the resource for which given ACL rule applies.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsResource
 */
export interface KafkaUserV1Beta1SpecAuthorizationAclsResource {
  /**
   * Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAclsResource#name
   */
  readonly name?: string;

  /**
   * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAclsResource#patternType
   */
  readonly patternType?: KafkaUserV1Beta1SpecAuthorizationAclsResourcePatternType;

  /**
   * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
   *
   * @schema KafkaUserV1Beta1SpecAuthorizationAclsResource#type
   */
  readonly type: KafkaUserV1Beta1SpecAuthorizationAclsResourceType;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthorizationAclsResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthorizationAclsResource(obj: KafkaUserV1Beta1SpecAuthorizationAclsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patternType': obj.patternType,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsType
 */
export enum KafkaUserV1Beta1SpecAuthorizationAclsType {
  /** allow */
  ALLOW = "allow",
  /** deny */
  DENY = "deny",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaUserV1Beta1SpecTemplateSecretMetadata
 */
export interface KafkaUserV1Beta1SpecTemplateSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserV1Beta1SpecTemplateSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserV1Beta1SpecTemplateSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecTemplateSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecTemplateSecretMetadata(obj: KafkaUserV1Beta1SpecTemplateSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the resource's namespace.
 *
 * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef
 */
export interface KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef {
  /**
   * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef(obj: KafkaUserV1Beta1SpecAuthenticationPasswordValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsResourcePatternType
 */
export enum KafkaUserV1Beta1SpecAuthorizationAclsResourcePatternType {
  /** literal */
  LITERAL = "literal",
  /** prefix */
  PREFIX = "prefix",
}

/**
 * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
 *
 * @schema KafkaUserV1Beta1SpecAuthorizationAclsResourceType
 */
export enum KafkaUserV1Beta1SpecAuthorizationAclsResourceType {
  /** topic */
  TOPIC = "topic",
  /** group */
  GROUP = "group",
  /** cluster */
  CLUSTER = "cluster",
  /** transactionalId */
  TRANSACTIONAL_ID = "transactionalId",
}


/**
 *
 *
 * @schema KafkaUserV1Alpha1
 */
export class KafkaUserV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaUserV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaUser',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaUserV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaUserV1Alpha1Props = {}): any {
    return {
      ...KafkaUserV1Alpha1.GVK,
      ...toJson_KafkaUserV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "KafkaUserV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaUserV1Alpha1Props = {}) {
    super(scope, id, {
      ...KafkaUserV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaUserV1Alpha1.GVK,
      ...toJson_KafkaUserV1Alpha1Props(resolved),
    };
  }
}

/**
 * @schema KafkaUserV1Alpha1
 */
export interface KafkaUserV1Alpha1Props {
  /**
   * @schema KafkaUserV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the user.
   *
   * @schema KafkaUserV1Alpha1#spec
   */
  readonly spec?: KafkaUserV1Alpha1Spec;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1Props(obj: KafkaUserV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaUserV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the user.
 *
 * @schema KafkaUserV1Alpha1Spec
 */
export interface KafkaUserV1Alpha1Spec {
  /**
   * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
   *
   * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
   * * `tls` generates a secret with user certificate for mutual TLS authentication.
   * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
   * ACLs and quotas set for this user are configured in the `CN=<username>` format.
   *
   * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
   *
   * @schema KafkaUserV1Alpha1Spec#authentication
   */
  readonly authentication?: KafkaUserV1Alpha1SpecAuthentication;

  /**
   * Authorization rules for this Kafka user.
   *
   * @schema KafkaUserV1Alpha1Spec#authorization
   */
  readonly authorization?: KafkaUserV1Alpha1SpecAuthorization;

  /**
   * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
   *
   * @schema KafkaUserV1Alpha1Spec#quotas
   */
  readonly quotas?: KafkaUserV1Alpha1SpecQuotas;

  /**
   * Template to specify how Kafka User `Secrets` are generated.
   *
   * @schema KafkaUserV1Alpha1Spec#template
   */
  readonly template?: KafkaUserV1Alpha1SpecTemplate;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1Spec(obj: KafkaUserV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaUserV1Alpha1SpecAuthentication(obj.authentication),
    'authorization': toJson_KafkaUserV1Alpha1SpecAuthorization(obj.authorization),
    'quotas': toJson_KafkaUserV1Alpha1SpecQuotas(obj.quotas),
    'template': toJson_KafkaUserV1Alpha1SpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
 *
 * * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
 * * `tls` generates a secret with user certificate for mutual TLS authentication.
 * * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
 * ACLs and quotas set for this user are configured in the `CN=<username>` format.
 *
 * Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
 *
 * @schema KafkaUserV1Alpha1SpecAuthentication
 */
export interface KafkaUserV1Alpha1SpecAuthentication {
  /**
   * Specify the password for the user. If not set, a new password is generated by the User Operator.
   *
   * @schema KafkaUserV1Alpha1SpecAuthentication#password
   */
  readonly password?: KafkaUserV1Alpha1SpecAuthenticationPassword;

  /**
   * Authentication type.
   *
   * @schema KafkaUserV1Alpha1SpecAuthentication#type
   */
  readonly type: KafkaUserV1Alpha1SpecAuthenticationType;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthentication(obj: KafkaUserV1Alpha1SpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_KafkaUserV1Alpha1SpecAuthenticationPassword(obj.password),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization rules for this Kafka user.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorization
 */
export interface KafkaUserV1Alpha1SpecAuthorization {
  /**
   * List of ACL rules which should be applied to this user.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorization#acls
   */
  readonly acls: KafkaUserV1Alpha1SpecAuthorizationAcls[];

  /**
   * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorization#type
   */
  readonly type: KafkaUserV1Alpha1SpecAuthorizationType;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthorization(obj: KafkaUserV1Alpha1SpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acls': obj.acls?.map(y => toJson_KafkaUserV1Alpha1SpecAuthorizationAcls(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
 *
 * @schema KafkaUserV1Alpha1SpecQuotas
 */
export interface KafkaUserV1Alpha1SpecQuotas {
  /**
   * A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserV1Alpha1SpecQuotas#consumerByteRate
   */
  readonly consumerByteRate?: number;

  /**
   * A quota on the rate at which mutations are accepted for the create topics request, the create partitions request and the delete topics request. The rate is accumulated by the number of partitions created or deleted.
   *
   * @schema KafkaUserV1Alpha1SpecQuotas#controllerMutationRate
   */
  readonly controllerMutationRate?: number;

  /**
   * A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserV1Alpha1SpecQuotas#producerByteRate
   */
  readonly producerByteRate?: number;

  /**
   * A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
   *
   * @schema KafkaUserV1Alpha1SpecQuotas#requestPercentage
   */
  readonly requestPercentage?: number;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecQuotas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecQuotas(obj: KafkaUserV1Alpha1SpecQuotas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumerByteRate': obj.consumerByteRate,
    'controllerMutationRate': obj.controllerMutationRate,
    'producerByteRate': obj.producerByteRate,
    'requestPercentage': obj.requestPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Kafka User `Secrets` are generated.
 *
 * @schema KafkaUserV1Alpha1SpecTemplate
 */
export interface KafkaUserV1Alpha1SpecTemplate {
  /**
   * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
   *
   * @schema KafkaUserV1Alpha1SpecTemplate#secret
   */
  readonly secret?: KafkaUserV1Alpha1SpecTemplateSecret;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecTemplate(obj: KafkaUserV1Alpha1SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': toJson_KafkaUserV1Alpha1SpecTemplateSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify the password for the user. If not set, a new password is generated by the User Operator.
 *
 * @schema KafkaUserV1Alpha1SpecAuthenticationPassword
 */
export interface KafkaUserV1Alpha1SpecAuthenticationPassword {
  /**
   * Secret from which the password should be read.
   *
   * @schema KafkaUserV1Alpha1SpecAuthenticationPassword#valueFrom
   */
  readonly valueFrom: KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthenticationPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthenticationPassword(obj: KafkaUserV1Alpha1SpecAuthenticationPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'valueFrom': toJson_KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type.
 *
 * @schema KafkaUserV1Alpha1SpecAuthenticationType
 */
export enum KafkaUserV1Alpha1SpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** tls-external */
  TLS_HYPHEN_EXTERNAL = "tls-external",
  /** scram-sha-512 */
  SCRAM_HYPHEN_SHA_HYPHEN_512 = "scram-sha-512",
}

/**
 * @schema KafkaUserV1Alpha1SpecAuthorizationAcls
 */
export interface KafkaUserV1Alpha1SpecAuthorizationAcls {
  /**
   * The host from which the action described in the ACL rule is allowed or denied.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAcls#host
   */
  readonly host?: string;

  /**
   * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAcls#operation
   */
  readonly operation?: KafkaUserV1Alpha1SpecAuthorizationAclsOperation;

  /**
   * List of operations which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAcls#operations
   */
  readonly operations?: KafkaUserV1Alpha1SpecAuthorizationAclsOperations[];

  /**
   * Indicates the resource for which given ACL rule applies.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAcls#resource
   */
  readonly resource: KafkaUserV1Alpha1SpecAuthorizationAclsResource;

  /**
   * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAcls#type
   */
  readonly type?: KafkaUserV1Alpha1SpecAuthorizationAclsType;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthorizationAcls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthorizationAcls(obj: KafkaUserV1Alpha1SpecAuthorizationAcls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'operation': obj.operation,
    'operations': obj.operations?.map(y => y),
    'resource': toJson_KafkaUserV1Alpha1SpecAuthorizationAclsResource(obj.resource),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationType
 */
export enum KafkaUserV1Alpha1SpecAuthorizationType {
  /** simple */
  SIMPLE = "simple",
}

/**
 * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
 *
 * @schema KafkaUserV1Alpha1SpecTemplateSecret
 */
export interface KafkaUserV1Alpha1SpecTemplateSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaUserV1Alpha1SpecTemplateSecret#metadata
   */
  readonly metadata?: KafkaUserV1Alpha1SpecTemplateSecretMetadata;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecTemplateSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecTemplateSecret(obj: KafkaUserV1Alpha1SpecTemplateSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaUserV1Alpha1SpecTemplateSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret from which the password should be read.
 *
 * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom
 */
export interface KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom {
  /**
   * Selects a key of a Secret in the resource's namespace.
   *
   * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom(obj: KafkaUserV1Alpha1SpecAuthenticationPasswordValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsOperation
 */
export enum KafkaUserV1Alpha1SpecAuthorizationAclsOperation {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsOperations
 */
export enum KafkaUserV1Alpha1SpecAuthorizationAclsOperations {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * Indicates the resource for which given ACL rule applies.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResource
 */
export interface KafkaUserV1Alpha1SpecAuthorizationAclsResource {
  /**
   * Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResource#name
   */
  readonly name?: string;

  /**
   * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResource#patternType
   */
  readonly patternType?: KafkaUserV1Alpha1SpecAuthorizationAclsResourcePatternType;

  /**
   * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
   *
   * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResource#type
   */
  readonly type: KafkaUserV1Alpha1SpecAuthorizationAclsResourceType;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthorizationAclsResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthorizationAclsResource(obj: KafkaUserV1Alpha1SpecAuthorizationAclsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patternType': obj.patternType,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsType
 */
export enum KafkaUserV1Alpha1SpecAuthorizationAclsType {
  /** allow */
  ALLOW = "allow",
  /** deny */
  DENY = "deny",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaUserV1Alpha1SpecTemplateSecretMetadata
 */
export interface KafkaUserV1Alpha1SpecTemplateSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserV1Alpha1SpecTemplateSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserV1Alpha1SpecTemplateSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecTemplateSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecTemplateSecretMetadata(obj: KafkaUserV1Alpha1SpecTemplateSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the resource's namespace.
 *
 * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef
 */
export interface KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef {
  /**
   * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef(obj: KafkaUserV1Alpha1SpecAuthenticationPasswordValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResourcePatternType
 */
export enum KafkaUserV1Alpha1SpecAuthorizationAclsResourcePatternType {
  /** literal */
  LITERAL = "literal",
  /** prefix */
  PREFIX = "prefix",
}

/**
 * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
 *
 * @schema KafkaUserV1Alpha1SpecAuthorizationAclsResourceType
 */
export enum KafkaUserV1Alpha1SpecAuthorizationAclsResourceType {
  /** topic */
  TOPIC = "topic",
  /** group */
  GROUP = "group",
  /** cluster */
  CLUSTER = "cluster",
  /** transactionalId */
  TRANSACTIONAL_ID = "transactionalId",
}

