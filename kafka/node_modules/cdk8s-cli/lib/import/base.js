"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportBase = exports.Language = void 0;
const path = __importStar(require("path"));
const codemaker_1 = require("codemaker");
const fs = __importStar(require("fs-extra"));
const srcmak = __importStar(require("jsii-srcmak"));
const util_1 = require("../util");
var Language;
(function (Language) {
    Language["TYPESCRIPT"] = "typescript";
    Language["PYTHON"] = "python";
    Language["DOTNET"] = "dotnet";
    Language["JAVA"] = "java";
    Language["GO"] = "go";
})(Language = exports.Language || (exports.Language = {}));
class ImportBase {
    async import(options) {
        const code = new codemaker_1.CodeMaker();
        const outdir = path.resolve(options.outdir);
        await fs.mkdirp(outdir);
        const isTypescript = options.targetLanguage === Language.TYPESCRIPT;
        const { moduleNamePrefix } = options;
        if (this.moduleNames.length === 0) {
            console.error('warning: no definitions to import');
        }
        const mapFunc = (origName) => {
            let name = origName;
            switch (options.targetLanguage) {
                case Language.PYTHON:
                case Language.JAVA:
                    name = name.split('.').reverse().join('.');
                    break;
            }
            return {
                origName: origName,
                name: name,
            };
        };
        // sort to ensure python writes parent packages first, so children are not deleted
        const modules = this.moduleNames.map(mapFunc).sort((a, b) => a.name.localeCompare(b.name));
        for (const module of modules) {
            // output the name of the imported resource
            console.log(module.origName);
            const fileName = moduleNamePrefix ? `${moduleNamePrefix}-${module.name}.ts` : `${module.name}.ts`;
            code.openFile(fileName);
            code.indentation = 2;
            await this.generateTypeScript(code, module.origName, {
                classNamePrefix: options.classNamePrefix,
            });
            code.closeFile(fileName);
            if (isTypescript) {
                await code.save(outdir);
            }
            if (!isTypescript || options.outputJsii) {
                await (0, util_1.mkdtemp)(async (staging) => {
                    // this is not typescript, so we generate in a staging directory and
                    // use jsii-srcmak to compile and extract the language-specific source
                    // into our project.
                    await code.save(staging);
                    // these are the module dependencies we compile against
                    const deps = ['@types/node', 'constructs', 'cdk8s'];
                    const opts = {
                        entrypoint: fileName,
                        moduleKey: moduleNamePrefix ? `${moduleNamePrefix}_${module.name}` : module.name,
                        deps: deps.map(dep => path.dirname(require.resolve(`${dep}/package.json`))),
                    };
                    // used for testing.
                    if (options.outputJsii) {
                        opts.jsii = { path: options.outputJsii };
                    }
                    // python!
                    if (options.targetLanguage === Language.PYTHON) {
                        const moduleName = `${moduleNamePrefix ? `${moduleNamePrefix}.${module.name}` : module.name}`.replace(/-/g, '_');
                        opts.python = {
                            outdir: outdir,
                            moduleName,
                        };
                    }
                    // java!
                    if (options.targetLanguage === Language.JAVA) {
                        const javaName = module.name.replace(/\//g, '.').replace(/-/g, '_');
                        opts.java = {
                            outdir: '.',
                            package: `imports.${moduleNamePrefix ? moduleNamePrefix + '.' + javaName : javaName}`,
                        };
                    }
                    // go!
                    if (options.targetLanguage === Language.GO) {
                        const { userModuleName, userModulePath } = this.getGoModuleName(outdir);
                        const relativeDir = path.relative(userModulePath, outdir);
                        // go package names may only consist of letters or digits.
                        // underscores are allowed too, but they are less idiomatic
                        // this converts e.g. "cert-manager.path.to.url" to "certmanagerpathtourl"
                        const importModuleName = module.name.replace(/[^A-Za-z0-9]/g, '').toLocaleLowerCase();
                        opts.golang = {
                            outdir: outdir,
                            moduleName: `${userModuleName}/${relativeDir}`,
                            packageName: moduleNamePrefix ? moduleNamePrefix + '_' + importModuleName : importModuleName,
                        };
                    }
                    await srcmak.srcmak(staging, opts);
                });
            }
        }
    }
    /**
     * Traverses up directories until it finds a directory with a go.mod file,
     * and parses the module name from the file.
     */
    getGoModuleName(origOutdir) {
        let outdir = path.resolve(origOutdir);
        while (outdir !== path.dirname(outdir)) {
            const file = path.join(outdir, 'go.mod');
            if (fs.existsSync(file)) {
                const contents = fs.readFileSync(file, 'utf8');
                const matches = /module (.*)/.exec(contents);
                if (!matches) {
                    throw new Error('Invalid go.mod file - could not find module path.');
                }
                return {
                    userModuleName: matches[1],
                    userModulePath: outdir,
                };
            }
            outdir = path.dirname(outdir);
        }
        throw new Error(`Cannot find go.mod file within ${origOutdir} or any of its parent directories.`);
    }
}
exports.ImportBase = ImportBase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbXBvcnQvYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3Qix5Q0FBc0M7QUFDdEMsNkNBQStCO0FBQy9CLG9EQUFzQztBQUN0QyxrQ0FBa0M7QUFFbEMsSUFBWSxRQU1YO0FBTkQsV0FBWSxRQUFRO0lBQ2xCLHFDQUF5QixDQUFBO0lBQ3pCLDZCQUFpQixDQUFBO0lBQ2pCLDZCQUFpQixDQUFBO0lBQ2pCLHlCQUFhLENBQUE7SUFDYixxQkFBUyxDQUFBO0FBQ1gsQ0FBQyxFQU5XLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBTW5CO0FBMkJELE1BQXNCLFVBQVU7SUFLdkIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFzQjtRQUN4QyxNQUFNLElBQUksR0FBRyxJQUFJLHFCQUFTLEVBQUUsQ0FBQztRQUU3QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDeEIsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGNBQWMsS0FBSyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBQ3BFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUVyQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNqQyxPQUFPLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7U0FDcEQ7UUFFRCxNQUFNLE9BQU8sR0FBRyxDQUFFLFFBQWdCLEVBQUcsRUFBRTtZQUNyQyxJQUFJLElBQUksR0FBRyxRQUFRLENBQUM7WUFDcEIsUUFBUSxPQUFPLENBQUMsY0FBYyxFQUFFO2dCQUM5QixLQUFLLFFBQVEsQ0FBQyxNQUFN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cGF0aCc7XG5pbXBvcnQgeyBDb2RlTWFrZXIgfSBmcm9tICdjb2RlbWFrZXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc3JjbWFrIGZyb20gJ2pzaWktc3JjbWFrJztcbmltcG9ydCB7IG1rZHRlbXAgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGVudW0gTGFuZ3VhZ2Uge1xuICBUWVBFU0NSSVBUID0gJ3R5cGVzY3JpcHQnLFxuICBQWVRIT04gPSAncHl0aG9uJyxcbiAgRE9UTkVUID0gJ2RvdG5ldCcsXG4gIEpBVkEgPSAnamF2YScsXG4gIEdPID0gJ2dvJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRPcHRpb25zIHtcbiAgcmVhZG9ubHkgbW9kdWxlTmFtZVByZWZpeD86IHN0cmluZztcbiAgcmVhZG9ubHkgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlO1xuICByZWFkb25seSBvdXRkaXI6IHN0cmluZztcbiAgcmVhZG9ubHkgc2F2ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gY29weSB0aGUgb3V0cHV0IC5qc2lpIGZpbGUuXG4gICAqIEBkZWZhdWx0IC0ganNpaSBmaWxlIGlzIG5vdCBlbWl0dGVkXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRKc2lpPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIHByZWZpeCBmb3IgYWxsIGNvbnN0cnVjdCBjbGFzc2VzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRlZmF1bHQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc3BlY2lmaWMgaW1wb3J0IHR5cGUuIEZvciBleGFtcGxlXG4gICAqIGs4cyBpbXBvcnRzIHdpbGwgYWRkIGEgXCJLdWJlXCIgcHJlZml4IGJ5IGRlZmF1bHQuXG4gICAqL1xuICByZWFkb25seSBjbGFzc05hbWVQcmVmaXg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVPcHRpb25zIHtcbiAgcmVhZG9ubHkgY2xhc3NOYW1lUHJlZml4Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW1wb3J0QmFzZSB7XG4gIHB1YmxpYyBhYnN0cmFjdCBnZXQgbW9kdWxlTmFtZXMoKTogc3RyaW5nW107XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdlbmVyYXRlVHlwZVNjcmlwdChjb2RlOiBDb2RlTWFrZXIsIG1vZHVsZU5hbWU6IHN0cmluZywgb3B0aW9uczogR2VuZXJhdGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICBwdWJsaWMgYXN5bmMgaW1wb3J0KG9wdGlvbnM6IEltcG9ydE9wdGlvbnMpIHtcbiAgICBjb25zdCBjb2RlID0gbmV3IENvZGVNYWtlcigpO1xuXG4gICAgY29uc3Qgb3V0ZGlyID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMub3V0ZGlyKTtcbiAgICBhd2FpdCBmcy5ta2RpcnAob3V0ZGlyKTtcbiAgICBjb25zdCBpc1R5cGVzY3JpcHQgPSBvcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5UWVBFU0NSSVBUO1xuICAgIGNvbnN0IHsgbW9kdWxlTmFtZVByZWZpeCB9ID0gb3B0aW9ucztcblxuICAgIGlmICh0aGlzLm1vZHVsZU5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignd2FybmluZzogbm8gZGVmaW5pdGlvbnMgdG8gaW1wb3J0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwRnVuYyA9ICggb3JpZ05hbWU6IHN0cmluZyApID0+IHtcbiAgICAgIGxldCBuYW1lID0gb3JpZ05hbWU7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UpIHtcbiAgICAgICAgY2FzZSBMYW5ndWFnZS5QWVRIT046XG4gICAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnLicpLnJldmVyc2UoKS5qb2luKCcuJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnTmFtZTogb3JpZ05hbWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBzb3J0IHRvIGVuc3VyZSBweXRob24gd3JpdGVzIHBhcmVudCBwYWNrYWdlcyBmaXJzdCwgc28gY2hpbGRyZW4gYXJlIG5vdCBkZWxldGVkXG4gICAgY29uc3QgbW9kdWxlcyA9IHRoaXMubW9kdWxlTmFtZXMubWFwKG1hcEZ1bmMpLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcblxuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgIC8vIG91dHB1dCB0aGUgbmFtZSBvZiB0aGUgaW1wb3J0ZWQgcmVzb3VyY2VcbiAgICAgIGNvbnNvbGUubG9nKG1vZHVsZS5vcmlnTmFtZSk7XG5cbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gbW9kdWxlTmFtZVByZWZpeCA/IGAke21vZHVsZU5hbWVQcmVmaXh9LSR7bW9kdWxlLm5hbWV9LnRzYCA6IGAke21vZHVsZS5uYW1lfS50c2A7XG4gICAgICBjb2RlLm9wZW5GaWxlKGZpbGVOYW1lKTtcbiAgICAgIGNvZGUuaW5kZW50YXRpb24gPSAyO1xuICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVTY3JpcHQoY29kZSwgbW9kdWxlLm9yaWdOYW1lLCB7XG4gICAgICAgIGNsYXNzTmFtZVByZWZpeDogb3B0aW9ucy5jbGFzc05hbWVQcmVmaXgsXG4gICAgICB9KTtcblxuICAgICAgY29kZS5jbG9zZUZpbGUoZmlsZU5hbWUpO1xuXG4gICAgICBpZiAoaXNUeXBlc2NyaXB0KSB7XG4gICAgICAgIGF3YWl0IGNvZGUuc2F2ZShvdXRkaXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVHlwZXNjcmlwdCB8fCBvcHRpb25zLm91dHB1dEpzaWkpIHtcbiAgICAgICAgYXdhaXQgbWtkdGVtcChhc3luYyBzdGFnaW5nID0+IHtcblxuICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHR5cGVzY3JpcHQsIHNvIHdlIGdlbmVyYXRlIGluIGEgc3RhZ2luZyBkaXJlY3RvcnkgYW5kXG4gICAgICAgICAgLy8gdXNlIGpzaWktc3JjbWFrIHRvIGNvbXBpbGUgYW5kIGV4dHJhY3QgdGhlIGxhbmd1YWdlLXNwZWNpZmljIHNvdXJjZVxuICAgICAgICAgIC8vIGludG8gb3VyIHByb2plY3QuXG4gICAgICAgICAgYXdhaXQgY29kZS5zYXZlKHN0YWdpbmcpO1xuXG4gICAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSBtb2R1bGUgZGVwZW5kZW5jaWVzIHdlIGNvbXBpbGUgYWdhaW5zdFxuICAgICAgICAgIGNvbnN0IGRlcHMgPSBbJ0B0eXBlcy9ub2RlJywgJ2NvbnN0cnVjdHMnLCAnY2RrOHMnXTtcblxuICAgICAgICAgIGNvbnN0IG9wdHM6IHNyY21hay5PcHRpb25zID0ge1xuICAgICAgICAgICAgZW50cnlwb2ludDogZmlsZU5hbWUsXG4gICAgICAgICAgICBtb2R1bGVLZXk6IG1vZHVsZU5hbWVQcmVmaXggPyBgJHttb2R1bGVOYW1lUHJlZml4fV8ke21vZHVsZS5uYW1lfWAgOiBtb2R1bGUubmFtZSxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMubWFwKGRlcCA9PiBwYXRoLmRpcm5hbWUocmVxdWlyZS5yZXNvbHZlKGAke2RlcH0vcGFja2FnZS5qc29uYCkpKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRKc2lpKSB7XG4gICAgICAgICAgICBvcHRzLmpzaWkgPSB7IHBhdGg6IG9wdGlvbnMub3V0cHV0SnNpaSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHB5dGhvbiFcbiAgICAgICAgICBpZiAob3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuUFlUSE9OKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVOYW1lID0gYCR7bW9kdWxlTmFtZVByZWZpeCA/IGAke21vZHVsZU5hbWVQcmVmaXh9LiR7bW9kdWxlLm5hbWV9YCA6IG1vZHVsZS5uYW1lfWAucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgICAgICAgICAgb3B0cy5weXRob24gPSB7XG4gICAgICAgICAgICAgIG91dGRpcjogb3V0ZGlyLFxuICAgICAgICAgICAgICBtb2R1bGVOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBqYXZhIVxuICAgICAgICAgIGlmIChvcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5KQVZBKSB7XG4gICAgICAgICAgICBjb25zdCBqYXZhTmFtZSA9IG1vZHVsZS5uYW1lLnJlcGxhY2UoL1xcLy9nLCAnLicpLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICAgICAgICAgIG9wdHMuamF2YSA9IHtcbiAgICAgICAgICAgICAgb3V0ZGlyOiAnLicsXG4gICAgICAgICAgICAgIHBhY2thZ2U6IGBpbXBvcnRzLiR7bW9kdWxlTmFtZVByZWZpeCA/IG1vZHVsZU5hbWVQcmVmaXggKyAnLicgKyBqYXZhTmFtZSA6IGphdmFOYW1lfWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGdvIVxuICAgICAgICAgIGlmIChvcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5HTykge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyTW9kdWxlTmFtZSwgdXNlck1vZHVsZVBhdGggfSA9IHRoaXMuZ2V0R29Nb2R1bGVOYW1lKG91dGRpcik7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZURpciA9IHBhdGgucmVsYXRpdmUodXNlck1vZHVsZVBhdGgsIG91dGRpcik7XG5cbiAgICAgICAgICAgIC8vIGdvIHBhY2thZ2UgbmFtZXMgbWF5IG9ubHkgY29uc2lzdCBvZiBsZXR0ZXJzIG9yIGRpZ2l0cy5cbiAgICAgICAgICAgIC8vIHVuZGVyc2NvcmVzIGFyZSBhbGxvd2VkIHRvbywgYnV0IHRoZXkgYXJlIGxlc3MgaWRpb21hdGljXG4gICAgICAgICAgICAvLyB0aGlzIGNvbnZlcnRzIGUuZy4gXCJjZXJ0LW1hbmFnZXIucGF0aC50by51cmxcIiB0byBcImNlcnRtYW5hZ2VycGF0aHRvdXJsXCJcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE1vZHVsZU5hbWUgPSBtb2R1bGUubmFtZS5yZXBsYWNlKC9bXkEtWmEtejAtOV0vZywgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIG9wdHMuZ29sYW5nID0ge1xuICAgICAgICAgICAgICBvdXRkaXI6IG91dGRpcixcbiAgICAgICAgICAgICAgbW9kdWxlTmFtZTogYCR7dXNlck1vZHVsZU5hbWV9LyR7cmVsYXRpdmVEaXJ9YCxcbiAgICAgICAgICAgICAgcGFja2FnZU5hbWU6IG1vZHVsZU5hbWVQcmVmaXggPyBtb2R1bGVOYW1lUHJlZml4ICsgJ18nICsgaW1wb3J0TW9kdWxlTmFtZSA6IGltcG9ydE1vZHVsZU5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHNyY21hay5zcmNtYWsoc3RhZ2luZywgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgZGlyZWN0b3JpZXMgdW50aWwgaXQgZmluZHMgYSBkaXJlY3Rvcnkgd2l0aCBhIGdvLm1vZCBmaWxlLFxuICAgKiBhbmQgcGFyc2VzIHRoZSBtb2R1bGUgbmFtZSBmcm9tIHRoZSBmaWxlLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRHb01vZHVsZU5hbWUob3JpZ091dGRpcjogc3RyaW5nKSB7XG4gICAgbGV0IG91dGRpciA9IHBhdGgucmVzb2x2ZShvcmlnT3V0ZGlyKTtcblxuICAgIHdoaWxlIChvdXRkaXIgIT09IHBhdGguZGlybmFtZShvdXRkaXIpKSB7XG4gICAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKG91dGRpciwgJ2dvLm1vZCcpO1xuXG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlKSkge1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gL21vZHVsZSAoLiopLy5leGVjKGNvbnRlbnRzKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ28ubW9kIGZpbGUgLSBjb3VsZCBub3QgZmluZCBtb2R1bGUgcGF0aC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlck1vZHVsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgdXNlck1vZHVsZVBhdGg6IG91dGRpcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3V0ZGlyID0gcGF0aC5kaXJuYW1lKG91dGRpcik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBnby5tb2QgZmlsZSB3aXRoaW4gJHtvcmlnT3V0ZGlyfSBvciBhbnkgb2YgaXRzIHBhcmVudCBkaXJlY3Rvcmllcy5gKTtcbiAgfVxufVxuIl19