"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeParseCrds = exports.ImportCustomResourceDefinition = exports.CustomResourceDefinition = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const ajv_1 = __importDefault(require("ajv"));
const codemaker_1 = require("codemaker");
const json2jsii_1 = require("json2jsii");
const base_1 = require("./base");
const codegen_1 = require("./codegen");
const reviver_1 = require("../reviver");
const util_1 = require("../util");
const CRD_KIND = 'CustomResourceDefinition';
// all these APIs are compatible from our perspective.
const SUPPORTED_API_VERSIONS = [
    'apiextensions.k8s.io/v1beta1',
    'apiextensions.k8s.io/v1',
];
class CustomResourceDefinition {
    constructor(manifest) {
        var _a, _b, _c;
        this.versions = [];
        const apiVersion = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.apiVersion) !== null && _a !== void 0 ? _a : 'undefined';
        assert(SUPPORTED_API_VERSIONS.includes(apiVersion), `"apiVersion" is "${apiVersion}" but it should be one of: ${SUPPORTED_API_VERSIONS.map(x => `"${x}"`).join(', ')}`);
        assert(manifest.kind === CRD_KIND, `"kind" must be "${CRD_KIND}"`);
        const spec = manifest.spec;
        if (!spec) {
            throw new Error('manifest does not have a "spec" attribute');
        }
        this.group = spec.group;
        this.kind = spec.names.kind;
        if (spec.version) {
            this.addVersions([{ name: spec.version, schema: (_b = spec.validation) === null || _b === void 0 ? void 0 : _b.openAPIV3Schema }]);
        }
        else {
            this.addVersions(((_c = spec.versions) !== null && _c !== void 0 ? _c : []).map(v => { var _a, _b, _c; return ({ name: v.name, schema: (_b = (_a = v.schema) === null || _a === void 0 ? void 0 : _a.openAPIV3Schema) !== null && _b !== void 0 ? _b : (_c = spec.validation) === null || _c === void 0 ? void 0 : _c.openAPIV3Schema }); }));
        }
        if (this.versions.length === 0) {
            throw new Error('unable to determine CRD versions');
        }
    }
    merge(crd) {
        this.addVersions(crd.versions);
    }
    addVersions(versions) {
        for (const v of versions) {
            const existingVersions = this.versions.map(ver => ver.name);
            if (existingVersions.includes(v.name)) {
                throw new Error(`Found multiple occurrences of version ${v.name} for ${this.key}`);
            }
            this.versions.push({ name: v.name, schema: v.schema });
        }
    }
    get key() {
        return `${this.group}/${this.kind.toLocaleLowerCase()}`;
    }
    async generateTypeScript(code, options) {
        for (let i = 0; i < this.versions.length; i++) {
            const version = this.versions[i];
            // to preseve backwards compatiblity, only append a suffix for
            // the second version onwards.
            const suffix = i === 0 ? '' : (0, codemaker_1.toPascalCase)(version.name);
            const types = new json2jsii_1.TypeGenerator({});
            (0, codegen_1.generateConstruct)(types, {
                group: this.group,
                version: version.name,
                kind: this.kind,
                fqn: `${this.kind}${suffix}`,
                schema: version.schema,
                custom: true,
                prefix: options.classNamePrefix,
                suffix,
            });
            code.line(types.render());
        }
    }
}
exports.CustomResourceDefinition = CustomResourceDefinition;
class ImportCustomResourceDefinition extends base_1.ImportBase {
    static async fromSpec(importSpec) {
        const { source } = importSpec;
        const manifest = await (0, util_1.download)(source);
        return new ImportCustomResourceDefinition(manifest);
    }
    constructor(rawManifest) {
        super();
        this.groups = {};
        this.rawManifest = rawManifest;
        const manifest = safeParseCrds(rawManifest);
        const crds = {};
        const groups = {};
        for (const spec of manifest) {
            const crd = new CustomResourceDefinition(spec);
            const key = crd.key;
            if (key in crds) {
                // might contain different versions - lets try to merge them in
                crds[key].merge(crd);
            }
            else {
                crds[key] = crd;
            }
        }
        //sort to ensure consistent ordering for snapshot compare
        const sortedCrds = Object.values(crds).sort((a, b) => a.key.localeCompare(b.key));
        for (const crd of sortedCrds) {
            const g = crd.group;
            if (!(g in groups)) {
                groups[g] = new Array();
            }
            groups[g].push(crd);
        }
        this.groups = groups;
    }
    get moduleNames() {
        return Object.keys(this.groups);
    }
    async generateTypeScript(code, moduleName, options) {
        const crds = this.groups[moduleName];
        (0, codegen_1.emitHeader)(code, true);
        for (const crd of crds) {
            console.log(`  ${crd.key}`);
            await crd.generateTypeScript(code, options);
        }
    }
}
exports.ImportCustomResourceDefinition = ImportCustomResourceDefinition;
function assert(condition, message) {
    if (!condition) {
        throw new Error(`invalid CustomResourceDefinition manifest: ${message}`);
    }
}
function safeParseCrds(manifest) {
    const schemaPath = path.join(__dirname, '..', 'schemas', 'crd.schema.json');
    const schema = JSON.parse(fs.readFileSync(schemaPath, { encoding: 'utf8' }));
    const reviver = new reviver_1.SafeReviver({
        sanitizers: [reviver_1.SafeReviver.DESCRIPTION_SANITIZER, reviver_1.SafeReviver.LEGAL_CHAR_SANITIZER],
    });
    // first parse and strip
    const objects = (0, util_1.safeParseYaml)(manifest, reviver);
    // since the manifest can contain non crds as well, we first
    // collect all crds and only apply a schema validation on them.
    const crds = [];
    function collectCRDs(objs) {
        for (const obj of objs.filter(o => o)) {
            if (obj.kind === CRD_KIND) {
                crds.push(obj);
            }
            if (obj.kind === 'List') {
                collectCRDs(obj.items);
            }
        }
    }
    collectCRDs(objects);
    const ajv = new ajv_1.default();
    const validate = ajv.compile(schema);
    const errors = [];
    for (const crd of crds) {
        validate(crd);
        if (validate.errors) {
            errors.push(...validate.errors);
        }
        ;
    }
    if (errors.length > 0) {
        throw new Error(`Schema validation errors detected\n ${errors.map(e => `* ${e.message}`).join('\n')}`);
    }
    return crds;
}
exports.safeParseCrds = safeParseCrds;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ltcG9ydC9jcmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLDhDQUFzQjtBQUN0Qix5Q0FBb0Q7QUFDcEQseUNBQTBDO0FBQzFDLGlDQUFxRDtBQUNyRCx1Q0FBMEQ7QUFFMUQsd0NBQXlDO0FBQ3pDLGtDQUFrRDtBQUVsRCxNQUFNLFFBQVEsR0FBRywwQkFBMEIsQ0FBQztBQTBCNUMsc0RBQXNEO0FBQ3RELE1BQU0sc0JBQXNCLEdBQUc7SUFDN0IsOEJBQThCO0lBQzlCLHlCQUF5QjtDQUMxQixDQUFDO0FBSUYsTUFBYSx3QkFBd0I7SUFPbkMsWUFBWSxRQUFrQzs7UUFKN0IsYUFBUSxHQUFzQyxFQUFFLENBQUM7UUFLaEUsTUFBTSxVQUFVLEdBQUcsTUFBQSxRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsVUFBVSxtQ0FBSSxXQUFXLENBQUM7UUFDdkQsTUFBTSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxvQkFBb0IsVUFBVSw4QkFBOEIsc0JBQXNCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEssTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLG1CQUFtQixRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBRW5FLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztTQUM5RDtRQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUss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SUFDSCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRXJCLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7SUFDdEIsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyQyxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbEIsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDdEIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFO1lBQ25CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFBQSxDQUFDO0tBQ0g7SUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDeEc7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUF6Q0Qsc0NBeUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBBanYgZnJvbSAnYWp2JztcbmltcG9ydCB7IENvZGVNYWtlciwgdG9QYXNjYWxDYXNlIH0gZnJvbSAnY29kZW1ha2VyJztcbmltcG9ydCB7IFR5cGVHZW5lcmF0b3IgfSBmcm9tICdqc29uMmpzaWknO1xuaW1wb3J0IHsgR2VuZXJhdGVPcHRpb25zLCBJbXBvcnRCYXNlIH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IGVtaXRIZWFkZXIsIGdlbmVyYXRlQ29uc3RydWN0IH0gZnJvbSAnLi9jb2RlZ2VuJztcbmltcG9ydCB7IEltcG9ydFNwZWMgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgU2FmZVJldml2ZXIgfSBmcm9tICcuLi9yZXZpdmVyJztcbmltcG9ydCB7IGRvd25sb2FkLCBzYWZlUGFyc2VZYW1sIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IENSRF9LSU5EID0gJ0N1c3RvbVJlc291cmNlRGVmaW5pdGlvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFuaWZlc3RPYmplY3REZWZpbml0aW9uIHtcbiAgYXBpVmVyc2lvbj86IHN0cmluZztcbiAga2luZD86IHN0cmluZztcbiAgaXRlbXM/OiBNYW5pZmVzdE9iamVjdERlZmluaXRpb25bXTsgLy8gaWYgYGtpbmRgIGlzIFwiTGlzdFwiXG4gIG1ldGFkYXRhPzoge1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gIH07XG4gIHNwZWM/OiB7XG4gICAgZ3JvdXA6IHN0cmluZztcbiAgICBuYW1lczoge1xuICAgICAga2luZDogc3RyaW5nO1xuICAgICAgW2tleTogc3RyaW5nXTogYW55O1xuICAgIH07XG4gICAgdmVyc2lvbnM/OiBBcnJheTx7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBzY2hlbWE/OiB7IG9wZW5BUElWM1NjaGVtYT86IGFueSB9O1xuICAgICAgW2tleTogc3RyaW5nXTogYW55O1xuICAgIH0+O1xuICAgIHZlcnNpb24/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbj86IHsgb3BlbkFQSVYzU2NoZW1hPzogYW55IH07XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICB9O1xufVxuXG4vLyBhbGwgdGhlc2UgQVBJcyBhcmUgY29tcGF0aWJsZSBmcm9tIG91ciBwZXJzcGVjdGl2ZS5cbmNvbnN0IFNVUFBPUlRFRF9BUElfVkVSU0lPTlMgPSBbXG4gICdhcGlleHRlbnNpb25zLms4cy5pby92MWJldGExJyxcbiAgJ2FwaWV4dGVuc2lvbnMuazhzLmlvL3YxJyxcbl07XG5cbnR5cGUgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbiA9IHsgbmFtZTogc3RyaW5nOyBzY2hlbWE/OiBhbnkgfTtcblxuZXhwb3J0IGNsYXNzIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBraW5kOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgdmVyc2lvbnM6IEN1c3RvbVJlc291cmNlRGVmaW5pdGlvblZlcnNpb25bXSA9IFtdO1xuXG4gIHB1YmxpYyByZWFkb25seSBncm91cDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG1hbmlmZXN0OiBNYW5pZmVzdE9iamVjdERlZmluaXRpb24pIHtcbiAgICBjb25zdCBhcGlWZXJzaW9uID0gbWFuaWZlc3Q/LmFwaVZlcnNpb24gPz8gJ3VuZGVmaW5lZCc7XG4gICAgYXNzZXJ0KFNVUFBPUlRFRF9BUElfVkVSU0lPTlMuaW5jbHVkZXMoYXBpVmVyc2lvbiksIGBcImFwaVZlcnNpb25cIiBpcyBcIiR7YXBpVmVyc2lvbn1cIiBidXQgaXQgc2hvdWxkIGJlIG9uZSBvZjogJHtTVVBQT1JURURfQVBJX1ZFUlNJT05TLm1hcCh4ID0+IGBcIiR7eH1cImApLmpvaW4oJywgJyl9YCk7XG4gICAgYXNzZXJ0KG1hbmlmZXN0LmtpbmQgPT09IENSRF9LSU5ELCBgXCJraW5kXCIgbXVzdCBiZSBcIiR7Q1JEX0tJTkR9XCJgKTtcblxuICAgIGNvbnN0IHNwZWMgPSBtYW5pZmVzdC5zcGVjO1xuICAgIGlmICghc3BlYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW5pZmVzdCBkb2VzIG5vdCBoYXZlIGEgXCJzcGVjXCIgYXR0cmlidXRlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5ncm91cCA9IHNwZWMuZ3JvdXA7XG4gICAgdGhpcy5raW5kID0gc3BlYy5uYW1lcy5raW5kO1xuXG4gICAgaWYgKHNwZWMudmVyc2lvbikge1xuICAgICAgdGhpcy5hZGRWZXJzaW9ucyhbeyBuYW1lOiBzcGVjLnZlcnNpb24sIHNjaGVtYTogc3BlYy52YWxpZGF0aW9uPy5vcGVuQVBJVjNTY2hlbWEgfV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFZlcnNpb25zKChzcGVjLnZlcnNpb25zID8/IFtdKS5tYXAodiA9PiAoeyBuYW1lOiB2Lm5hbWUsIHNjaGVtYTogdi5zY2hlbWE/Lm9wZW5BUElWM1NjaGVtYSA/PyBzcGVjLnZhbGlkYXRpb24/Lm9wZW5BUElWM1NjaGVtYSB9KSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZlcnNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGV0ZXJtaW5lIENSRCB2ZXJzaW9ucycpO1xuICAgIH1cblxuICB9XG5cbiAgcHVibGljIG1lcmdlKGNyZDogQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uKSB7XG4gICAgdGhpcy5hZGRWZXJzaW9ucyhjcmQudmVyc2lvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRWZXJzaW9ucyh2ZXJzaW9uczogQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uVmVyc2lvbltdKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHZlcnNpb25zKSB7XG4gICAgICBjb25zdCBleGlzdGluZ1ZlcnNpb25zID0gdGhpcy52ZXJzaW9ucy5tYXAodmVyID0+IHZlci5uYW1lKTtcbiAgICAgIGlmIChleGlzdGluZ1ZlcnNpb25zLmluY2x1ZGVzKHYubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBtdWx0aXBsZSBvY2N1cnJlbmNlcyBvZiB2ZXJzaW9uICR7di5uYW1lfSBmb3IgJHt0aGlzLmtleX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmVyc2lvbnMucHVzaCh7IG5hbWU6IHYubmFtZSwgc2NoZW1hOiB2LnNjaGVtYSB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGtleSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5ncm91cH0vJHt0aGlzLmtpbmQudG9Mb2NhbGVMb3dlckNhc2UoKX1gO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlVHlwZVNjcmlwdChjb2RlOiBDb2RlTWFrZXIsIG9wdGlvbnM6IEdlbmVyYXRlT3B0aW9ucykge1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnZlcnNpb25zW2ldO1xuXG4gICAgICAvLyB0byBwcmVzZXZlIGJhY2t3YXJkcyBjb21wYXRpYmxpdHksIG9ubHkgYXBwZW5kIGEgc3VmZml4IGZvclxuICAgICAgLy8gdGhlIHNlY29uZCB2ZXJzaW9uIG9ud2FyZHMuXG4gICAgICBjb25zdCBzdWZmaXggPSBpID09PSAwID8gJycgOiB0b1Bhc2NhbENhc2UodmVyc2lvbi5uYW1lKTtcblxuICAgICAgY29uc3QgdHlwZXMgPSBuZXcgVHlwZUdlbmVyYXRvcih7fSk7XG5cbiAgICAgIGdlbmVyYXRlQ29uc3RydWN0KHR5cGVzLCB7XG4gICAgICAgIGdyb3VwOiB0aGlzLmdyb3VwLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLm5hbWUsXG4gICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgZnFuOiBgJHt0aGlzLmtpbmR9JHtzdWZmaXh9YCxcbiAgICAgICAgc2NoZW1hOiB2ZXJzaW9uLnNjaGVtYSxcbiAgICAgICAgY3VzdG9tOiB0cnVlLFxuICAgICAgICBwcmVmaXg6IG9wdGlvbnMuY2xhc3NOYW1lUHJlZml4LFxuICAgICAgICBzdWZmaXgsXG4gICAgICB9KTtcblxuICAgICAgY29kZS5saW5lKHR5cGVzLnJlbmRlcigpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEltcG9ydEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiBleHRlbmRzIEltcG9ydEJhc2Uge1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZyb21TcGVjKGltcG9ydFNwZWM6IEltcG9ydFNwZWMpOiBQcm9taXNlPEltcG9ydEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbj4ge1xuICAgIGNvbnN0IHsgc291cmNlIH0gPSBpbXBvcnRTcGVjO1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgZG93bmxvYWQoc291cmNlKTtcbiAgICByZXR1cm4gbmV3IEltcG9ydEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbihtYW5pZmVzdCk7XG4gIH1cblxuICBwdWJsaWMgcmVhZG9ubHkgcmF3TWFuaWZlc3Q6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBncm91cHM6IFJlY29yZDxzdHJpbmcsIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbltdPiA9IHsgfTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHJhd01hbmlmZXN0OiBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5yYXdNYW5pZmVzdCA9IHJhd01hbmlmZXN0O1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gc2FmZVBhcnNlQ3JkcyhyYXdNYW5pZmVzdCk7XG5cbiAgICBjb25zdCBjcmRzOiBSZWNvcmQ8c3RyaW5nLCBDdXN0b21SZXNvdXJjZURlZmluaXRpb24+ID0geyB9O1xuICAgIGNvbnN0IGdyb3VwczogUmVjb3JkPHN0cmluZywgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uW10+ID0geyB9O1xuXG4gICAgZm9yIChjb25zdCBzcGVjIG9mIG1hbmlmZXN0KSB7XG4gICAgICBjb25zdCBjcmQgPSBuZXcgQ3VzdG9tUmVzb3VyY2VEZWZpbml0aW9uKHNwZWMpO1xuICAgICAgY29uc3Qga2V5ID0gY3JkLmtleTtcblxuICAgICAgaWYgKGtleSBpbiBjcmRzKSB7XG4gICAgICAgIC8vIG1pZ2h0IGNvbnRhaW4gZGlmZmVyZW50IHZlcnNpb25zIC0gbGV0cyB0cnkgdG8gbWVyZ2UgdGhlbSBpblxuICAgICAgICBjcmRzW2tleV0ubWVyZ2UoY3JkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZHNba2V5XSA9IGNyZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3NvcnQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgb3JkZXJpbmcgZm9yIHNuYXBzaG90IGNvbXBhcmVcbiAgICBjb25zdCBzb3J0ZWRDcmRzID0gT2JqZWN0LnZhbHVlcyhjcmRzKS5zb3J0KChhOiBDdXN0b21SZXNvdXJjZURlZmluaXRpb24sIGI6IEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbikgPT4gYS5rZXkubG9jYWxlQ29tcGFyZShiLmtleSkpO1xuXG4gICAgZm9yIChjb25zdCBjcmQgb2Ygc29ydGVkQ3Jkcykge1xuICAgICAgY29uc3QgZyA9IGNyZC5ncm91cDtcbiAgICAgIGlmICggIShnIGluIGdyb3VwcykgKSB7XG4gICAgICAgIGdyb3Vwc1tnXSA9IG5ldyBBcnJheTxDdXN0b21SZXNvdXJjZURlZmluaXRpb24+KCk7XG4gICAgICB9XG4gICAgICBncm91cHNbZ10ucHVzaChjcmQpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICB9XG5cbiAgcHVibGljIGdldCBtb2R1bGVOYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ncm91cHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdlbmVyYXRlVHlwZVNjcmlwdChjb2RlOiBDb2RlTWFrZXIsIG1vZHVsZU5hbWU6IHN0cmluZywgb3B0aW9uczogR2VuZXJhdGVPcHRpb25zKSB7XG4gICAgY29uc3QgY3JkcyA9IHRoaXMuZ3JvdXBzW21vZHVsZU5hbWVdO1xuXG5cbiAgICBlbWl0SGVhZGVyKGNvZGUsIHRydWUpO1xuXG4gICAgZm9yIChjb25zdCBjcmQgb2YgY3Jkcykge1xuICAgICAgY29uc29sZS5sb2coYCAgJHtjcmQua2V5fWApO1xuICAgICAgYXdhaXQgY3JkLmdlbmVyYXRlVHlwZVNjcmlwdChjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbjogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIEN1c3RvbVJlc291cmNlRGVmaW5pdGlvbiBtYW5pZmVzdDogJHttZXNzYWdlfWApO1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVQYXJzZUNyZHMobWFuaWZlc3Q6IHN0cmluZyk6IE1hbmlmZXN0T2JqZWN0RGVmaW5pdGlvbltdIHtcbiAgY29uc3Qgc2NoZW1hUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICdzY2hlbWFzJywgJ2NyZC5zY2hlbWEuanNvbicpO1xuICBjb25zdCBzY2hlbWEgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhzY2hlbWFQYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSkpO1xuICBjb25zdCByZXZpdmVyID0gbmV3IFNhZmVSZXZpdmVyKHtcbiAgICBzYW5pdGl6ZXJzOiBbU2FmZVJldml2ZXIuREVTQ1JJUFRJT05fU0FOSVRJWkVSLCBTYWZlUmV2aXZlci5MRUdBTF9DSEFSX1NBTklUSVpFUl0sXG4gIH0pO1xuXG4gIC8vIGZpcnN0IHBhcnNlIGFuZCBzdHJpcFxuICBjb25zdCBvYmplY3RzID0gc2FmZVBhcnNlWWFtbChtYW5pZmVzdCwgcmV2aXZlcik7XG5cbiAgLy8gc2luY2UgdGhlIG1hbmlmZXN0IGNhbiBjb250YWluIG5vbiBjcmRzIGFzIHdlbGwsIHdlIGZpcnN0XG4gIC8vIGNvbGxlY3QgYWxsIGNyZHMgYW5kIG9ubHkgYXBwbHkgYSBzY2hlbWEgdmFsaWRhdGlvbiBvbiB0aGVtLlxuXG4gIGNvbnN0IGNyZHM6IGFueVtdID0gW107XG5cbiAgZnVuY3Rpb24gY29sbGVjdENSRHMob2JqczogYW55W10pIHtcbiAgICBmb3IgKGNvbnN0IG9iaiBvZiBvYmpzLmZpbHRlcihvID0+IG8pKSB7XG4gICAgICBpZiAob2JqLmtpbmQgPT09IENSRF9LSU5EKSB7XG4gICAgICAgIGNyZHMucHVzaChvYmopO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5raW5kID09PSAnTGlzdCcpIHtcbiAgICAgICAgY29sbGVjdENSRHMob2JqLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb2xsZWN0Q1JEcyhvYmplY3RzKTtcblxuICBjb25zdCBhanYgPSBuZXcgQWp2KCk7XG4gIGNvbnN0IHZhbGlkYXRlID0gYWp2LmNvbXBpbGUoc2NoZW1hKTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGZvciAoY29uc3QgY3JkIG9mIGNyZHMpIHtcbiAgICB2YWxpZGF0ZShjcmQpO1xuICAgIGlmICh2YWxpZGF0ZS5lcnJvcnMpIHtcbiAgICAgIGVycm9ycy5wdXNoKC4uLnZhbGlkYXRlLmVycm9ycyk7XG4gICAgfTtcbiAgfVxuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSB2YWxpZGF0aW9uIGVycm9ycyBkZXRlY3RlZFxcbiAke2Vycm9ycy5tYXAoZSA9PiBgKiAke2UubWVzc2FnZX1gKS5qb2luKCdcXG4nKX1gKTtcbiAgfVxuICByZXR1cm4gY3Jkcztcbn1cbiJdfQ==