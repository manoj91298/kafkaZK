"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeReviver = void 0;
/**
 * JSON/YAML reviver that:
 *
 * - Throws when an illegal key is detected.
 * - Replaces illegal values with a special marker.
 */
class SafeReviver {
    constructor(props) {
        var _a, _b;
        this.allowlistedKeys = (_a = props === null || props === void 0 ? void 0 : props.allowlistedKeys) !== null && _a !== void 0 ? _a : [];
        this.sanitizers = (_b = props === null || props === void 0 ? void 0 : props.sanitizers) !== null && _b !== void 0 ? _b : [];
    }
    sanitizeValue(path, value) {
        for (const sanitizer of this.sanitizers) {
            const { applied, sanitized } = sanitizer(path, value);
            if (applied) {
                return sanitized;
            }
        }
        return value;
    }
    /**
     * Sanitizes a JSON object in-place.
     */
    sanitize(obj) {
        if (obj == null)
            return;
        this._sanitizeObj([], obj);
    }
    _sanitizeObj(path, partialObj) {
        for (const [key, value] of Object.entries(partialObj)) {
            if (typeof (key) !== 'string') {
                throw new Error(`Expected key (${key}) to be of type 'string', but got '${typeof (key)}'`);
            }
            if (!this.allowlistedKeys.includes(key) && !SafeReviver.LEGAL_CHARS.test(key)) {
                // keys cannot be stripped so we have to throw - thats ok, we don't want to parse such docs at all
                throw new Error(`Key '${key}' contains non standard characters (Must match regex '${SafeReviver.LEGAL_CHARS}')`);
            }
            const childPath = path.concat([key]);
            if (typeof (value) === 'string') {
                partialObj[key] = this.sanitizeValue(childPath, value);
            }
            else if (typeof (value) === 'object' && value !== null) {
                this._sanitizeObj(childPath, value); // recursive call
            }
        }
    }
}
exports.SafeReviver = SafeReviver;
// . | used in resource fqn which servers as a key (e.g io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup)
// / | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// - | used in annotation keys (e.g x-kubernetes-group-version-kind)
// # | used in $ref to point to a definition (e.g #/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
// , | used in values that represent a list (e.g merge,retainKeys)
// + | used in values representing MIME types (e.g application/json-patch+json)
// : | used in e.g. Prometheus events (e.g run:completed)
// * | used in e.g. AWS policies (e.g s3:ObjectCreated:*)
SafeReviver.LEGAL_CHARS = /^(\w|\.|\/|-|#|,)*$/;
SafeReviver.LEGAL_CHARS_IN_ENUM = /^( |\w|\.|\/|-|#|,|\+|:|\*|!|=|~)*$/;
// the string we use as the stripped value
SafeReviver.STRIPPED_VALUE = '__stripped_by_cdk8s__';
// remove characters from descriptions that might terminate the comment
SafeReviver.DESCRIPTION_SANITIZER = (path, value) => {
    if (path.length > 0 && path[path.length - 1] === 'description') {
        return { applied: true, sanitized: value.replace(/\*\//g, '_/') };
    }
    else {
        return { applied: false };
    }
};
// strip most illegal values
// the reason we don't throw is because sometimes these type of values exist in
// the original text for good reason, like for example a `jsonPath` key in a CRD manifest, and we don't
// want to fail the entire thing.
SafeReviver.LEGAL_CHAR_SANITIZER = (path, value) => {
    // case 1: we are in an array of enums
    if (path.length > 2 && path[path.length - 2] === 'enum' && /^\d+$/.test(path[path.length - 1])) {
        if (!SafeReviver.LEGAL_CHARS_IN_ENUM.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
        // case 2: default
    }
    else {
        if (!SafeReviver.LEGAL_CHARS.test(value)) {
            return { applied: true, sanitized: SafeReviver.STRIPPED_VALUE };
        }
        else {
            return { applied: false };
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV2aXZlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXZpdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQWNBOzs7OztHQUtHO0FBQ0gsTUFBYSxXQUFXO0lBc0R0QixZQUFZLEtBQXdCOztRQUNsQyxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQUEsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLGVBQWUsbUNBQUksRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsVUFBVSxtQ0FBSSxFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUVNLGFBQWEsQ0FBQyxJQUFjLEVBQUUsS0FBYTtRQUNoRCxLQUFLLE1BQU0sU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDdkMsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3RELElBQUksT0FBTyxFQUFFO2dCQUNYLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1NBQ0Y7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVEsQ0FBQyxHQUFRO1FBQ3RCLElBQUksR0FBRyxJQUFJLElBQUk7WUFBRSxPQUFPO1FBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBYyxFQUFFLFVBQWU7UUFDbEQsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDckQsSUFBSSxPQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixHQUFHLHNDQUFzQyxP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LENBQUM7U0FDM0I7S0FFRjtBQUNILENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHRoZSBwYXRoIHRvIGl0IHdpdGhpbiB0aGUgcGFyZW50IG9iamVjdCxcbiAqIGFuZCBlaXRoZXIgdHJhbnNmb3JtcyBpdCBvciBsZWF2ZXMgaXQgYWxvbmUuXG4gKi9cbmV4cG9ydCB0eXBlIFNhbml0aXplciA9IChwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IHN0cmluZykgPT4geyBhcHBsaWVkOiBib29sZWFuOyBzYW5pdGl6ZWQ/OiBzdHJpbmcgfTtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciAnU2FmZVJldml2ZXInLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhZmVSZXZpdmVyUHJvcHMge1xuICByZWFkb25seSBhbGxvd2xpc3RlZEtleXM/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgc2FuaXRpemVycz86IEFycmF5PFNhbml0aXplcj47XG59XG5cbi8qKlxuICogSlNPTi9ZQU1MIHJldml2ZXIgdGhhdDpcbiAqXG4gKiAtIFRocm93cyB3aGVuIGFuIGlsbGVnYWwga2V5IGlzIGRldGVjdGVkLlxuICogLSBSZXBsYWNlcyBpbGxlZ2FsIHZhbHVlcyB3aXRoIGEgc3BlY2lhbCBtYXJrZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYWZlUmV2aXZlciB7XG5cbiAgLy8gLiB8IHVzZWQgaW4gcmVzb3VyY2UgZnFuIHdoaWNoIHNlcnZlcnMgYXMgYSBrZXkgKGUuZyBpby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuQVBJR3JvdXApXG4gIC8vIC8gfCB1c2VkIGluICRyZWYgdG8gcG9pbnQgdG8gYSBkZWZpbml0aW9uIChlLmcgIy9kZWZpbml0aW9ucy9pby5rOHMuYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuR3JvdXBWZXJzaW9uRm9yRGlzY292ZXJ5KVxuICAvLyAtIHwgdXNlZCBpbiBhbm5vdGF0aW9uIGtleXMgKGUuZyB4LWt1YmVybmV0ZXMtZ3JvdXAtdmVyc2lvbi1raW5kKVxuICAvLyAjIHwgdXNlZCBpbiAkcmVmIHRvIHBvaW50IHRvIGEgZGVmaW5pdGlvbiAoZS5nICMvZGVmaW5pdGlvbnMvaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkdyb3VwVmVyc2lvbkZvckRpc2NvdmVyeSlcbiAgLy8gLCB8IHVzZWQgaW4gdmFsdWVzIHRoYXQgcmVwcmVzZW50IGEgbGlzdCAoZS5nIG1lcmdlLHJldGFpbktleXMpXG4gIC8vICsgfCB1c2VkIGluIHZhbHVlcyByZXByZXNlbnRpbmcgTUlNRSB0eXBlcyAoZS5nIGFwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvbilcbiAgLy8gOiB8IHVzZWQgaW4gZS5nLiBQcm9tZXRoZXVzIGV2ZW50cyAoZS5nIHJ1bjpjb21wbGV0ZWQpXG4gIC8vICogfCB1c2VkIGluIGUuZy4gQVdTIHBvbGljaWVzIChlLmcgczM6T2JqZWN0Q3JlYXRlZDoqKVxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExFR0FMX0NIQVJTID0gL14oXFx3fFxcLnxcXC98LXwjfCwpKiQvO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExFR0FMX0NIQVJTX0lOX0VOVU0gPSAvXiggfFxcd3xcXC58XFwvfC18I3wsfFxcK3w6fFxcKnwhfD18fikqJC87XG5cbiAgLy8gdGhlIHN0cmluZyB3ZSB1c2UgYXMgdGhlIHN0cmlwcGVkIHZhbHVlXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU1RSSVBQRURfVkFMVUUgPSAnX19zdHJpcHBlZF9ieV9jZGs4c19fJztcblxuICAvLyByZW1vdmUgY2hhcmFjdGVycyBmcm9tIGRlc2NyaXB0aW9ucyB0aGF0IG1pZ2h0IHRlcm1pbmF0ZSB0aGUgY29tbWVudFxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFU0NSSVBUSU9OX1NBTklUSVpFUjogU2FuaXRpemVyID0gKHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdkZXNjcmlwdGlvbicpIHtcbiAgICAgIHJldHVybiB7IGFwcGxpZWQ6IHRydWUsIHNhbml0aXplZDogdmFsdWUucmVwbGFjZSgvXFwqXFwvL2csICdfLycpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGFwcGxpZWQ6IGZhbHNlIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIHN0cmlwIG1vc3QgaWxsZWdhbCB2YWx1ZXNcbiAgLy8gdGhlIHJlYXNvbiB3ZSBkb24ndCB0aHJvdyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB0aGVzZSB0eXBlIG9mIHZhbHVlcyBleGlzdCBpblxuICAvLyB0aGUgb3JpZ2luYWwgdGV4dCBmb3IgZ29vZCByZWFzb24sIGxpa2UgZm9yIGV4YW1wbGUgYSBganNvblBhdGhgIGtleSBpbiBhIENSRCBtYW5pZmVzdCwgYW5kIHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZmFpbCB0aGUgZW50aXJlIHRoaW5nLlxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExFR0FMX0NIQVJfU0FOSVRJWkVSOiBTYW5pdGl6ZXIgPSAocGF0aDogc3RyaW5nW10sIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAvLyBjYXNlIDE6IHdlIGFyZSBpbiBhbiBhcnJheSBvZiBlbnVtc1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDIgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDJdID09PSAnZW51bScgJiYgL15cXGQrJC8udGVzdChwYXRoW3BhdGgubGVuZ3RoIC0gMV0pKSB7XG5cbiAgICAgIGlmICghU2FmZVJldml2ZXIuTEVHQUxfQ0hBUlNfSU5fRU5VTS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBhcHBsaWVkOiB0cnVlLCBzYW5pdGl6ZWQ6IFNhZmVSZXZpdmVyLlNUUklQUEVEX1ZBTFVFIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBhcHBsaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuXG4gICAgLy8gY2FzZSAyOiBkZWZhdWx0XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKCFTYWZlUmV2aXZlci5MRUdBTF9DSEFSUy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBhcHBsaWVkOiB0cnVlLCBzYW5pdGl6ZWQ6IFNhZmVSZXZpdmVyLlNUUklQUEVEX1ZBTFVFIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBhcHBsaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYWxsb3dsaXN0ZWRLZXlzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBzYW5pdGl6ZXJzOiBBcnJheTxTYW5pdGl6ZXI+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzPzogU2FmZVJldml2ZXJQcm9wcykge1xuICAgIHRoaXMuYWxsb3dsaXN0ZWRLZXlzID0gcHJvcHM/LmFsbG93bGlzdGVkS2V5cyA/PyBbXTtcbiAgICB0aGlzLnNhbml0aXplcnMgPSBwcm9wcz8uc2FuaXRpemVycyA/PyBbXTtcbiAgfVxuXG4gIHB1YmxpYyBzYW5pdGl6ZVZhbHVlKHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGNvbnN0IHNhbml0aXplciBvZiB0aGlzLnNhbml0aXplcnMpIHtcbiAgICAgIGNvbnN0IHsgYXBwbGllZCwgc2FuaXRpemVkIH0gPSBzYW5pdGl6ZXIocGF0aCwgdmFsdWUpO1xuICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgcmV0dXJuIHNhbml0aXplZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2FuaXRpemVzIGEgSlNPTiBvYmplY3QgaW4tcGxhY2UuXG4gICAqL1xuICBwdWJsaWMgc2FuaXRpemUob2JqOiBhbnkpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICB0aGlzLl9zYW5pdGl6ZU9iaihbXSwgb2JqKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Nhbml0aXplT2JqKHBhdGg6IHN0cmluZ1tdLCBwYXJ0aWFsT2JqOiBhbnkpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0aWFsT2JqKSkge1xuICAgICAgaWYgKHR5cGVvZihrZXkpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGtleSAoJHtrZXl9KSB0byBiZSBvZiB0eXBlICdzdHJpbmcnLCBidXQgZ290ICcke3R5cGVvZihrZXkpfSdgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmFsbG93bGlzdGVkS2V5cy5pbmNsdWRlcyhrZXkpICYmICFTYWZlUmV2aXZlci5MRUdBTF9DSEFSUy50ZXN0KGtleSkpIHtcbiAgICAgICAgLy8ga2V5cyBjYW5ub3QgYmUgc3RyaXBwZWQgc28gd2UgaGF2ZSB0byB0aHJvdyAtIHRoYXRzIG9rLCB3ZSBkb24ndCB3YW50IHRvIHBhcnNlIHN1Y2ggZG9jcyBhdCBhbGxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJyR7a2V5fScgY29udGFpbnMgbm9uIHN0YW5kYXJkIGNoYXJhY3RlcnMgKE11c3QgbWF0Y2ggcmVnZXggJyR7U2FmZVJldml2ZXIuTEVHQUxfQ0hBUlN9JylgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoW2tleV0pO1xuXG4gICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFydGlhbE9ialtrZXldID0gdGhpcy5zYW5pdGl6ZVZhbHVlKGNoaWxkUGF0aCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zYW5pdGl6ZU9iaihjaGlsZFBhdGgsIHZhbHVlKTsgLy8gcmVjdXJzaXZlIGNhbGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==