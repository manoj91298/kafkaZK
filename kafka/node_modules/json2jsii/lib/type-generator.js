"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenerator = void 0;
const camelcase_1 = __importDefault(require("camelcase"));
const snake_case_1 = require("snake-case");
const allowlist_1 = require("./allowlist");
const code_1 = require("./code");
const tojson_1 = require("./tojson");
const PRIMITIVE_TYPES = ['string', 'number', 'integer', 'boolean'];
const DEFINITIONS_PREFIX = '#/definitions/';
const DEFAULT_RENDER_TYPE_NAME = (s) => s.split('.').map(x => pascalCase(x)).join('');
/**
 * Generates typescript types from JSON schemas.
 */
class TypeGenerator {
    /**
     * Convert all-caps acronyms (e.g. "VPC", "FooBARZooFIGoo") to pascal case
     * (e.g. "Vpc", "FooBarZooFiGoo").
     */
    static normalizeTypeName(typeName) {
        // Handle kebab-case first
        const stage1 = typeName.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
        // start with the full string and then use the regex to match all-caps sequences.
        const re = /([A-Z]+)(?:[^a-z]|$)/g;
        let result = stage1;
        let m;
        do {
            m = re.exec(stage1);
            if (m) {
                const before = result.slice(0, m.index); // all the text before the sequence
                const cap = m[1]; // group #1 matches the all-caps sequence we are after
                const pascal = cap[0] + cap.slice(1).toLowerCase(); // convert to pascal case by lowercasing all but the first char
                const after = result.slice(m.index + pascal.length); // all the text after the sequence
                result = before + pascal + after; // concat
            }
        } while (m);
        result = result.replace(/^./, result[0].toUpperCase()); // ensure first letter is capitalized
        return result;
    }
    /**
     * Renders a JSII struct (and accompanying types) from a JSON schema.
     *
     * If you wish to render multiple top-level structs or include custom types,
     * create a new instance of `TypeGenerator` manually.
     *
     * @param structName The name of the JSII struct (TypeScript interface).
     * @param schema The JSON schema (top level schema must include "properties")
     * @returns Generated TypeScript source code that includes the top-level
     * struct and all other types.
     */
    static forStruct(structName, schema, options = {}) {
        const gen = new TypeGenerator({ definitions: schema.definitions, ...options });
        gen.emitType(structName, schema);
        return gen;
    }
    /**
     *
     * @param schema Schema definitions
     * @param options
     */
    constructor(options = {}) {
        var _a, _b, _c, _d, _e;
        this.typesToEmit = {};
        this.emittedTypes = {};
        this.exclude = (_a = options.exclude) !== null && _a !== void 0 ? _a : [];
        this.definitions = {};
        this.toJson = (_b = options.toJson) !== null && _b !== void 0 ? _b : true;
        this.sanitizeEnums = (_c = options.sanitizeEnums) !== null && _c !== void 0 ? _c : false;
        this.renderTypeName = (_d = options.renderTypeName) !== null && _d !== void 0 ? _d : DEFAULT_RENDER_TYPE_NAME;
        for (const [typeName, def] of Object.entries((_e = options.definitions) !== null && _e !== void 0 ? _e : {})) {
            this.addDefinition(typeName, def);
        }
    }
    /**
     * Adds a JSON schema definition for a type name. This method does not emit the type
     * but rather just registers the definition that will get resolved if this type is `$ref`ed.
     *
     * @param typeName The name of the type.
     * @param def The JSON schema definition for this type
     */
    addDefinition(typeName, def) {
        this.definitions[typeName] = def;
    }
    /**
     * Overrides the definition of `fromTypeName` such that any references to it
     * will be resolved as `toTypeName`. Bear in mind that the type name specified
     * in `to` must either be defined as a definition (`addDefinition()`) _or_
     * emitted as a custom type (`emitCustomType()`).
     */
    addAlias(from, to) {
        this.addDefinition(from, { $ref: `#/definitions/${to}` });
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitType(typeName, def, structFqn = typeName) {
        return this.emitTypeInternal(typeName, def, structFqn).type;
    }
    /**
     * Many schemas define a type as an array of types to indicate union types.
     * To avoid having the type generator be aware of that, we transform those types
     * into their corresponding typescript definitions.
     * --------------------------------------------------
     *
     * Strictly speaking, these definitions are meant to allow the liternal 'null' value
     * to be used in addition to the actual types. However, since union types are not supported
     * in jsii, allowing this would mean falling back to 'any' and loosing all type safety for such
     * properties. Transforming it into a single concrete optional type provides both type safety and
     * the option to omit the property. What it doesn't allow is explicitly passing 'null', which might
     * be desired in some cases. For now we prefer type safety over that.
     *
     * 1. ['null', '<type>'] -> optional '<type>'
     * 2. ['null', '<type1>', '<type2>'] -> optional 'any'
     *
     * This is the normal jsii conversion, nothing much we can do here.
     *
     * 3. ['<type1>', '<type2>'] -> 'any'
     */
    maybeTransformTypeArray(def) {
        if (!Array.isArray(def.type)) {
            return;
        }
        const nullType = def.type.some(t => t === 'null');
        const nonNullTypes = new Set(def.type.filter(t => t !== 'null'));
        if (nullType) {
            def.required = false;
        }
        if (nonNullTypes.size === 0) {
            def.type = 'null';
        }
        else {
            // if its a union of non null types we use 'any' to be jsii compliant
            def.type = nonNullTypes.size > 1 ? 'any' : nonNullTypes.values().next().value;
        }
    }
    /**
     * Emit a type based on a JSON schema. If `def` is not specified, the
     * definition of the type will be looked up in the `definitions` provided
     * during initialization or via `addDefinition()`.
     *
     * @param typeName The name of th type
     * @param def JSON schema. If not specified, the schema is looked up from
     * `definitions` based on the type name
     * @param structFqn FQN for the type (defaults to `typeName`)
     * @returns The resolved type (not always the same as `typeName`)
     */
    emitTypeInternal(typeName, def, structFqn = typeName) {
        if (!def) {
            def = this.definitions[typeName];
            if (!def) {
                throw new Error(`unable to find schema definition for ${typeName}`);
            }
        }
        this.maybeTransformTypeArray(def);
        if (def.enum && this.sanitizeEnums) {
            // santizie enums from liternal 'null' because they prevent emitting the enum
            // and instead cause a fallback to 'string'. we assume the optionality of the enum
            // covers the 'null' value.
            def.enum = def.enum.filter(d => d !== null);
        }
        // callers expect that emit a type named `typeName` so we can't change it here
        // but at least we can verify it's correct.
        if (TypeGenerator.normalizeTypeName(typeName) !== typeName) {
            throw new Error(`${typeName} must be normalized before calling emitType`);
        }
        if (structFqn.startsWith(DEFINITIONS_PREFIX)) {
            structFqn = structFqn.substring(DEFINITIONS_PREFIX.length);
        }
        if (this.isExcluded(structFqn)) {
            throw new Error(`Type ${structFqn} cannot be added since it matches one of the exclusion patterns`);
        }
        // complex type
        if (def.$ref) {
            return this.typeForRef(def);
        }
        // unions (unless this is a struct, and then we just ignore the constraints)
        if (def.oneOf || def.anyOf) {
            const asUnion = this.tryEmitUnion(typeName, def, structFqn);
            if (asUnion) {
                return asUnion;
            }
            // carry on, we can't represent this schema as a union (yet?)
        }
        // dates
        if (def.format === 'date-time') {
            if (def.type && def.type !== 'string') {
                throw new Error('date-time must be a string');
            }
            return { type: 'Date', toJson: x => `${x}?.toISOString()` };
        }
        // enums
        if (def.enum && Array.isArray(def.enum) && def.enum.length > 0 && def.enum.every(x => ['string', 'number'].includes(typeof (x)))) {
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            return this.emitEnum(typeName, def, structFqn);
        }
        // struct
        if (def.properties) {
            if (def.type && def.type !== 'object') {
                throw new Error('for "properties", if "type" is specified it has to be an "object"');
            }
            return this.emitStruct(typeName, def, structFqn);
        }
        // map
        if (def.additionalProperties && typeof (def.additionalProperties) === 'object') {
            if (def.type && def.type !== 'object') {
                throw new Error('for "additionalProperties", if "type" is specified it has to be an "object"');
            }
            const et = this.typeForProperty(typeName, def.additionalProperties);
            const toJson = (x) => `((${x}) === undefined) ? undefined : (Object.entries(${x}).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: ${et.toJson('i[1]')} }), {}))`;
            return { type: `{ [key: string]: ${et.type} }`, toJson };
        }
        switch (def.type) {
            case 'string':
                return { type: 'string', toJson: x => x };
            case 'number':
            case 'integer':
                return { type: 'number', toJson: x => x };
            case 'boolean':
                return { type: 'boolean', toJson: (x) => x };
            case 'array': {
                return this.emitArray(typeName, def);
            }
        }
        return { type: 'any', toJson: x => x };
    }
    /**
     * Registers a custom type and emits it. This will override any existing
     * definitions for this type name.
     *
     * @param typeName The name of the type emitted by this handler.
     * @param emitter A function that will be called to emit the code and returns
     * information about the emitted type.
     */
    emitCustomType(typeName, emitter) {
        if (typeName in this.emittedTypes) {
            return;
        }
        this.typesToEmit[typeName] = code => {
            const result = emitter(code);
            if (typeof (result) === 'object') {
                return result;
            }
            else {
                return { type: typeName, toJson: x => x };
            }
        };
    }
    /**
     * @deprecated use `emitCustomType()`
     */
    addCode(typeName, emitter) {
        return this.emitCustomType(typeName, emitter);
    }
    /**
     * Renders all emitted types to a string.
     *
     * Use `renderToCode()` in order to render output to an existing `Code` object.
     */
    render() {
        const code = new code_1.Code();
        this.renderToCode(code);
        return code.render();
    }
    /**
     * Writes all types to a `CodeMaker` with an open file.
     * Use this method in case you need to add those type to an existing file.
     * @param code The `CodeMaker` instance.
     */
    renderToCode(code) {
        while (Object.keys(this.typesToEmit).length) {
            const name = Object.keys(this.typesToEmit)[0];
            const emitter = this.typesToEmit[name];
            const emittedType = emitter(code);
            code.line();
            delete this.typesToEmit[name];
            this.emittedTypes[name] = emittedType;
        }
    }
    /**
     * @deprecated use `renderToCode()`
     */
    emitCode(code) {
        return this.renderToCode(code);
    }
    /**
     * @deprecated use `emitType()`
     */
    addType(typeName, def, structFqn = typeName) {
        return this.emitType(typeName, def, structFqn);
    }
    /**
     * Emits an array.
     */
    emitArray(typeName, def) {
        const et = this.typeForArray(typeName, def);
        return { type: `${et.type}[]`, toJson: x => `${x}?.map(y => ${et.toJson('y')})` };
    }
    /**
     * @returns true if this definition can be represented as a union or false if it cannot
     */
    tryEmitUnion(typeName, def, fqn) {
        const options = new Array();
        for (const option of def.oneOf || def.anyOf || []) {
            if (!supportedUnionOptionType(option.type)) {
                return undefined;
            }
            const type = option.type === 'integer' ? 'number' : option.type;
            options.push(type);
        }
        const emitted = { type: typeName, toJson: x => `${x}?.value` };
        this.addCode(typeName, code => {
            this.emitDescription(code, fqn, def.description);
            code.openBlock(`export class ${typeName}`);
            const possibleTypes = [];
            for (const type of options) {
                possibleTypes.push(type);
                const methodName = 'from' + type[0].toUpperCase() + type.substr(1);
                code.openBlock(`public static ${methodName}(value: ${type}): ${typeName}`);
                code.line(`return new ${typeName}(value);`);
                code.closeBlock();
            }
            code.openBlock(`private constructor(public readonly value: ${possibleTypes.join(' | ')})`);
            code.closeBlock();
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitStruct(typeName, structDef, structFqn) {
        const toJson = new tojson_1.ToJsonFunction(typeName);
        const emitted = {
            type: typeName,
            toJson: x => `${toJson.functionName}(${x})`,
        };
        this.emitCustomType(typeName, code => {
            this.emitDescription(code, structFqn, structDef.description);
            code.openBlock(`export interface ${typeName}`);
            for (const [propName, propSpec] of Object.entries(structDef.properties || {})) {
                this.emitProperty(code, propName, propSpec, structFqn, structDef, toJson);
            }
            code.closeBlock();
            if (this.toJson) {
                toJson.emit(code);
            }
            return emitted;
        });
        return emitted;
    }
    emitProperty(code, name, propDef, structFqn, structDef, toJson) {
        const originalName = name;
        // if the name starts with '$' (like $ref or $schema), we remove the "$"
        // and it's the same deal - will produce invalid output
        if (name.startsWith('$')) {
            name = name.substring(1);
        }
        // convert the name to camel case so it's compatible with JSII
        name = (0, camelcase_1.default)(name);
        this.emitDescription(code, `${structFqn}#${originalName}`, propDef.description);
        const propertyType = this.typeForProperty(`${structFqn}.${name}`, propDef);
        const required = this.isPropertyRequired(originalName, structDef);
        const optional = required ? '' : '?';
        code.line(`readonly ${name}${optional}: ${propertyType.type};`);
        code.line();
        toJson.addField(originalName, name, propertyType.toJson);
    }
    emitEnum(typeName, def, structFqn) {
        const emitted = {
            type: typeName,
            toJson: x => x,
        };
        this.emitCustomType(typeName, code => {
            if (!def.enum || def.enum.length === 0) {
                throw new Error(`definition is not an enum: ${JSON.stringify(def)}`);
            }
            if (def.type && !(def.type === 'string' || def.type === 'number' || def.type === 'integer')) {
                throw new Error('only enums with string or number values are supported');
            }
            this.emitDescription(code, structFqn, def.description);
            code.openBlock(`export enum ${typeName}`);
            const processedValues = new Set();
            for (const value of def.enum) {
                if (!['string', 'number'].includes(typeof (value))) {
                    throw new Error('only enums with string or number values are supported');
                }
                let memberName = (0, snake_case_1.snakeCase)(rewriteNamedSymbols(`${value}`).replace(/[^a-z0-9]/gi, '_')).split('_').filter(x => x).join('_').toUpperCase();
                // If enums of same value exists, then we choose one of them and skip adding others
                // since that would cause conflict
                const lowerCaseValue = value === null || value === void 0 ? void 0 : value.toString().toLowerCase();
                if (lowerCaseValue && !processedValues.has(lowerCaseValue)) {
                    processedValues.add(lowerCaseValue);
                }
                else {
                    continue;
                }
                // if member name starts with a non-alpha character, add a prefix so it becomes a symbol
                if (!/^[A-Z].*/i.test(memberName)) {
                    memberName = 'VALUE_' + memberName;
                }
                code.line(`/** ${value} */`);
                code.line(`${memberName} = ${JSON.stringify(value)},`);
            }
            code.closeBlock();
            return emitted;
        });
        return emitted;
    }
    emitDescription(code, fqn, description, annotations = {}) {
        code.line('/**');
        if (description) {
            description = description.replace(/\*\//g, '_/');
            for (const dline of description.split('\n').map(x => x.trim())) {
                code.line(` * ${dline}`);
            }
            const extractDefault = /Defaults?\W+(to|is)\W+(.+)/g.exec(description);
            const def = extractDefault && extractDefault[2];
            if (def) {
                annotations.default = def;
            }
            code.line(' *');
        }
        annotations.schema = fqn;
        for (const [type, value] of Object.entries(annotations)) {
            code.line(` * @${type} ${value}`);
        }
        code.line(' */');
    }
    typeForProperty(propertyFqn, def) {
        const subtype = TypeGenerator.normalizeTypeName(DEFAULT_RENDER_TYPE_NAME(propertyFqn));
        return this.emitTypeInternal(subtype, def, subtype);
    }
    typeForRef(def) {
        const prefix = '#/definitions/';
        if (!def.$ref || !def.$ref.startsWith(prefix)) {
            throw new Error(`invalid $ref ${JSON.stringify(def)}`);
        }
        if (this.isExcluded(def.$ref)) {
            return { type: 'any', toJson: x => x };
        }
        const typeName = TypeGenerator.normalizeTypeName(this.renderTypeName(def.$ref.substring(prefix.length)));
        // if we already emitted a type with this type name, just return it
        const emitted = this.emittedTypes[typeName];
        if (emitted) {
            return emitted;
        }
        const schema = this.resolveReference(def);
        return this.emitTypeInternal(typeName, schema, def.$ref);
    }
    typeForArray(propertyFqn, def) {
        if (!def.items || typeof (def.items) !== 'object') {
            // Falling back to an array of any type
            def.items = {};
        }
        return this.typeForProperty(propertyFqn, def.items);
    }
    resolveReference(def) {
        const ref = def.$ref;
        if (!ref || !ref.startsWith(DEFINITIONS_PREFIX)) {
            throw new Error('expecting a local reference');
        }
        const lookup = ref.substr(DEFINITIONS_PREFIX.length);
        const found = this.definitions[lookup];
        if (!found) {
            throw new Error(`unable to find a definition for the $ref "${lookup}"`);
        }
        return found;
    }
    isPropertyRequired(property, structDef) {
        return Array.isArray(structDef.required) && structDef.required.includes(property);
    }
    isExcluded(fqn) {
        for (const pattern of this.exclude) {
            const re = new RegExp(pattern);
            if (re.test(fqn)) {
                return true;
            }
        }
        return false;
    }
}
exports.TypeGenerator = TypeGenerator;
function supportedUnionOptionType(type) {
    return type && (typeof (type) === 'string' && PRIMITIVE_TYPES.includes(type));
}
function pascalCase(s) {
    return (0, camelcase_1.default)(s, { pascalCase: true });
}
function rewriteNamedSymbols(input) {
    const ret = new Array();
    let cursor = 0;
    while (cursor < input.length) {
        const [prefixName, prefixLen] = longestPrefixMatch(input, cursor, allowlist_1.NAMED_SYMBOLS);
        if (prefixName) {
            const prefix = `_${prefixName}_`.split('');
            ret.push(...prefix);
            cursor += prefixLen;
        }
        else {
            ret.push(input.charAt(cursor));
            cursor += 1;
        }
    }
    // Remove underscores if its only prefix to be returned
    if (ret[0] === '_') {
        ret.unshift('VALUE');
    }
    if (ret[ret.length - 1] === '_') {
        ret.pop();
    }
    return ret.join('');
}
function longestPrefixMatch(input, index, lookupTable) {
    let ret;
    let longest = 0;
    for (const [name, value] of Object.entries(lookupTable)) {
        if (hasSubStringAt(input, index, value) && value.length > longest && !isExemptPattern(input, index)) {
            ret = name;
            longest = value.length;
        }
    }
    return [ret, longest];
}
function hasSubStringAt(input, index, substring) {
    if (index == input.indexOf(substring, index)) {
        return true;
    }
    return false;
}
function isExemptPattern(input, index) {
    const exemptPatterns = [
        // 9.9, 9.
        /(?<=\d)\.\d/,
    ];
    return exemptPatterns.some((p) => testRegexAt(p, input, index));
}
function testRegexAt(regex, input, index) {
    const re = new RegExp(regex, 'y');
    re.lastIndex = index;
    return re.test(input);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1nZW5lcmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZS1nZW5lcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMERBQWtDO0FBRWxDLDJDQUF1QztBQUN2QywyQ0FBNEM7QUFDNUMsaUNBQThCO0FBQzlCLHFDQUEwQztBQUcxQyxNQUFNLGVBQWUsR0FBRyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ25FLE1BQU0sa0JBQWtCLEdBQUcsZ0JBQWdCLENBQUM7QUFDNUMsTUFBTSx3QkFBd0IsR0FBRyxDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUF3RDlGOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBQ3hCOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxRQUFnQjtRQUU5QywwQkFBMEI7UUFDMUIsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdEcsaUZBQWlGO1FBQ2pGLE1BQU0sRUFBRSxHQUFHLHVCQUF1QixDQUFDO1FBQ25DLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNwQixJQUFJLENBQUMsQ0FBQztRQUNOLEdBQUc7WUFDRCxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENB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T0FBTyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxLQUFhLEVBQUUsS0FBYSxFQUFFLEtBQWE7SUFDOUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBRXJCLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNhbWVsQ2FzZSBmcm9tICdjYW1lbGNhc2UnO1xuaW1wb3J0IHsgSlNPTlNjaGVtYTQgfSBmcm9tICdqc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBzbmFrZUNhc2UgfSBmcm9tICdzbmFrZS1jYXNlJztcbmltcG9ydCB7IE5BTUVEX1NZTUJPTFMgfSBmcm9tICcuL2FsbG93bGlzdCc7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSAnLi9jb2RlJztcbmltcG9ydCB7IFRvSnNvbkZ1bmN0aW9uIH0gZnJvbSAnLi90b2pzb24nO1xuXG5cbmNvbnN0IFBSSU1JVElWRV9UWVBFUyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdpbnRlZ2VyJywgJ2Jvb2xlYW4nXTtcbmNvbnN0IERFRklOSVRJT05TX1BSRUZJWCA9ICcjL2RlZmluaXRpb25zLyc7XG5jb25zdCBERUZBVUxUX1JFTkRFUl9UWVBFX05BTUUgPSAoczogc3RyaW5nKSA9PiBzLnNwbGl0KCcuJykubWFwKHggPT4gcGFzY2FsQ2FzZSh4KSkuam9pbignJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZUdlbmVyYXRvck9wdGlvbnMge1xuICAvKipcbiAgICogUGF0dGVybnMgb2YgdHlwZSBGUU5zIHRvIGV4Y2x1ZGUuXG4gICAqIEBkZWZhdWx0IC0gaW5jbHVkZSBhbGwgdHlwZXNcbiAgICovXG4gIHJlYWRvbmx5IGV4Y2x1ZGU/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogU2NoZW1hIGRlZmluaXRpb25zIGZvciByZXNvbHZpbmcgJHJlZnNcbiAgICogQGRlZmF1bHQgLSAkcmVmcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgKi9cbiAgcmVhZG9ubHkgZGVmaW5pdGlvbnM/OiB7IFtkZWY6IHN0cmluZ106IEpTT05TY2hlbWE0IH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGB0b0pzb25fWHl6YCBmdW5jdGlvbnMgZm9yIGFsbCB0eXBlcyB3aGljaCBjb252ZXJ0IGRhdGEgb2JqZWN0c1xuICAgKiBiYWNrIHRvIHNjaGVtYS1jb21wYXRpYmxlIEpTT04uXG4gICAqXG4gICAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgcmVxdWlyZWQgc2luY2UgcHJvcGVydHkgbmFtZXMgaW4gZ2VuZXJhdGVkIHN0cnVjdHMgYXJlXG4gICAqIGNhbWVsIGNhc2VkIGluIG9yZGVyIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBKU0lJLCBhbmQgdGhpcyBpcyBhIGxvc3N5XG4gICAqIGNvbnZlcnNpb24sIHNvIHRoZSB0b0pzb24gZnVuY3Rpb25zIGFyZSByZXF1aXJlZCB0byBjb252ZXJ0IHRoZSBkYXRhIGJhY2tcbiAgICogdG8gYSBzY2hlbWEtY29tcGF0aWJsZSBkYXRhIG9iamVjdHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHRvSnNvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0IHRvIHRydWUsIGVudW1zIGFyZSBzYW5pdGl6ZWQgZnJvbSB0aGUgJ251bGwnIGxpdGVyYWwgdmFsdWUsXG4gICAqIGFsbG93aW5nIHR5cGluZyB0aGUgcHJvcGVydHkgYXMgYW4gZW51bSwgaW5zdGVhZCBvZiB0aGUgdW5kZXJseWluZyB0eXBlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc3dpdGNoaW5nIHRoaXMgZnJvbSAnZmFsc2UnIHRvICd0cnVlJyBpcyBhIGJyZWFraW5nIGNoYW5nZSBpblxuICAgKiB0aGUgZ2VuZXJhdGVkIGNvZGUgYXMgaXQgbWlnaHQgY2hhbmdlIGEgcHJvcGVydHkgdHlwZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHNhbml0aXplRW51bXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGRlZmluaXRpb24gbmFtZSwgcmVuZGVyIHRoZSB0eXBlIG5hbWUgdG8gYmUgZW1pdHRlZCBieSB0aGF0IGRlZmluaXRpb24uXG4gICAqXG4gICAqIFdoZW4gYGVtaXRUeXBlYCBpcyBpbnZva2VkLCB0aGUgdHlwZSBuYW1lIHRvIGJlIGVtaXR0ZWQgaXMgcHJvdmlkZWQgYnkgdGhlIGNhbGxlci5cbiAgICogSG93ZXZlciwgZm9yIGNvbXBsZXggdHlwZXMgY29udGFpbmluZyByZWZlcmVuY2VzIHRvIG90aGVyIHR5cGVzLCB3ZSBpbmZlciB0aGUgdHlwZSBuYW1lIG9mIHRoZSByZWZlcmVuY2VcbiAgICogYnkgbG9va2luZyBhdCB0aGUgZGVmaW5pdGlvbiBuYW1lIG9mIHRoZSBgJHJlZmAgYXR0cmlidXRlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgd2F5IHRvIGNvbnRyb2wgaG93IHRob3NlIGRlZmluaXRpb24gbmFtZXMgdHJhbnNsYXRlIGludG8gdHlwZSBuYW1lLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYSBjb21wbGV4IHR5cGUgcmVmZXJlbmNlcyBhIG5hbWVzcGFjZWQgZGVmaW5pdGlvbiBsaWtlIGBhcGkuZ3JvdXAuRm9vYCwgd2UnZCBsaWtlIHRvIGNvbnRyb2xcbiAgICogaG93IHRvIHRyYW5zbGF0ZSBgYXBpLmdyb3VwLkZvb2AsIHdoaWNoIGlzIGFuIGlsbGVnYWwgdHlwZW5hbWUsIGludG8gYSBsZWdhbCBvbmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gT25seSBkb3QgbmFtZXNwYWNpbmcgaXMgaGFuZGxlZCBieSBkZWZhdWx0LiBFbGVtZW50cyBiZXR3ZWVuIGRvdHMgYXJlIHBhc2NhbCBjYXNlZCBhbmQgY29uY2F0ZW5hdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVuZGVyVHlwZU5hbWU/OiAoZGVmOiBzdHJpbmcpID0+IHN0cmluZztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdHlwZXNjcmlwdCB0eXBlcyBmcm9tIEpTT04gc2NoZW1hcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVHZW5lcmF0b3Ige1xuICAvKipcbiAgICogQ29udmVydCBhbGwtY2FwcyBhY3JvbnltcyAoZS5nLiBcIlZQQ1wiLCBcIkZvb0JBUlpvb0ZJR29vXCIpIHRvIHBhc2NhbCBjYXNlXG4gICAqIChlLmcuIFwiVnBjXCIsIFwiRm9vQmFyWm9vRmlHb29cIikuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZVR5cGVOYW1lKHR5cGVOYW1lOiBzdHJpbmcpIHtcblxuICAgIC8vIEhhbmRsZSBrZWJhYi1jYXNlIGZpcnN0XG4gICAgY29uc3Qgc3RhZ2UxID0gdHlwZU5hbWUuc3BsaXQoJy0nKS5tYXAod29yZCA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkuam9pbignJyk7XG5cbiAgICAvLyBzdGFydCB3aXRoIHRoZSBmdWxsIHN0cmluZyBhbmQgdGhlbiB1c2UgdGhlIHJlZ2V4IHRvIG1hdGNoIGFsbC1jYXBzIHNlcXVlbmNlcy5cbiAgICBjb25zdCByZSA9IC8oW0EtWl0rKSg/OlteYS16XXwkKS9nO1xuICAgIGxldCByZXN1bHQgPSBzdGFnZTE7XG4gICAgbGV0IG07XG4gICAgZG8ge1xuICAgICAgbSA9IHJlLmV4ZWMoc3RhZ2UxKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHJlc3VsdC5zbGljZSgwLCBtLmluZGV4KTsgLy8gYWxsIHRoZSB0ZXh0IGJlZm9yZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgY29uc3QgY2FwID0gbVsxXTsgLy8gZ3JvdXAgIzEgbWF0Y2hlcyB0aGUgYWxsLWNhcHMgc2VxdWVuY2Ugd2UgYXJlIGFmdGVyXG4gICAgICAgIGNvbnN0IHBhc2NhbCA9IGNhcFswXSArIGNhcC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpOyAvLyBjb252ZXJ0IHRvIHBhc2NhbCBjYXNlIGJ5IGxvd2VyY2FzaW5nIGFsbCBidXQgdGhlIGZpcnN0IGNoYXJcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSByZXN1bHQuc2xpY2UobS5pbmRleCArIHBhc2NhbC5sZW5ndGgpOyAvLyBhbGwgdGhlIHRleHQgYWZ0ZXIgdGhlIHNlcXVlbmNlXG4gICAgICAgIHJlc3VsdCA9IGJlZm9yZSArIHBhc2NhbCArIGFmdGVyOyAvLyBjb25jYXRcbiAgICAgIH1cbiAgICB9IHdoaWxlIChtKTtcblxuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9eLi8sIHJlc3VsdFswXS50b1VwcGVyQ2FzZSgpKTsgLy8gZW5zdXJlIGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIEpTSUkgc3RydWN0IChhbmQgYWNjb21wYW55aW5nIHR5cGVzKSBmcm9tIGEgSlNPTiBzY2hlbWEuXG4gICAqXG4gICAqIElmIHlvdSB3aXNoIHRvIHJlbmRlciBtdWx0aXBsZSB0b3AtbGV2ZWwgc3RydWN0cyBvciBpbmNsdWRlIGN1c3RvbSB0eXBlcyxcbiAgICogY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGBUeXBlR2VuZXJhdG9yYCBtYW51YWxseS5cbiAgICpcbiAgICogQHBhcmFtIHN0cnVjdE5hbWUgVGhlIG5hbWUgb2YgdGhlIEpTSUkgc3RydWN0IChUeXBlU2NyaXB0IGludGVyZmFjZSkuXG4gICAqIEBwYXJhbSBzY2hlbWEgVGhlIEpTT04gc2NoZW1hICh0b3AgbGV2ZWwgc2NoZW1hIG11c3QgaW5jbHVkZSBcInByb3BlcnRpZXNcIilcbiAgICogQHJldHVybnMgR2VuZXJhdGVkIFR5cGVTY3JpcHQgc291cmNlIGNvZGUgdGhhdCBpbmNsdWRlcyB0aGUgdG9wLWxldmVsXG4gICAqIHN0cnVjdCBhbmQgYWxsIG90aGVyIHR5cGVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmb3JTdHJ1Y3Qoc3RydWN0TmFtZTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWE0LCBvcHRpb25zOiBUeXBlR2VuZXJhdG9yT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZ2VuID0gbmV3IFR5cGVHZW5lcmF0b3IoeyBkZWZpbml0aW9uczogc2NoZW1hLmRlZmluaXRpb25zLCAuLi5vcHRpb25zIH0pO1xuICAgIGdlbi5lbWl0VHlwZShzdHJ1Y3ROYW1lLCBzY2hlbWEpO1xuICAgIHJldHVybiBnZW47XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IHR5cGVzVG9FbWl0OiB7IFtuYW1lOiBzdHJpbmddOiBUeXBlRW1pdHRlciB9ID0geyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IGVtaXR0ZWRUeXBlczogUmVjb3JkPHN0cmluZywgRW1pdHRlZFR5cGU+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhjbHVkZTogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmaW5pdGlvbnM6IHsgW2RlZjogc3RyaW5nXTogSlNPTlNjaGVtYTQgfTtcbiAgcHJpdmF0ZSByZWFkb25seSB0b0pzb246IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgc2FuaXRpemVFbnVtczogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJUeXBlTmFtZTogKGRlZjogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBUeXBlR2VuZXJhdG9yT3B0aW9ucyA9IHsgfSkge1xuICAgIHRoaXMuZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSA/PyBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgdGhpcy50b0pzb24gPSBvcHRpb25zLnRvSnNvbiA/PyB0cnVlO1xuICAgIHRoaXMuc2FuaXRpemVFbnVtcyA9IG9wdGlvbnMuc2FuaXRpemVFbnVtcyA/PyBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclR5cGVOYW1lID0gb3B0aW9ucy5yZW5kZXJUeXBlTmFtZSA/PyBERUZBVUxUX1JFTkRFUl9UWVBFX05BTUU7XG5cbiAgICBmb3IgKGNvbnN0IFt0eXBlTmFtZSwgZGVmXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLmRlZmluaXRpb25zID8/IHt9KSkge1xuICAgICAgdGhpcy5hZGREZWZpbml0aW9uKHR5cGVOYW1lLCBkZWYpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgSlNPTiBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgYSB0eXBlIG5hbWUuIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVtaXQgdGhlIHR5cGVcbiAgICogYnV0IHJhdGhlciBqdXN0IHJlZ2lzdGVycyB0aGUgZGVmaW5pdGlvbiB0aGF0IHdpbGwgZ2V0IHJlc29sdmVkIGlmIHRoaXMgdHlwZSBpcyBgJHJlZmBlZC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGVOYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGVmIFRoZSBKU09OIHNjaGVtYSBkZWZpbml0aW9uIGZvciB0aGlzIHR5cGVcbiAgICovXG4gIHB1YmxpYyBhZGREZWZpbml0aW9uKHR5cGVOYW1lOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpIHtcbiAgICB0aGlzLmRlZmluaXRpb25zW3R5cGVOYW1lXSA9IGRlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGRlZmluaXRpb24gb2YgYGZyb21UeXBlTmFtZWAgc3VjaCB0aGF0IGFueSByZWZlcmVuY2VzIHRvIGl0XG4gICAqIHdpbGwgYmUgcmVzb2x2ZWQgYXMgYHRvVHlwZU5hbWVgLiBCZWFyIGluIG1pbmQgdGhhdCB0aGUgdHlwZSBuYW1lIHNwZWNpZmllZFxuICAgKiBpbiBgdG9gIG11c3QgZWl0aGVyIGJlIGRlZmluZWQgYXMgYSBkZWZpbml0aW9uIChgYWRkRGVmaW5pdGlvbigpYCkgX29yX1xuICAgKiBlbWl0dGVkIGFzIGEgY3VzdG9tIHR5cGUgKGBlbWl0Q3VzdG9tVHlwZSgpYCkuXG4gICAqL1xuICBwdWJsaWMgYWRkQWxpYXMoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKSB7XG4gICAgdGhpcy5hZGREZWZpbml0aW9uKGZyb20sIHsgJHJlZjogYCMvZGVmaW5pdGlvbnMvJHt0b31gIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSB0eXBlIGJhc2VkIG9uIGEgSlNPTiBzY2hlbWEuIElmIGBkZWZgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiBkZWZpbml0aW9uIG9mIHRoZSB0eXBlIHdpbGwgYmUgbG9va2VkIHVwIGluIHRoZSBgZGVmaW5pdGlvbnNgIHByb3ZpZGVkXG4gICAqIGR1cmluZyBpbml0aWFsaXphdGlvbiBvciB2aWEgYGFkZERlZmluaXRpb24oKWAuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgbmFtZSBvZiB0aCB0eXBlXG4gICAqIEBwYXJhbSBkZWYgSlNPTiBzY2hlbWEuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBzY2hlbWEgaXMgbG9va2VkIHVwIGZyb21cbiAgICogYGRlZmluaXRpb25zYCBiYXNlZCBvbiB0aGUgdHlwZSBuYW1lXG4gICAqIEBwYXJhbSBzdHJ1Y3RGcW4gRlFOIGZvciB0aGUgdHlwZSAoZGVmYXVsdHMgdG8gYHR5cGVOYW1lYClcbiAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHR5cGUgKG5vdCBhbHdheXMgdGhlIHNhbWUgYXMgYHR5cGVOYW1lYClcbiAgICovXG4gIHB1YmxpYyBlbWl0VHlwZSh0eXBlTmFtZTogc3RyaW5nLCBkZWY/OiBKU09OU2NoZW1hNCwgc3RydWN0RnFuOiBzdHJpbmcgPSB0eXBlTmFtZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGVJbnRlcm5hbCh0eXBlTmFtZSwgZGVmLCBzdHJ1Y3RGcW4pLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogTWFueSBzY2hlbWFzIGRlZmluZSBhIHR5cGUgYXMgYW4gYXJyYXkgb2YgdHlwZXMgdG8gaW5kaWNhdGUgdW5pb24gdHlwZXMuXG4gICAqIFRvIGF2b2lkIGhhdmluZyB0aGUgdHlwZSBnZW5lcmF0b3IgYmUgYXdhcmUgb2YgdGhhdCwgd2UgdHJhbnNmb3JtIHRob3NlIHR5cGVzXG4gICAqIGludG8gdGhlaXIgY29ycmVzcG9uZGluZyB0eXBlc2NyaXB0IGRlZmluaXRpb25zLlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBTdHJpY3RseSBzcGVha2luZywgdGhlc2UgZGVmaW5pdGlvbnMgYXJlIG1lYW50IHRvIGFsbG93IHRoZSBsaXRlcm5hbCAnbnVsbCcgdmFsdWVcbiAgICogdG8gYmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aGUgYWN0dWFsIHR5cGVzLiBIb3dldmVyLCBzaW5jZSB1bmlvbiB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgKiBpbiBqc2lpLCBhbGxvd2luZyB0aGlzIHdvdWxkIG1lYW4gZmFsbGluZyBiYWNrIHRvICdhbnknIGFuZCBsb29zaW5nIGFsbCB0eXBlIHNhZmV0eSBmb3Igc3VjaFxuICAgKiBwcm9wZXJ0aWVzLiBUcmFuc2Zvcm1pbmcgaXQgaW50byBhIHNpbmdsZSBjb25jcmV0ZSBvcHRpb25hbCB0eXBlIHByb3ZpZGVzIGJvdGggdHlwZSBzYWZldHkgYW5kXG4gICAqIHRoZSBvcHRpb24gdG8gb21pdCB0aGUgcHJvcGVydHkuIFdoYXQgaXQgZG9lc24ndCBhbGxvdyBpcyBleHBsaWNpdGx5IHBhc3NpbmcgJ251bGwnLCB3aGljaCBtaWdodFxuICAgKiBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMuIEZvciBub3cgd2UgcHJlZmVyIHR5cGUgc2FmZXR5IG92ZXIgdGhhdC5cbiAgICpcbiAgICogMS4gWydudWxsJywgJzx0eXBlPiddIC0+IG9wdGlvbmFsICc8dHlwZT4nXG4gICAqIDIuIFsnbnVsbCcsICc8dHlwZTE+JywgJzx0eXBlMj4nXSAtPiBvcHRpb25hbCAnYW55J1xuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBub3JtYWwganNpaSBjb252ZXJzaW9uLCBub3RoaW5nIG11Y2ggd2UgY2FuIGRvIGhlcmUuXG4gICAqXG4gICAqIDMuIFsnPHR5cGUxPicsICc8dHlwZTI+J10gLT4gJ2FueSdcbiAgICovXG4gIHByaXZhdGUgbWF5YmVUcmFuc2Zvcm1UeXBlQXJyYXkoZGVmOiBKU09OU2NoZW1hNCkge1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZi50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxUeXBlID0gZGVmLnR5cGUuc29tZSh0ID0+IHQgPT09ICdudWxsJyk7XG4gICAgY29uc3Qgbm9uTnVsbFR5cGVzID0gbmV3IFNldChkZWYudHlwZS5maWx0ZXIodCA9PiB0ICE9PSAnbnVsbCcpKTtcblxuICAgIGlmIChudWxsVHlwZSkge1xuICAgICAgZGVmLnJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vbk51bGxUeXBlcy5zaXplID09PSAwKSB7XG4gICAgICBkZWYudHlwZSA9ICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgaXRzIGEgdW5pb24gb2Ygbm9uIG51bGwgdHlwZXMgd2UgdXNlICdhbnknIHRvIGJlIGpzaWkgY29tcGxpYW50XG4gICAgICBkZWYudHlwZSA9IG5vbk51bGxUeXBlcy5zaXplID4gMSA/ICdhbnknIDogbm9uTnVsbFR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgdHlwZSBiYXNlZCBvbiBhIEpTT04gc2NoZW1hLiBJZiBgZGVmYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogZGVmaW5pdGlvbiBvZiB0aGUgdHlwZSB3aWxsIGJlIGxvb2tlZCB1cCBpbiB0aGUgYGRlZmluaXRpb25zYCBwcm92aWRlZFxuICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb3IgdmlhIGBhZGREZWZpbml0aW9uKClgLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZU5hbWUgVGhlIG5hbWUgb2YgdGggdHlwZVxuICAgKiBAcGFyYW0gZGVmIEpTT04gc2NoZW1hLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc2NoZW1hIGlzIGxvb2tlZCB1cCBmcm9tXG4gICAqIGBkZWZpbml0aW9uc2AgYmFzZWQgb24gdGhlIHR5cGUgbmFtZVxuICAgKiBAcGFyYW0gc3RydWN0RnFuIEZRTiBmb3IgdGhlIHR5cGUgKGRlZmF1bHRzIHRvIGB0eXBlTmFtZWApXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB0eXBlIChub3QgYWx3YXlzIHRoZSBzYW1lIGFzIGB0eXBlTmFtZWApXG4gICAqL1xuICBwcml2YXRlIGVtaXRUeXBlSW50ZXJuYWwodHlwZU5hbWU6IHN0cmluZywgZGVmPzogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nID0gdHlwZU5hbWUpOiBFbWl0dGVkVHlwZSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGRlZiA9IHRoaXMuZGVmaW5pdGlvbnNbdHlwZU5hbWVdO1xuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgJHt0eXBlTmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1heWJlVHJhbnNmb3JtVHlwZUFycmF5KGRlZik7XG5cbiAgICBpZiAoZGVmLmVudW0gJiYgdGhpcy5zYW5pdGl6ZUVudW1zKSB7XG4gICAgICAvLyBzYW50aXppZSBlbnVtcyBmcm9tIGxpdGVybmFsICdudWxsJyBiZWNhdXNlIHRoZXkgcHJldmVudCBlbWl0dGluZyB0aGUgZW51bVxuICAgICAgLy8gYW5kIGluc3RlYWQgY2F1c2UgYSBmYWxsYmFjayB0byAnc3RyaW5nJy4gd2UgYXNzdW1lIHRoZSBvcHRpb25hbGl0eSBvZiB0aGUgZW51bVxuICAgICAgLy8gY292ZXJzIHRoZSAnbnVsbCcgdmFsdWUuXG4gICAgICBkZWYuZW51bSA9IGRlZi5lbnVtLmZpbHRlcihkID0+IGQgIT09IG51bGwpO1xuICAgIH1cblxuICAgIC8vIGNhbGxlcnMgZXhwZWN0IHRoYXQgZW1pdCBhIHR5cGUgbmFtZWQgYHR5cGVOYW1lYCBzbyB3ZSBjYW4ndCBjaGFuZ2UgaXQgaGVyZVxuICAgIC8vIGJ1dCBhdCBsZWFzdCB3ZSBjYW4gdmVyaWZ5IGl0J3MgY29ycmVjdC5cbiAgICBpZiAoVHlwZUdlbmVyYXRvci5ub3JtYWxpemVUeXBlTmFtZSh0eXBlTmFtZSkgIT09IHR5cGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZU5hbWV9IG11c3QgYmUgbm9ybWFsaXplZCBiZWZvcmUgY2FsbGluZyBlbWl0VHlwZWApO1xuICAgIH1cblxuICAgIGlmIChzdHJ1Y3RGcW4uc3RhcnRzV2l0aChERUZJTklUSU9OU19QUkVGSVgpKSB7XG4gICAgICBzdHJ1Y3RGcW4gPSBzdHJ1Y3RGcW4uc3Vic3RyaW5nKERFRklOSVRJT05TX1BSRUZJWC5sZW5ndGgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRXhjbHVkZWQoc3RydWN0RnFuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlICR7c3RydWN0RnFufSBjYW5ub3QgYmUgYWRkZWQgc2luY2UgaXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGV4Y2x1c2lvbiBwYXR0ZXJuc2ApO1xuICAgIH1cblxuICAgIC8vIGNvbXBsZXggdHlwZVxuICAgIGlmIChkZWYuJHJlZikge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZUZvclJlZihkZWYpO1xuICAgIH1cblxuICAgIC8vIHVuaW9ucyAodW5sZXNzIHRoaXMgaXMgYSBzdHJ1Y3QsIGFuZCB0aGVuIHdlIGp1c3QgaWdub3JlIHRoZSBjb25zdHJhaW50cylcbiAgICBpZiAoZGVmLm9uZU9mIHx8IGRlZi5hbnlPZikge1xuXG4gICAgICBjb25zdCBhc1VuaW9uID0gdGhpcy50cnlFbWl0VW5pb24odHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgICAgIGlmIChhc1VuaW9uKSB7XG4gICAgICAgIHJldHVybiBhc1VuaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBjYXJyeSBvbiwgd2UgY2FuJ3QgcmVwcmVzZW50IHRoaXMgc2NoZW1hIGFzIGEgdW5pb24gKHlldD8pXG4gICAgfVxuXG4gICAgLy8gZGF0ZXNcbiAgICBpZiAoZGVmLmZvcm1hdCA9PT0gJ2RhdGUtdGltZScpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiBkZWYudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRlLXRpbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB0eXBlOiAnRGF0ZScsIHRvSnNvbjogeCA9PiBgJHt4fT8udG9JU09TdHJpbmcoKWAgfTtcbiAgICB9XG5cbiAgICAvLyBlbnVtc1xuICAgIGlmIChkZWYuZW51bSAmJiBBcnJheS5pc0FycmF5KGRlZi5lbnVtKSAmJiBkZWYuZW51bS5sZW5ndGggPiAwICYmIGRlZi5lbnVtLmV2ZXJ5KHggPT4gWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mKHgpKSkpIHtcbiAgICAgIGlmIChkZWYudHlwZSAmJiAhKGRlZi50eXBlID09PSAnc3RyaW5nJyB8fCBkZWYudHlwZSA9PT0gJ251bWJlcicgfHwgZGVmLnR5cGUgPT09ICdpbnRlZ2VyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGVudW1zIHdpdGggc3RyaW5nIG9yIG51bWJlciB2YWx1ZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0RW51bSh0eXBlTmFtZSwgZGVmLCBzdHJ1Y3RGcW4pO1xuICAgIH1cblxuICAgIC8vIHN0cnVjdFxuICAgIGlmIChkZWYucHJvcGVydGllcykge1xuICAgICAgaWYgKGRlZi50eXBlICYmIGRlZi50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvciBcInByb3BlcnRpZXNcIiwgaWYgXCJ0eXBlXCIgaXMgc3BlY2lmaWVkIGl0IGhhcyB0byBiZSBhbiBcIm9iamVjdFwiJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXRTdHJ1Y3QodHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgICB9XG5cbiAgICAvLyBtYXBcbiAgICBpZiAoZGVmLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmIHR5cGVvZihkZWYuYWRkaXRpb25hbFByb3BlcnRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGRlZi50eXBlICYmIGRlZi50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvciBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGlmIFwidHlwZVwiIGlzIHNwZWNpZmllZCBpdCBoYXMgdG8gYmUgYW4gXCJvYmplY3RcIicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBldCA9IHRoaXMudHlwZUZvclByb3BlcnR5KHR5cGVOYW1lLCBkZWYuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgY29uc3QgdG9Kc29uID0gKHg6IHN0cmluZykgPT4gYCgoJHt4fSkgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiAoT2JqZWN0LmVudHJpZXMoJHt4fSkucmVkdWNlKChyLCBpKSA9PiAoaVsxXSA9PT0gdW5kZWZpbmVkKSA/IHIgOiAoeyAuLi5yLCBbaVswXV06ICR7ZXQudG9Kc29uKCdpWzFdJykgfSB9KSwge30pKWA7XG4gICAgICByZXR1cm4geyB0eXBlOiBgeyBba2V5OiBzdHJpbmddOiAke2V0LnR5cGV9IH1gLCB0b0pzb24gfTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRlZi50eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4geyB0eXBlOiAnc3RyaW5nJywgdG9Kc29uOiB4ID0+IHggfTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICByZXR1cm4geyB0eXBlOiAnbnVtYmVyJywgdG9Kc29uOiB4ID0+IHggfTtcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdib29sZWFuJywgdG9Kc29uOiAoeCkgPT4geCB9O1xuXG4gICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdEFycmF5KHR5cGVOYW1lLCBkZWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdhbnknLCB0b0pzb246IHggPT4geCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGN1c3RvbSB0eXBlIGFuZCBlbWl0cyBpdC4gVGhpcyB3aWxsIG92ZXJyaWRlIGFueSBleGlzdGluZ1xuICAgKiBkZWZpbml0aW9ucyBmb3IgdGhpcyB0eXBlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSBlbWl0dGVkIGJ5IHRoaXMgaGFuZGxlci5cbiAgICogQHBhcmFtIGVtaXR0ZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGVtaXQgdGhlIGNvZGUgYW5kIHJldHVybnNcbiAgICogaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVtaXR0ZWQgdHlwZS5cbiAgICovXG4gIHB1YmxpYyBlbWl0Q3VzdG9tVHlwZSh0eXBlTmFtZTogc3RyaW5nLCBlbWl0dGVyOiBUeXBlRW1pdHRlciB8IENvZGVFbWl0dGVyKSB7XG4gICAgaWYgKHR5cGVOYW1lIGluIHRoaXMuZW1pdHRlZFR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50eXBlc1RvRW1pdFt0eXBlTmFtZV0gPSBjb2RlID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVtaXR0ZXIoY29kZSk7XG4gICAgICBpZiAodHlwZW9mKHJlc3VsdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlTmFtZSwgdG9Kc29uOiB4ID0+IHggfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZW1pdEN1c3RvbVR5cGUoKWBcbiAgICovXG4gIHB1YmxpYyBhZGRDb2RlKHR5cGVOYW1lOiBzdHJpbmcsIGVtaXR0ZXI6IFR5cGVFbWl0dGVyIHwgQ29kZUVtaXR0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0Q3VzdG9tVHlwZSh0eXBlTmFtZSwgZW1pdHRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhbGwgZW1pdHRlZCB0eXBlcyB0byBhIHN0cmluZy5cbiAgICpcbiAgICogVXNlIGByZW5kZXJUb0NvZGUoKWAgaW4gb3JkZXIgdG8gcmVuZGVyIG91dHB1dCB0byBhbiBleGlzdGluZyBgQ29kZWAgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIHJlbmRlcigpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvZGUgPSBuZXcgQ29kZSgpO1xuICAgIHRoaXMucmVuZGVyVG9Db2RlKGNvZGUpO1xuICAgIHJldHVybiBjb2RlLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhbGwgdHlwZXMgdG8gYSBgQ29kZU1ha2VyYCB3aXRoIGFuIG9wZW4gZmlsZS5cbiAgICogVXNlIHRoaXMgbWV0aG9kIGluIGNhc2UgeW91IG5lZWQgdG8gYWRkIHRob3NlIHR5cGUgdG8gYW4gZXhpc3RpbmcgZmlsZS5cbiAgICogQHBhcmFtIGNvZGUgVGhlIGBDb2RlTWFrZXJgIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHJlbmRlclRvQ29kZShjb2RlOiBDb2RlKSB7XG4gICAgd2hpbGUgKE9iamVjdC5rZXlzKHRoaXMudHlwZXNUb0VtaXQpLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmFtZSA9IE9iamVjdC5rZXlzKHRoaXMudHlwZXNUb0VtaXQpWzBdO1xuICAgICAgY29uc3QgZW1pdHRlciA9IHRoaXMudHlwZXNUb0VtaXRbbmFtZV07XG4gICAgICBjb25zdCBlbWl0dGVkVHlwZSA9IGVtaXR0ZXIoY29kZSk7XG4gICAgICBjb2RlLmxpbmUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnR5cGVzVG9FbWl0W25hbWVdO1xuICAgICAgdGhpcy5lbWl0dGVkVHlwZXNbbmFtZV0gPSBlbWl0dGVkVHlwZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByZW5kZXJUb0NvZGUoKWBcbiAgICovXG4gIHB1YmxpYyBlbWl0Q29kZShjb2RlOiBDb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9Db2RlKGNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZW1pdFR5cGUoKWBcbiAgICovXG4gIHB1YmxpYyBhZGRUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIGRlZj86IEpTT05TY2hlbWE0LCBzdHJ1Y3RGcW46IHN0cmluZyA9IHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdFR5cGUodHlwZU5hbWUsIGRlZiwgc3RydWN0RnFuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBhcnJheS5cbiAgICovXG4gIHByaXZhdGUgZW1pdEFycmF5KHR5cGVOYW1lOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpOiBFbWl0dGVkVHlwZSB7XG4gICAgY29uc3QgZXQgPSB0aGlzLnR5cGVGb3JBcnJheSh0eXBlTmFtZSwgZGVmKTtcbiAgICByZXR1cm4geyB0eXBlOiBgJHtldC50eXBlfVtdYCwgdG9Kc29uOiB4ID0+IGAke3h9Py5tYXAoeSA9PiAke2V0LnRvSnNvbigneScpfSlgIH07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGRlZmluaXRpb24gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgdW5pb24gb3IgZmFsc2UgaWYgaXQgY2Fubm90XG4gICAqL1xuICBwcml2YXRlIHRyeUVtaXRVbmlvbih0eXBlTmFtZTogc3RyaW5nLCBkZWY6IEpTT05TY2hlbWE0LCBmcW46IHN0cmluZyk6IEVtaXR0ZWRUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBvcHRpb25zID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub25lT2YgfHwgZGVmLmFueU9mIHx8IFtdKSB7XG4gICAgICBpZiAoIXN1cHBvcnRlZFVuaW9uT3B0aW9uVHlwZShvcHRpb24udHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbi50eXBlID09PSAnaW50ZWdlcicgPyAnbnVtYmVyJyA6IG9wdGlvbi50eXBlO1xuICAgICAgb3B0aW9ucy5wdXNoKHR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVtaXR0ZWQ6IEVtaXR0ZWRUeXBlID0geyB0eXBlOiB0eXBlTmFtZSwgdG9Kc29uOiB4ID0+IGAke3h9Py52YWx1ZWAgfTtcblxuICAgIHRoaXMuYWRkQ29kZSh0eXBlTmFtZSwgY29kZSA9PiB7XG4gICAgICB0aGlzLmVtaXREZXNjcmlwdGlvbihjb2RlLCBmcW4sIGRlZi5kZXNjcmlwdGlvbik7XG5cbiAgICAgIGNvZGUub3BlbkJsb2NrKGBleHBvcnQgY2xhc3MgJHt0eXBlTmFtZX1gKTtcbiAgICAgIGNvbnN0IHBvc3NpYmxlVHlwZXMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgcG9zc2libGVUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICBjb25zdCBtZXRob2ROYW1lID0gJ2Zyb20nICsgdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSk7XG4gICAgICAgIGNvZGUub3BlbkJsb2NrKGBwdWJsaWMgc3RhdGljICR7bWV0aG9kTmFtZX0odmFsdWU6ICR7dHlwZX0pOiAke3R5cGVOYW1lfWApO1xuICAgICAgICBjb2RlLmxpbmUoYHJldHVybiBuZXcgJHt0eXBlTmFtZX0odmFsdWUpO2ApO1xuICAgICAgICBjb2RlLmNsb3NlQmxvY2soKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5vcGVuQmxvY2soYHByaXZhdGUgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHZhbHVlOiAke3Bvc3NpYmxlVHlwZXMuam9pbignIHwgJyl9KWApO1xuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAgIGNvZGUuY2xvc2VCbG9jaygpO1xuXG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbWl0dGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0U3RydWN0KHR5cGVOYW1lOiBzdHJpbmcsIHN0cnVjdERlZjogSlNPTlNjaGVtYTQsIHN0cnVjdEZxbjogc3RyaW5nKTogRW1pdHRlZFR5cGUge1xuICAgIGNvbnN0IHRvSnNvbiA9IG5ldyBUb0pzb25GdW5jdGlvbih0eXBlTmFtZSk7XG4gICAgY29uc3QgZW1pdHRlZDogRW1pdHRlZFR5cGUgPSB7XG4gICAgICB0eXBlOiB0eXBlTmFtZSxcbiAgICAgIHRvSnNvbjogeCA9PiBgJHt0b0pzb24uZnVuY3Rpb25OYW1lfSgke3h9KWAsXG4gICAgfTtcblxuICAgIHRoaXMuZW1pdEN1c3RvbVR5cGUodHlwZU5hbWUsIGNvZGUgPT4ge1xuXG4gICAgICB0aGlzLmVtaXREZXNjcmlwdGlvbihjb2RlLCBzdHJ1Y3RGcW4sIHN0cnVjdERlZi5kZXNjcmlwdGlvbik7XG4gICAgICBjb2RlLm9wZW5CbG9jayhgZXhwb3J0IGludGVyZmFjZSAke3R5cGVOYW1lfWApO1xuXG4gICAgICBmb3IgKGNvbnN0IFtwcm9wTmFtZSwgcHJvcFNwZWNdIG9mIE9iamVjdC5lbnRyaWVzKHN0cnVjdERlZi5wcm9wZXJ0aWVzIHx8IHt9KSkge1xuICAgICAgICB0aGlzLmVtaXRQcm9wZXJ0eShjb2RlLCBwcm9wTmFtZSwgcHJvcFNwZWMsIHN0cnVjdEZxbiwgc3RydWN0RGVmLCB0b0pzb24pO1xuICAgICAgfVxuXG4gICAgICBjb2RlLmNsb3NlQmxvY2soKTtcblxuICAgICAgaWYgKHRoaXMudG9Kc29uKSB7XG4gICAgICAgIHRvSnNvbi5lbWl0KGNvZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbWl0dGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0UHJvcGVydHkoY29kZTogQ29kZSwgbmFtZTogc3RyaW5nLCBwcm9wRGVmOiBKU09OU2NoZW1hNCwgc3RydWN0RnFuOiBzdHJpbmcsIHN0cnVjdERlZjogSlNPTlNjaGVtYTQsIHRvSnNvbjogVG9Kc29uRnVuY3Rpb24pIHtcbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBuYW1lO1xuXG4gICAgLy8gaWYgdGhlIG5hbWUgc3RhcnRzIHdpdGggJyQnIChsaWtlICRyZWYgb3IgJHNjaGVtYSksIHdlIHJlbW92ZSB0aGUgXCIkXCJcbiAgICAvLyBhbmQgaXQncyB0aGUgc2FtZSBkZWFsIC0gd2lsbCBwcm9kdWNlIGludmFsaWQgb3V0cHV0XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0aGUgbmFtZSB0byBjYW1lbCBjYXNlIHNvIGl0J3MgY29tcGF0aWJsZSB3aXRoIEpTSUlcbiAgICBuYW1lID0gY2FtZWxDYXNlKG5hbWUpO1xuXG4gICAgdGhpcy5lbWl0RGVzY3JpcHRpb24oY29kZSwgYCR7c3RydWN0RnFufSMke29yaWdpbmFsTmFtZX1gLCBwcm9wRGVmLmRlc2NyaXB0aW9uKTtcbiAgICBjb25zdCBwcm9wZXJ0eVR5cGUgPSB0aGlzLnR5cGVGb3JQcm9wZXJ0eShgJHtzdHJ1Y3RGcW59LiR7bmFtZX1gLCBwcm9wRGVmKTtcbiAgICBjb25zdCByZXF1aXJlZCA9IHRoaXMuaXNQcm9wZXJ0eVJlcXVpcmVkKG9yaWdpbmFsTmFtZSwgc3RydWN0RGVmKTtcbiAgICBjb25zdCBvcHRpb25hbCA9IHJlcXVpcmVkID8gJycgOiAnPyc7XG5cbiAgICBjb2RlLmxpbmUoYHJlYWRvbmx5ICR7bmFtZX0ke29wdGlvbmFsfTogJHtwcm9wZXJ0eVR5cGUudHlwZX07YCk7XG4gICAgY29kZS5saW5lKCk7XG5cbiAgICB0b0pzb24uYWRkRmllbGQob3JpZ2luYWxOYW1lLCBuYW1lLCBwcm9wZXJ0eVR5cGUudG9Kc29uKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEVudW0odHlwZU5hbWU6IHN0cmluZywgZGVmOiBKU09OU2NoZW1hNCwgc3RydWN0RnFuOiBzdHJpbmcpOiBFbWl0dGVkVHlwZSB7XG4gICAgY29uc3QgZW1pdHRlZDogRW1pdHRlZFR5cGUgPSB7XG4gICAgICB0eXBlOiB0eXBlTmFtZSxcbiAgICAgIHRvSnNvbjogeCA9PiB4LFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXRDdXN0b21UeXBlKHR5cGVOYW1lLCBjb2RlID0+IHtcblxuICAgICAgaWYgKCFkZWYuZW51bSB8fCBkZWYuZW51bS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkZWZpbml0aW9uIGlzIG5vdCBhbiBlbnVtOiAke0pTT04uc3RyaW5naWZ5KGRlZil9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWYudHlwZSAmJiAhKGRlZi50eXBlID09PSAnc3RyaW5nJyB8fCBkZWYudHlwZSA9PT0gJ251bWJlcicgfHwgZGVmLnR5cGUgPT09ICdpbnRlZ2VyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGVudW1zIHdpdGggc3RyaW5nIG9yIG51bWJlciB2YWx1ZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXREZXNjcmlwdGlvbihjb2RlLCBzdHJ1Y3RGcW4sIGRlZi5kZXNjcmlwdGlvbik7XG5cbiAgICAgIGNvZGUub3BlbkJsb2NrKGBleHBvcnQgZW51bSAke3R5cGVOYW1lfWApO1xuXG4gICAgICBjb25zdCBwcm9jZXNzZWRWYWx1ZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkZWYuZW51bSkge1xuICAgICAgICBpZiAoIVsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZih2YWx1ZSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGVudW1zIHdpdGggc3RyaW5nIG9yIG51bWJlciB2YWx1ZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lbWJlck5hbWUgPSBzbmFrZUNhc2UocmV3cml0ZU5hbWVkU3ltYm9scyhgJHt2YWx1ZX1gKS5yZXBsYWNlKC9bXmEtejAtOV0vZ2ksICdfJykpLnNwbGl0KCdfJykuZmlsdGVyKHggPT4geCkuam9pbignXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gSWYgZW51bXMgb2Ygc2FtZSB2YWx1ZSBleGlzdHMsIHRoZW4gd2UgY2hvb3NlIG9uZSBvZiB0aGVtIGFuZCBza2lwIGFkZGluZyBvdGhlcnNcbiAgICAgICAgLy8gc2luY2UgdGhhdCB3b3VsZCBjYXVzZSBjb25mbGljdFxuICAgICAgICBjb25zdCBsb3dlckNhc2VWYWx1ZSA9IHZhbHVlPy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNhc2VWYWx1ZSAmJiAhcHJvY2Vzc2VkVmFsdWVzLmhhcyhsb3dlckNhc2VWYWx1ZSkpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZXMuYWRkKGxvd2VyQ2FzZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG1lbWJlciBuYW1lIHN0YXJ0cyB3aXRoIGEgbm9uLWFscGhhIGNoYXJhY3RlciwgYWRkIGEgcHJlZml4IHNvIGl0IGJlY29tZXMgYSBzeW1ib2xcbiAgICAgICAgaWYgKCEvXltBLVpdLiovaS50ZXN0KG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgbWVtYmVyTmFtZSA9ICdWQUxVRV8nICsgbWVtYmVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUubGluZShgLyoqICR7dmFsdWV9ICovYCk7XG4gICAgICAgIGNvZGUubGluZShgJHttZW1iZXJOYW1lfSA9ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSxgKTtcbiAgICAgIH1cblxuICAgICAgY29kZS5jbG9zZUJsb2NrKCk7XG5cbiAgICAgIHJldHVybiBlbWl0dGVkO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVtaXR0ZWQ7XG4gIH1cblxuICBwcml2YXRlIGVtaXREZXNjcmlwdGlvbihjb2RlOiBDb2RlLCBmcW46IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcsIGFubm90YXRpb25zOiB7IFt0eXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgfSkge1xuICAgIGNvZGUubGluZSgnLyoqJyk7XG5cbiAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZSgvXFwqXFwvL2csICdfLycpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRsaW5lIG9mIGRlc2NyaXB0aW9uLnNwbGl0KCdcXG4nKS5tYXAoeCA9PiB4LnRyaW0oKSkpIHtcbiAgICAgICAgY29kZS5saW5lKGAgKiAke2RsaW5lfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYWN0RGVmYXVsdCA9IC9EZWZhdWx0cz9cXFcrKHRvfGlzKVxcVysoLispL2cuZXhlYyhkZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCBkZWYgPSBleHRyYWN0RGVmYXVsdCAmJiBleHRyYWN0RGVmYXVsdFsyXTtcbiAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgYW5ub3RhdGlvbnMuZGVmYXVsdCA9IGRlZjtcbiAgICAgIH1cblxuICAgICAgY29kZS5saW5lKCcgKicpO1xuICAgIH1cblxuICAgIGFubm90YXRpb25zLnNjaGVtYSA9IGZxbjtcblxuICAgIGZvciAoY29uc3QgW3R5cGUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbm5vdGF0aW9ucykpIHtcbiAgICAgIGNvZGUubGluZShgICogQCR7dHlwZX0gJHt2YWx1ZX1gKTtcbiAgICB9XG5cbiAgICBjb2RlLmxpbmUoJyAqLycpO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlRm9yUHJvcGVydHkocHJvcGVydHlGcW46IHN0cmluZywgZGVmOiBKU09OU2NoZW1hNCk6IEVtaXR0ZWRUeXBlIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gVHlwZUdlbmVyYXRvci5ub3JtYWxpemVUeXBlTmFtZShERUZBVUxUX1JFTkRFUl9UWVBFX05BTUUocHJvcGVydHlGcW4pKTtcbiAgICByZXR1cm4gdGhpcy5lbWl0VHlwZUludGVybmFsKHN1YnR5cGUsIGRlZiwgc3VidHlwZSk7XG4gIH1cblxuICBwcml2YXRlIHR5cGVGb3JSZWYoZGVmOiBKU09OU2NoZW1hNCk6IEVtaXR0ZWRUeXBlIHtcbiAgICBjb25zdCBwcmVmaXggPSAnIy9kZWZpbml0aW9ucy8nO1xuICAgIGlmICghZGVmLiRyZWYgfHwgIWRlZi4kcmVmLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkICRyZWYgJHtKU09OLnN0cmluZ2lmeShkZWYpfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRXhjbHVkZWQoZGVmLiRyZWYpKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAnYW55JywgdG9Kc29uOiB4ID0+IHggfTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlTmFtZSA9IFR5cGVHZW5lcmF0b3Iubm9ybWFsaXplVHlwZU5hbWUodGhpcy5yZW5kZXJUeXBlTmFtZShkZWYuJHJlZi5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCkpKTtcblxuICAgIC8vIGlmIHdlIGFscmVhZHkgZW1pdHRlZCBhIHR5cGUgd2l0aCB0aGlzIHR5cGUgbmFtZSwganVzdCByZXR1cm4gaXRcbiAgICBjb25zdCBlbWl0dGVkID0gdGhpcy5lbWl0dGVkVHlwZXNbdHlwZU5hbWVdO1xuICAgIGlmIChlbWl0dGVkKSB7XG4gICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICB9XG5cbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLnJlc29sdmVSZWZlcmVuY2UoZGVmKTtcbiAgICByZXR1cm4gdGhpcy5lbWl0VHlwZUludGVybmFsKHR5cGVOYW1lLCBzY2hlbWEsIGRlZi4kcmVmKTtcbiAgfVxuXG4gIHByaXZhdGUgdHlwZUZvckFycmF5KHByb3BlcnR5RnFuOiBzdHJpbmcsIGRlZjogSlNPTlNjaGVtYTQpOiBFbWl0dGVkVHlwZSB7XG4gICAgaWYgKCFkZWYuaXRlbXMgfHwgdHlwZW9mKGRlZi5pdGVtcykgIT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBGYWxsaW5nIGJhY2sgdG8gYW4gYXJyYXkgb2YgYW55IHR5cGVcbiAgICAgIGRlZi5pdGVtcyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnR5cGVGb3JQcm9wZXJ0eShwcm9wZXJ0eUZxbiwgZGVmLml0ZW1zKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVJlZmVyZW5jZShkZWY6IEpTT05TY2hlbWE0KTogSlNPTlNjaGVtYTQge1xuICAgIGNvbnN0IHJlZiA9IGRlZi4kcmVmO1xuICAgIGlmICghcmVmIHx8ICFyZWYuc3RhcnRzV2l0aChERUZJTklUSU9OU19QUkVGSVgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhIGxvY2FsIHJlZmVyZW5jZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvb2t1cCA9IHJlZi5zdWJzdHIoREVGSU5JVElPTlNfUFJFRklYLmxlbmd0aCk7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLmRlZmluaXRpb25zW2xvb2t1cF07XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBhIGRlZmluaXRpb24gZm9yIHRoZSAkcmVmIFwiJHtsb29rdXB9XCJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICBwcml2YXRlIGlzUHJvcGVydHlSZXF1aXJlZChwcm9wZXJ0eTogc3RyaW5nLCBzdHJ1Y3REZWY6IEpTT05TY2hlbWE0KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3RydWN0RGVmLnJlcXVpcmVkKSAmJiBzdHJ1Y3REZWYucmVxdWlyZWQuaW5jbHVkZXMocHJvcGVydHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0V4Y2x1ZGVkKGZxbjogc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMuZXhjbHVkZSkge1xuICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgaWYgKHJlLnRlc3QoZnFuKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBzdXBwb3J0ZWRVbmlvbk9wdGlvblR5cGUodHlwZTogYW55KTogdHlwZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZSAmJiAodHlwZW9mKHR5cGUpID09PSAnc3RyaW5nJyAmJiBQUklNSVRJVkVfVFlQRVMuaW5jbHVkZXModHlwZSkpO1xufVxuXG5mdW5jdGlvbiBwYXNjYWxDYXNlKHM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjYW1lbENhc2UocywgeyBwYXNjYWxDYXNlOiB0cnVlIH0pO1xufVxuXG5pbnRlcmZhY2UgRW1pdHRlZFR5cGUge1xuICAvKipcbiAgICogVGhlIEphdmFTY3JpcHQgdHlwZSB0byBlbWl0LlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2RlIHRvIGNvbnZlcnQgYSBzdGF0ZW1lbnQgYHNgIGJhY2sgdG8gSlNPTi5cbiAgICovXG4gIHJlYWRvbmx5IHRvSnNvbjogKGNvZGU6IHN0cmluZykgPT4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiByZXdyaXRlTmFtZWRTeW1ib2xzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gIGxldCBjdXJzb3IgPSAwO1xuICB3aGlsZSAoY3Vyc29yIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgY29uc3QgW3ByZWZpeE5hbWUsIHByZWZpeExlbl0gPSBsb25nZXN0UHJlZml4TWF0Y2goaW5wdXQsIGN1cnNvciwgTkFNRURfU1lNQk9MUyk7XG4gICAgaWYgKHByZWZpeE5hbWUpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGBfJHtwcmVmaXhOYW1lfV9gLnNwbGl0KCcnKTtcbiAgICAgIHJldC5wdXNoKC4uLnByZWZpeCk7XG4gICAgICBjdXJzb3IgKz0gcHJlZml4TGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChpbnB1dC5jaGFyQXQoY3Vyc29yKSk7XG4gICAgICBjdXJzb3IgKz0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdW5kZXJzY29yZXMgaWYgaXRzIG9ubHkgcHJlZml4IHRvIGJlIHJldHVybmVkXG4gIGlmIChyZXRbMF0gPT09ICdfJykgeyByZXQudW5zaGlmdCgnVkFMVUUnKTsgfVxuICBpZiAocmV0W3JldC5sZW5ndGggLSAxXSA9PT0gJ18nKSB7IHJldC5wb3AoKTsgfVxuXG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGxvbmdlc3RQcmVmaXhNYXRjaChpbnB1dDogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBsb29rdXBUYWJsZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFtzdHJpbmcgfCB1bmRlZmluZWQsIG51bWJlcl0ge1xuICBsZXQgcmV0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGxldCBsb25nZXN0OiBudW1iZXIgPSAwO1xuXG4gIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhsb29rdXBUYWJsZSkpIHtcbiAgICBpZiAoaGFzU3ViU3RyaW5nQXQoaW5wdXQsIGluZGV4LCB2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gbG9uZ2VzdCAmJiAhaXNFeGVtcHRQYXR0ZXJuKGlucHV0LCBpbmRleCkpIHtcbiAgICAgIHJldCA9IG5hbWU7XG4gICAgICBsb25nZXN0ID0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3JldCwgbG9uZ2VzdF07XG59XG5cbmZ1bmN0aW9uIGhhc1N1YlN0cmluZ0F0KGlucHV0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIHN1YnN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChpbmRleCA9PSBpbnB1dC5pbmRleE9mKHN1YnN0cmluZywgaW5kZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhlbXB0UGF0dGVybihpbnB1dDogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGV4ZW1wdFBhdHRlcm5zID0gW1xuICAgIC8vIDkuOSwgOS5cbiAgICAvKD88PVxcZClcXC5cXGQvLFxuICBdO1xuXG4gIHJldHVybiBleGVtcHRQYXR0ZXJucy5zb21lKChwKSA9PiB0ZXN0UmVnZXhBdChwLCBpbnB1dCwgaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gdGVzdFJlZ2V4QXQocmVnZXg6IFJlZ0V4cCwgaW5wdXQ6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAocmVnZXgsICd5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IGluZGV4O1xuXG4gIHJldHVybiByZS50ZXN0KGlucHV0KTtcbn1cblxudHlwZSBUeXBlRW1pdHRlciA9IChjb2RlOiBDb2RlKSA9PiBFbWl0dGVkVHlwZTtcbnR5cGUgQ29kZUVtaXR0ZXIgPSAoY29kZTogQ29kZSkgPT4gdm9pZDtcbiJdfQ==